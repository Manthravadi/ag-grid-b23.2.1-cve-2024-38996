{
  "id": {
    "meta": {
      "all": "/** Unique ID for the node. Either provided by the application, or generated by the grid if not. */",
      "comment": "Unique ID for the node. Either provided by the application, or generated by the grid if not."
    },
    "type": {
      "returnType": "string | undefined"
    }
  },
  "data": {
    "meta": {
      "all": "/** The data as provided by the application.\n     * Can be `undefined` when using row grouping or during grid initialisation.\n     */",
      "comment": "The data as provided by the application.\nCan be `undefined` when using row grouping or during grid initialisation."
    },
    "type": {
      "returnType": "TData | undefined"
    }
  },
  "displayed": {
    "meta": {
      "all": "/** This will be `true` if it has a rowIndex assigned, otherwise `false`.\n     */",
      "comment": "This will be `true` if it has a rowIndex assigned, otherwise `false`."
    },
    "type": {
      "returnType": "boolean"
    }
  },
  "rowPinned": {
    "meta": {
      "all": "/** Either `'top'` or `'bottom'` if row pinned, otherwise `undefined` or `null`. */",
      "comment": "Either `'top'` or `'bottom'` if row pinned, otherwise `undefined` or `null`."
    },
    "type": {
      "returnType": "RowPinnedType"
    }
  },
  "selectable": {
    "meta": {
      "all": "/** Is this row selectable. */",
      "comment": "Is this row selectable."
    },
    "type": {
      "returnType": "boolean"
    }
  },
  "rowHeight": {
    "meta": {
      "all": "/** The height, in pixels, of this row. */",
      "comment": "The height, in pixels, of this row."
    },
    "type": {
      "returnType": "number | null | undefined"
    }
  },
  "rowTop": {
    "meta": {
      "all": "/** The row top position in pixels. */",
      "comment": "The row top position in pixels."
    },
    "type": {
      "returnType": "number | null"
    }
  },
  "group": {
    "meta": {
      "all": "/** `true` if this node is a group node (i.e. it has children) */",
      "comment": "`true` if this node is a group node (i.e. it has children)"
    },
    "type": {
      "returnType": "boolean | undefined"
    }
  },
  "firstChild": {
    "meta": {
      "all": "/** `true` if this is the first child in this group. Changes when data is sorted. */",
      "comment": "`true` if this is the first child in this group. Changes when data is sorted."
    },
    "type": {
      "returnType": "boolean"
    }
  },
  "lastChild": {
    "meta": {
      "all": "/** `true` if this is the last child in this group. Changes when data is sorted. */",
      "comment": "`true` if this is the last child in this group. Changes when data is sorted."
    },
    "type": {
      "returnType": "boolean"
    }
  },
  "childIndex": {
    "meta": {
      "all": "/** Index of this row with respect to its parent when grouping. Changes when data is sorted. */",
      "comment": "Index of this row with respect to its parent when grouping. Changes when data is sorted."
    },
    "type": {
      "returnType": "number"
    }
  },
  "level": {
    "meta": {
      "all": "/** How many levels this node is from the top when grouping. */",
      "comment": "How many levels this node is from the top when grouping."
    },
    "type": {
      "returnType": "number"
    }
  },
  "uiLevel": {
    "meta": {
      "all": "/** How many levels this node is from the top when grouping in the UI (only different to `parent` when `groupRemoveSingleChildren=true`).*/",
      "comment": "How many levels this node is from the top when grouping in the UI (only different to `parent` when `groupRemoveSingleChildren=true`)."
    },
    "type": {
      "returnType": "number"
    }
  },
  "parent": {
    "meta": {
      "all": "/** The parent node to this node, or empty if top level. */",
      "comment": "The parent node to this node, or empty if top level."
    },
    "type": {
      "returnType": "IRowNode<TData> | null"
    }
  },
  "stub": {
    "meta": {
      "all": "/** Used by server-side row model. `true` if this row node is a stub. A stub is a placeholder row with loading icon while waiting from row to be loaded. */",
      "comment": "Used by server-side row model. `true` if this row node is a stub. A stub is a placeholder row with loading icon while waiting from row to be loaded."
    },
    "type": {
      "returnType": "boolean | undefined"
    }
  },
  "failedLoad": {
    "meta": {
      "all": "/** Used by server side row model, `true` if this row node failed a load. */",
      "comment": "Used by server side row model, `true` if this row node failed a load."
    },
    "type": {
      "returnType": "boolean | undefined"
    }
  },
  "rowIndex": {
    "meta": {
      "all": "/** The current row index. If the row is filtered out or in a collapsed group, this value will be `null`. */",
      "comment": "The current row index. If the row is filtered out or in a collapsed group, this value will be `null`."
    },
    "type": {
      "returnType": "number | null"
    }
  },
  "quickFilterAggregateText": {
    "meta": {
      "all": "/** If using quick filter, stores a string representation of the row for searching against. */",
      "comment": "If using quick filter, stores a string representation of the row for searching against."
    },
    "type": {
      "returnType": "string | null"
    }
  },
  "master": {
    "meta": {
      "all": "/** `true` if this row is a master row, part of master / detail (ie row can be expanded to show detail). */",
      "comment": "`true` if this row is a master row, part of master / detail (ie row can be expanded to show detail)."
    },
    "type": {
      "returnType": "boolean"
    }
  },
  "detail": {
    "meta": {
      "all": "/** `true` if this row is a detail row, part of master / detail (ie child row of an expanded master row). */",
      "comment": "`true` if this row is a detail row, part of master / detail (ie child row of an expanded master row)."
    },
    "type": {
      "returnType": "boolean | undefined"
    }
  },
  "field": {
    "meta": {
      "all": "/** The field we are grouping on from our row data. */",
      "comment": "The field we are grouping on from our row data."
    },
    "type": {
      "returnType": "string | null"
    }
  },
  "key": {
    "meta": {
      "all": "/** The key value for this group. */",
      "comment": "The key value for this group."
    },
    "type": {
      "returnType": "string | null"
    }
  },
  "groupData": {
    "meta": {
      "all": "/** If using row grouping, contains the group values for this group. */",
      "comment": "If using row grouping, contains the group values for this group."
    },
    "type": {
      "returnType": "{ [key: string]: any | null } | null"
    }
  },
  "aggData": {
    "meta": {
      "all": "/** If using row grouping and aggregation, contains the aggregation data. */",
      "comment": "If using row grouping and aggregation, contains the aggregation data."
    },
    "type": {
      "returnType": "any"
    }
  },
  "rowGroupColumn": {
    "meta": {
      "all": "/** The row group column used for this group. */",
      "comment": "The row group column used for this group."
    },
    "type": {
      "returnType": "Column | null"
    }
  },
  "rowGroupIndex": {
    "meta": {
      "all": "/** If doing in-memory (client-side) grouping, this is the index of the group column this cell is for.\n     * This will always be the same as the level, unless we are collapsing groups, i.e. `groupRemoveSingleChildren=true`.\n     */",
      "comment": "If doing in-memory (client-side) grouping, this is the index of the group column this cell is for.\nThis will always be the same as the level, unless we are collapsing groups, i.e. `groupRemoveSingleChildren=true`."
    },
    "type": {
      "returnType": "number | null"
    }
  },
  "expanded": {
    "meta": {
      "all": "/** `true` if group is expanded, otherwise `false`. */",
      "comment": "`true` if group is expanded, otherwise `false`."
    },
    "type": {
      "returnType": "boolean"
    }
  },
  "leafGroup": {
    "meta": {
      "all": "/** `true` if this node is a group and the group is the bottom level in the tree. */",
      "comment": "`true` if this node is a group and the group is the bottom level in the tree."
    },
    "type": {
      "returnType": "boolean | undefined"
    }
  },
  "allLeafChildren": {
    "meta": {
      "all": "/** All lowest level nodes beneath this node, no groups. */",
      "comment": "All lowest level nodes beneath this node, no groups."
    },
    "type": {
      "returnType": "IRowNode<TData>[] | null"
    }
  },
  "allChildrenCount": {
    "meta": {
      "all": "/** Number of children and grand children. */",
      "comment": "Number of children and grand children."
    },
    "type": {
      "returnType": "number | null"
    }
  },
  "childrenAfterGroup": {
    "meta": {
      "all": "/** Children of this group. If multi levels of grouping, shows only immediate children. */",
      "comment": "Children of this group. If multi levels of grouping, shows only immediate children."
    },
    "type": {
      "returnType": "IRowNode<TData>[] | null"
    }
  },
  "childrenAfterSort": {
    "meta": {
      "all": "/** Sorted children of this group. */",
      "comment": "Sorted children of this group."
    },
    "type": {
      "returnType": "IRowNode<TData>[] | null"
    }
  },
  "childrenAfterFilter": {
    "meta": {
      "all": "/** Filtered children of this group. */",
      "comment": "Filtered children of this group."
    },
    "type": {
      "returnType": "IRowNode<TData>[] | null"
    }
  },
  "footer": {
    "meta": {
      "all": "/** `true` if row is a footer. Footers have `group = true` and `footer = true`. */",
      "comment": "`true` if row is a footer. Footers have `group = true` and `footer = true`."
    },
    "type": {
      "returnType": "boolean | undefined"
    }
  },
  "sibling": {
    "meta": {
      "all": "/** If using footers, reference to the footer node for this group. */",
      "comment": "If using footers, reference to the footer node for this group."
    },
    "type": {
      "returnType": "IRowNode<TData>"
    }
  },
  "setSelected": {
    "meta": {
      "all": "/** Select (or deselect) the node.\n     * @param newValue -`true` for selection, `false` for deselection.\n     * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact. Default: `false`\n     * @param source - Source property that will appear in the `selectionChanged` event. Default: `'api'`\n     */",
      "comment": "Select (or deselect) the node.",
      "tags": [
        {
          "name": "param",
          "comment": "-`true` for selection, `false` for deselection."
        },
        {
          "name": "param",
          "comment": "- If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact. Default: `false`"
        },
        {
          "name": "param",
          "comment": "- Source property that will appear in the `selectionChanged` event. Default: `'api'`"
        }
      ]
    },
    "type": {
      "arguments": {
        "newValue": "boolean",
        "clearSelection?": "boolean",
        "source?": "SelectionEventSourceType"
      },
      "returnType": "void"
    }
  },
  "isSelected": {
    "meta": {
      "all": "/** Returns:\n     * - `true` if node is selected.\n     * - `false` if the node isn't selected.\n     * - `undefined` if it's partially selected (group where not all children are selected).\n     */",
      "comment": "Returns:\n- `true` if node is selected.\n- `false` if the node isn't selected.\n- `undefined` if it's partially selected (group where not all children are selected)."
    },
    "type": {
      "arguments": {},
      "returnType": "boolean | undefined"
    }
  },
  "isRowPinned": {
    "meta": {
      "all": "/** Returns:\n     * - `true` if node is either pinned to the `top` or `bottom`.\n     * - `false` if the node isn't pinned.\n     */",
      "comment": "Returns:\n- `true` if node is either pinned to the `top` or `bottom`.\n- `false` if the node isn't pinned."
    },
    "type": {
      "arguments": {},
      "returnType": "boolean"
    }
  },
  "isExpandable": {
    "meta": {
      "all": "/** Returns:\n     * - `true` if the node can be expanded, i.e it is a group or master row.\n     * - `false` if the node cannot be expanded.\n     */",
      "comment": "Returns:\n- `true` if the node can be expanded, i.e it is a group or master row.\n- `false` if the node cannot be expanded."
    },
    "type": {
      "arguments": {},
      "returnType": "boolean"
    }
  },
  "setExpanded": {
    "meta": {
      "all": "/** Set the expanded state of this rowNode.\n     * @param expanded - `true` to expand, `false` to collapse.\n     * @param sourceEvent - Optional event that will be passed to the `rowGroupOpened` event.\n     * @param forceSync - By default rows are expanded asynchronously for best performance. Set to `true` if you need to interact with the expanded row immediately after this function.\n     */",
      "comment": "Set the expanded state of this rowNode.",
      "tags": [
        {
          "name": "param",
          "comment": "- `true` to expand, `false` to collapse."
        },
        {
          "name": "param",
          "comment": "- Optional event that will be passed to the `rowGroupOpened` event."
        },
        {
          "name": "param",
          "comment": "- By default rows are expanded asynchronously for best performance. Set to `true` if you need to interact with the expanded row immediately after this function."
        }
      ]
    },
    "type": {
      "arguments": {
        "expanded": "boolean",
        "sourceEvent?": "MouseEvent | KeyboardEvent",
        "forceSync?": "boolean"
      },
      "returnType": "void"
    }
  },
  "isFullWidthCell": {
    "meta": {
      "all": "/** Returns:\n     * - `true` if the node is a full width cell.\n     * - `false` if the node is not a full width cell.\n     */",
      "comment": "Returns:\n- `true` if the node is a full width cell.\n- `false` if the node is not a full width cell."
    },
    "type": {
      "arguments": {},
      "returnType": "boolean"
    }
  },
  "isHovered": {
    "meta": {
      "all": "/** Returns:\n     * - `true` if the node is currently hovered.\n     * - `false` if the node is not hovered.\n     */",
      "comment": "Returns:\n- `true` if the node is currently hovered.\n- `false` if the node is not hovered."
    },
    "type": {
      "arguments": {},
      "returnType": "boolean"
    }
  },
  "addEventListener": {
    "meta": {
      "all": "/** Add an event listener. */",
      "comment": "Add an event listener."
    },
    "type": {
      "arguments": {
        "eventType": "T",
        "userListener": "AgRowNodeEventListener<T>"
      },
      "returnType": "void"
    }
  },
  "removeEventListener": {
    "meta": {
      "all": "/** Remove event listener. */",
      "comment": "Remove event listener."
    },
    "type": {
      "arguments": {
        "eventType": "T",
        "userListener": "AgRowNodeEventListener<T>"
      },
      "returnType": "void"
    }
  },
  "resetQuickFilterAggregateText": {
    "meta": {
      "all": "/** The first time `quickFilter` runs, the grid creates a one-off string representation of the row.\n     * This string is then used for the quick filter instead of hitting each column separately.\n     * When you edit, using grid editing, this string gets cleared down.\n     * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.\n     * Otherwise new values will not work with the `quickFilter`.\n     */",
      "comment": "The first time `quickFilter` runs, the grid creates a one-off string representation of the row.\nThis string is then used for the quick filter instead of hitting each column separately.\nWhen you edit, using grid editing, this string gets cleared down.\nHowever if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.\nOtherwise new values will not work with the `quickFilter`."
    },
    "type": {
      "arguments": {},
      "returnType": "void"
    }
  },
  "depthFirstSearch": {
    "meta": {
      "all": "/** Perform a depth-first search of this node and its children. */",
      "comment": "Perform a depth-first search of this node and its children."
    },
    "type": {
      "arguments": {
        "callback": "(rowNode: IRowNode<TData>) => void"
      },
      "returnType": "void"
    }
  },
  "setRowHeight": {
    "meta": {
      "all": "/** Sets the row height.\n     * Call if you want to change the height initially assigned to the row.\n     * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows.\n     * @param rowHeight - new height of the row\n     * @param estimated - is this an estimated height. Default: `false`\n     */",
      "comment": "Sets the row height.\nCall if you want to change the height initially assigned to the row.\nAfter calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows.",
      "tags": [
        {
          "name": "param",
          "comment": "- new height of the row"
        },
        {
          "name": "param",
          "comment": "- is this an estimated height. Default: `false`"
        }
      ]
    },
    "type": {
      "arguments": {
        "rowHeight": "number | undefined | null",
        "estimated?": "boolean"
      },
      "returnType": "void"
    }
  },
  "setData": {
    "meta": {
      "all": "/** Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.\n     */",
      "comment": "Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed."
    },
    "type": {
      "arguments": {
        "data": "TData"
      },
      "returnType": "void"
    }
  },
  "updateData": {
    "meta": {
      "all": "/** Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.\n     */",
      "comment": "Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed."
    },
    "type": {
      "arguments": {
        "data": "TData"
      },
      "returnType": "void"
    }
  },
  "setDataValue": {
    "meta": {
      "all": "/** Replaces the value on the `rowNode` for the specified column. When complete,\n     * the grid will refresh the rendered cell on the required row only.\n     * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.\n     *\n     * @param colKey The column where the value should be updated\n     * @param newValue The new value\n     * @param eventSource The source of the event\n     * @returns `true` if the value was changed, otherwise `false`.\n     */",
      "comment": "Replaces the value on the `rowNode` for the specified column. When complete,\nthe grid will refresh the rendered cell on the required row only.\n**Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.",
      "tags": [
        {
          "name": "param",
          "comment": "The column where the value should be updated"
        },
        {
          "name": "param",
          "comment": "The new value"
        },
        {
          "name": "param",
          "comment": "The source of the event"
        },
        {
          "name": "returns",
          "comment": "`true` if the value was changed, otherwise `false`."
        }
      ]
    },
    "type": {
      "arguments": {
        "colKey": "string | Column",
        "newValue": "any",
        "eventSource?": "string"
      },
      "returnType": "boolean"
    }
  },
  "getRoute": {
    "meta": {
      "all": "/** Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.\n     * If the Row Node is not a group, it returns `undefined`.\n     */",
      "comment": "Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.\nIf the Row Node is not a group, it returns `undefined`."
    },
    "type": {
      "arguments": {},
      "returnType": "string[] | undefined"
    }
  }
}