{
  "DetailGridInfo": {
    "meta": {},
    "type": {
      "id": "string",
      "api?": "GridApi"
    },
    "docs": {
      "id": "/** Id of the detail grid, the format is `detail_{ROW-ID}`,\n     * where `ROW-ID` is the `id` of the parent row.\n     */",
      "api?": "/** Grid api of the detail grid. */"
    }
  },
  "StartEditingCellParams": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "colKey": "string | Column",
      "rowPinned?": "RowPinnedType",
      "key?": "string"
    },
    "docs": {
      "rowIndex": "/** The row index of the row to start editing */",
      "colKey": "/** The column key of the row to start editing */",
      "rowPinned?": "/** Set to `'top'` or `'bottom'` to start editing a pinned row */",
      "key?": "/** The key to pass to the cell editor */"
    }
  },
  "GetCellValueParams": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "rowNode": "IRowNode",
      "colKey": "string | Column<TValue>",
      "useFormatter?": "boolean"
    },
    "docs": {
      "rowNode": "/** The row node to get the value from */",
      "colKey": "/** The column to get the value from */",
      "useFormatter?": "/** If `true` formatted value will be returned. */"
    }
  },
  "GridApi": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "getGridId()": "string",
      "addDetailGridInfo(id: string, gridInfo: DetailGridInfo)": "void",
      "removeDetailGridInfo(id: string)": "void",
      "getDetailGridInfo(id: string)": "DetailGridInfo | undefined",
      "forEachDetailGridInfo(callback: (gridInfo: DetailGridInfo, index: number) => void)": "void",
      "getDataAsCsv(params?: CsvExportParams)": "string | undefined",
      "exportDataAsCsv(params?: CsvExportParams)": "void",
      "getDataAsExcel(params?: ExcelExportParams)": "string | Blob | undefined",
      "exportDataAsExcel(params?: ExcelExportParams)": "void",
      "getSheetDataForExcel(params?: ExcelExportParams)": "string | undefined",
      "getMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "Blob | undefined",
      "exportMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "void",
      "setGridAriaProperty(property: string, value: string | null)": "void",
      "getPinnedTopRowCount()": "number",
      "getPinnedBottomRowCount()": "number",
      "getPinnedTopRow(index: number)": "IRowNode | undefined",
      "getPinnedBottomRow(index: number)": "IRowNode | undefined",
      "expireValueCache()": "void",
      "getVerticalPixelRange()": "{ top: number; bottom: number; }",
      "getHorizontalPixelRange()": "{ left: number; right: number; }",
      "refreshCells(params?: RefreshCellsParams<TData>)": "void",
      "flashCells(params?: FlashCellsParams<TData>)": "void",
      "redrawRows(params?: RedrawRowsParams<TData>)": "void",
      "refreshHeader()": "void",
      "isAnyFilterPresent()": "boolean",
      "isColumnFilterPresent()": "boolean",
      "isQuickFilterPresent()": "boolean",
      "getModel()": "IRowModel",
      "setRowNodeExpanded(rowNode: IRowNode, expanded: boolean, expandParents?: boolean, forceSync?: boolean)": "void",
      "onGroupExpandedOrCollapsed()": "void",
      "refreshClientSideRowModel(step?: ClientSideRowModelStep)": "void",
      "isAnimationFrameQueueEmpty()": "boolean",
      "flushAllAnimationFrames()": "void",
      "getRowNode(id: string)": "IRowNode<TData> | undefined",
      "getSizesForCurrentTheme()": "{ rowHeight: number; headerHeight: number; }",
      "expandAll()": "void",
      "collapseAll()": "void",
      "addRenderedRowListener(eventName: RenderedRowEvent, rowIndex: number, callback: (...args: any[]) => any)": "void",
      "getQuickFilter()": "string | undefined",
      "getAdvancedFilterModel()": "AdvancedFilterModel | null",
      "setAdvancedFilterModel(advancedFilterModel: AdvancedFilterModel | null)": "void",
      "showAdvancedFilterBuilder()": "void",
      "hideAdvancedFilterBuilder()": "void",
      "setNodesSelected(params: { nodes: IRowNode[]; newValue: boolean; source?: SelectionEventSourceType; })": "void",
      "selectAll(source?: SelectionEventSourceType)": "void",
      "deselectAll(source?: SelectionEventSourceType)": "void",
      "selectAllFiltered(source?: SelectionEventSourceType)": "void",
      "deselectAllFiltered(source?: SelectionEventSourceType)": "void",
      "getServerSideSelectionState()": "IServerSideSelectionState | IServerSideGroupSelectionState | null",
      "setServerSideSelectionState(state: IServerSideSelectionState | IServerSideGroupSelectionState)": "void",
      "selectAllOnCurrentPage(source?: SelectionEventSourceType)": "void",
      "deselectAllOnCurrentPage(source?: SelectionEventSourceType)": "void",
      "showLoadingOverlay()": "void",
      "showNoRowsOverlay()": "void",
      "hideOverlay()": "void",
      "getSelectedNodes()": "IRowNode<TData>[]",
      "getSelectedRows()": "TData[]",
      "getBestCostNodeSelection()": "IRowNode<TData>[] | undefined",
      "getRenderedNodes()": "IRowNode<TData>[]",
      "ensureColumnVisible(key: string | Column, position?: 'auto' | 'start' | 'middle' | 'end')": "void",
      "ensureIndexVisible(index: number, position?: 'top' | 'bottom' | 'middle' | null)": "void",
      "ensureNodeVisible(nodeSelector: TData | IRowNode<TData> | ((row: IRowNode<TData>) => boolean), position?: 'top' | 'bottom' | 'middle' | null)": "void",
      "forEachLeafNode(callback: (rowNode: IRowNode<TData>) => void)": "void",
      "forEachNode(callback: (rowNode: IRowNode<TData>, index: number) => void, includeFooterNodes?: boolean)": "void",
      "forEachNodeAfterFilter(callback: (rowNode: IRowNode<TData>, index: number) => void)": "void",
      "forEachNodeAfterFilterAndSort(callback: (rowNode: IRowNode<TData>, index: number) => void)": "void",
      "getFilterInstance(key: string | Column, callback?: (filter: TFilter | null) => void)": "undefined",
      "getColumnFilterInstance(key: string | Column)": "Promise<TFilter | null | undefined>",
      "destroyFilter(key: string | Column)": "void",
      "getStatusPanel(key: string)": "TStatusPanel | undefined",
      "getColumnDef(key: string | Column<TValue>)": "ColDef<TData, TValue> | null",
      "getColumnDefs()": "(ColDef<TData> | ColGroupDef<TData>)[] | undefined",
      "onFilterChanged(source?: FilterChangedEventSourceType)": "void",
      "onSortChanged()": "void",
      "setFilterModel(model: FilterModel | null)": "void",
      "getFilterModel()": "FilterModel",
      "getColumnFilterModel(column: string | Column)": "TModel | null",
      "setColumnFilterModel(column: string | Column, model: TModel | null)": "Promise<void>",
      "getFocusedCell()": "CellPosition | null",
      "clearFocusedCell()": "void",
      "setFocusedCell(rowIndex: number, colKey: string | Column, rowPinned?: RowPinnedType)": "void",
      "setFocusedHeader(colKey: string | Column | ColumnGroup, floatingFilter?: boolean)": "void",
      "addRowDropZone(params: RowDropZoneParams)": "void",
      "removeRowDropZone(params: RowDropZoneParams)": "void",
      "getRowDropZoneParams(events?: RowDropZoneEvents)": "RowDropZoneParams",
      "isSideBarVisible()": "boolean",
      "setSideBarVisible(show: boolean)": "void",
      "setSideBarPosition(position: 'left' | 'right')": "void",
      "openToolPanel(key: string)": "void",
      "closeToolPanel()": "void",
      "getOpenedToolPanel()": "string | null",
      "refreshToolPanel()": "void",
      "isToolPanelShowing()": "boolean",
      "getToolPanelInstance(id: 'columns')": "IColumnToolPanel | undefined",
      "getToolPanelInstance(id: 'filters')": "IFiltersToolPanel | undefined",
      "getToolPanelInstance(id: string)": "TToolPanel | undefined",
      "getSideBar()": "SideBarDef | undefined",
      "resetRowHeights()": "void",
      "setRowCount(rowCount: number, maxRowFound?: boolean)": "void",
      "onRowHeightChanged()": "void",
      "getValue(colKey: string | Column<TValue>, rowNode: IRowNode)": "TValue | null | undefined",
      "getCellValue(params: { rowNode: IRowNode; colKey: string | Column<TValue>; useFormatter: true; })": "string | null | undefined",
      "getCellValue(params: GetCellValueParams<TValue>)": "string | TValue | null | undefined",
      "addEventListener(eventType: TEventType, listener: AgEventListener<TData, any, TEventType>)": "void",
      "removeEventListener(eventType: TEventType, listener: AgEventListener<TData, any, TEventType>)": "void",
      "addGlobalListener(listener: AgGlobalEventListener<TData, any, TEventType>)": "void",
      "removeGlobalListener(listener: AgGlobalEventListener<TData, any, TEventType>)": "void",
      "dispatchEvent(event: AgEvent)": "void",
      "destroy()": "void",
      "isDestroyed()": "boolean",
      "resetQuickFilter()": "void",
      "getCellRanges()": "CellRange[] | null",
      "addCellRange(params: CellRangeParams)": "void",
      "clearRangeSelection()": "void",
      "undoCellEditing()": "void",
      "redoCellEditing()": "void",
      "getCurrentUndoSize()": "number",
      "getCurrentRedoSize()": "number",
      "getChartModels()": "ChartModel[] | undefined",
      "getChartRef(chartId: string)": "ChartRef | undefined",
      "getChartImageDataURL(params: GetChartImageDataUrlParams)": "string | undefined",
      "downloadChart(params: ChartDownloadParams)": "void",
      "openChartToolPanel(params: OpenChartToolPanelParams)": "void",
      "closeChartToolPanel(params: CloseChartToolPanelParams)": "void",
      "createRangeChart(params: CreateRangeChartParams)": "ChartRef | undefined",
      "createPivotChart(params: CreatePivotChartParams)": "ChartRef | undefined",
      "createCrossFilterChart(params: CreateCrossFilterChartParams)": "ChartRef | undefined",
      "updateChart(params: UpdateChartParams)": "void",
      "restoreChart(chartModel: ChartModel, chartContainer?: HTMLElement)": "ChartRef | undefined",
      "copyToClipboard(params?: IClipboardCopyParams)": "void",
      "cutToClipboard(params?: IClipboardCopyParams)": "void",
      "copySelectedRowsToClipboard(params?: IClipboardCopyRowsParams)": "void",
      "copySelectedRangeToClipboard(params?: IClipboardCopyParams)": "void",
      "copySelectedRangeDown()": "void",
      "pasteFromClipboard()": "void",
      "showColumnMenuAfterButtonClick(colKey: string | Column, buttonElement: HTMLElement)": "void",
      "showColumnMenuAfterMouseClick(colKey: string | Column, mouseEvent: MouseEvent | Touch)": "void",
      "showContextMenu(params?: IContextMenuParams)": "void",
      "showColumnChooser(params?: ColumnChooserParams)": "void",
      "showColumnFilter(colKey: string | Column)": "void",
      "showColumnMenu(colKey: string | Column)": "void",
      "hidePopupMenu()": "void",
      "hideColumnChooser()": "void",
      "tabToNextCell(event?: KeyboardEvent)": "boolean",
      "tabToPreviousCell(event?: KeyboardEvent)": "boolean",
      "getCellRendererInstances(params?: GetCellRendererInstancesParams<TData>)": "ICellRenderer[]",
      "getCellEditorInstances(params?: GetCellEditorInstancesParams<TData>)": "ICellEditor[]",
      "getEditingCells()": "CellPosition[]",
      "stopEditing(cancel?: boolean)": "void",
      "startEditingCell(params: StartEditingCellParams)": "void",
      "addAggFunc(key: string, aggFunc: IAggFunc)": "void",
      "addAggFuncs(aggFuncs: { [key: string]: IAggFunc; })": "void",
      "clearAggFuncs()": "void",
      "applyServerSideTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult | undefined",
      "applyServerSideTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void)": "void",
      "applyServerSideRowData(params: { successParams: LoadSuccessParams; route?: string[]; startRow?: number; })": "void",
      "retryServerSideLoads()": "void",
      "flushServerSideAsyncTransactions()": "void",
      "applyTransaction(rowDataTransaction: RowDataTransaction<TData>)": "RowNodeTransaction<TData> | null | undefined",
      "applyTransactionAsync(rowDataTransaction: RowDataTransaction<TData>, callback?: (res: RowNodeTransaction<TData>) => void)": "void",
      "flushAsyncTransactions()": "void",
      "refreshInfiniteCache()": "void",
      "purgeInfiniteCache()": "void",
      "refreshServerSide(params?: RefreshServerSideParams)": "void",
      "getServerSideGroupLevelState()": "ServerSideGroupLevelState[]",
      "getInfiniteRowCount()": "number | undefined",
      "isLastRowIndexKnown()": "boolean | undefined",
      "getCacheBlockState()": "any",
      "getFirstDisplayedRow()": "number",
      "getFirstDisplayedRowIndex()": "number",
      "getLastDisplayedRow()": "number",
      "getLastDisplayedRowIndex()": "number",
      "getDisplayedRowAtIndex(index: number)": "IRowNode<TData> | undefined",
      "getDisplayedRowCount()": "number",
      "paginationIsLastPageFound()": "boolean",
      "paginationGetPageSize()": "number",
      "paginationGetCurrentPage()": "number",
      "paginationGetTotalPages()": "number",
      "paginationGetRowCount()": "number",
      "paginationGoToNextPage()": "void",
      "paginationGoToPreviousPage()": "void",
      "paginationGoToFirstPage()": "void",
      "paginationGoToLastPage()": "void",
      "paginationGoToPage(page: number)": "void",
      "sizeColumnsToFit(paramsOrGridWidth?: ISizeColumnsToFitParams | number)": "void",
      "setColumnGroupOpened(group: ProvidedColumnGroup | string, newValue: boolean)": "void",
      "getColumnGroup(name: string, instanceId?: number)": "ColumnGroup | null",
      "getProvidedColumnGroup(name: string)": "ProvidedColumnGroup | null",
      "getDisplayNameForColumn(column: Column, location: HeaderLocation)": "string",
      "getDisplayNameForColumnGroup(columnGroup: ColumnGroup, location: HeaderLocation)": "string",
      "getColumn(key: string | ColDef<TData, TValue> | Column<TValue>)": "Column<TValue> | null",
      "getColumns()": "Column[] | null",
      "applyColumnState(params: ApplyColumnStateParams)": "boolean",
      "getColumnState()": "ColumnState[]",
      "resetColumnState()": "void",
      "getColumnGroupState()": "{ groupId: string; open: boolean; }[]",
      "setColumnGroupState(stateItems: { groupId: string; open: boolean; }[])": "void",
      "resetColumnGroupState()": "void",
      "isPinning()": "boolean",
      "isPinningLeft()": "boolean",
      "isPinningRight()": "boolean",
      "getDisplayedColAfter(col: Column)": "Column | null",
      "getDisplayedColBefore(col: Column)": "Column | null",
      "setColumnVisible(key: string | Column, visible: boolean)": "void",
      "setColumnsVisible(keys: (string | Column)[], visible: boolean)": "void",
      "setColumnPinned(key: string | ColDef | Column, pinned: ColumnPinnedType)": "void",
      "setColumnsPinned(keys: (string | ColDef | Column)[], pinned: ColumnPinnedType)": "void",
      "getAllGridColumns()": "Column[]",
      "getDisplayedLeftColumns()": "Column[]",
      "getDisplayedCenterColumns()": "Column[]",
      "getDisplayedRightColumns()": "Column[]",
      "getAllDisplayedColumns()": "Column[]",
      "getAllDisplayedVirtualColumns()": "Column[]",
      "moveColumn(key: string | ColDef | Column, toIndex: number)": "void",
      "moveColumnByIndex(fromIndex: number, toIndex: number)": "void",
      "moveColumns(columnsToMoveKeys: (string | ColDef | Column)[], toIndex: number)": "void",
      "moveRowGroupColumn(fromIndex: number, toIndex: number)": "void",
      "setColumnAggFunc(key: string | ColDef | Column, aggFunc: string | IAggFunc | null | undefined)": "void",
      "setColumnWidth(key: string | ColDef | Column, newWidth: number, finished?: boolean, source?: ColumnEventType)": "void",
      "setColumnWidths(columnWidths: { key: string | ColDef | Column; newWidth: number; }[], finished?: boolean, source?: ColumnEventType)": "void",
      "isPivotMode()": "boolean",
      "getPivotResultColumn(pivotKeys: string[], valueColKey: string | ColDef<TData, TValue> | Column<TValue>)": "Column<TValue> | null",
      "setValueColumns(colKeys: (string | ColDef | Column)[])": "void",
      "getValueColumns()": "Column[]",
      "removeValueColumn(colKey: string | ColDef | Column)": "void",
      "removeValueColumns(colKeys: (string | ColDef | Column)[])": "void",
      "addValueColumn(colKey: string | ColDef | Column)": "void",
      "addValueColumns(colKeys: (string | ColDef | Column)[])": "void",
      "setRowGroupColumns(colKeys: (string | ColDef | Column)[])": "void",
      "removeRowGroupColumn(colKey: string | ColDef | Column)": "void",
      "removeRowGroupColumns(colKeys: (string | ColDef | Column)[])": "void",
      "addRowGroupColumn(colKey: string | ColDef | Column)": "void",
      "addRowGroupColumns(colKeys: (string | ColDef | Column)[])": "void",
      "getRowGroupColumns()": "Column[]",
      "setPivotColumns(colKeys: (string | ColDef | Column)[])": "void",
      "removePivotColumn(colKey: string | ColDef | Column)": "void",
      "removePivotColumns(colKeys: (string | ColDef | Column)[])": "void",
      "addPivotColumn(colKey: string | ColDef | Column)": "void",
      "addPivotColumns(colKeys: (string | ColDef | Column)[])": "void",
      "getPivotColumns()": "Column[]",
      "getLeftDisplayedColumnGroups()": "(Column | ColumnGroup)[]",
      "getCenterDisplayedColumnGroups()": "(Column | ColumnGroup)[]",
      "getRightDisplayedColumnGroups()": "(Column | ColumnGroup)[]",
      "getAllDisplayedColumnGroups()": "(Column | ColumnGroup)[] | null",
      "autoSizeColumn(key: string | ColDef | Column, skipHeader?: boolean)": "void",
      "autoSizeColumns(keys: (string | ColDef | Column)[], skipHeader?: boolean)": "void",
      "autoSizeAllColumns(skipHeader?: boolean)": "void",
      "setPivotResultColumns(colDefs: (ColDef | ColGroupDef)[] | null)": "void",
      "getPivotResultColumns()": "Column[] | null",
      "getState()": "GridState",
      "getGridOption(key: Key)": "GridOptions<TData>[Key]",
      "setGridOption(key: Key, value: GridOptions<TData>[Key])": "void",
      "updateGridOptions(options: ManagedGridOptions<TDataUpdate>)": "void"
    },
    "docs": {
      "getGridId()": "/** Returns the `gridId` for the current grid as specified via the gridOptions property `gridId` or the auto assigned grid id if none was provided. */",
      "addDetailGridInfo(id: string, gridInfo: DetailGridInfo)": "/** Register a detail grid with the master grid when it is created. */",
      "removeDetailGridInfo(id: string)": "/** Unregister a detail grid from the master grid when it is destroyed. */",
      "getDetailGridInfo(id: string)": "/** Returns the `DetailGridInfo` corresponding to the supplied `detailGridId`. */",
      "forEachDetailGridInfo(callback: (gridInfo: DetailGridInfo, index: number) => void)": "/** Iterates through each `DetailGridInfo` in the grid and calls the supplied callback on each. */",
      "getDataAsCsv(params?: CsvExportParams)": "/** Similar to `exportDataAsCsv`, except returns the result as a string rather than download it. */",
      "exportDataAsCsv(params?: CsvExportParams)": "/** Downloads a CSV export of the grid's data. */",
      "getDataAsExcel(params?: ExcelExportParams)": "/** Similar to `exportDataAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */",
      "exportDataAsExcel(params?: ExcelExportParams)": "/** Downloads an Excel export of the grid's data. */",
      "getSheetDataForExcel(params?: ExcelExportParams)": "/** This is method to be used to get the grid's data as a sheet, that will later be exported either by `getMultipleSheetsAsExcel()` or `exportMultipleSheetsAsExcel()`. */",
      "getMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "/** Similar to `exportMultipleSheetsAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */",
      "exportMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "/** Downloads an Excel export of multiple sheets in one file. */",
      "setGridAriaProperty(property: string, value: string | null)": "/** Sets an ARIA property in the grid panel (element with `role=\\\"treegrid\\\"`), and removes an ARIA property when the value is null.\n     *\n     * Example: `api.setGridAriaProperty('label', 'my grid')` will set `aria-label=\\\"my grid\\\"`.\n     *\n     * `api.setGridAriaProperty('label', null)` will remove the `aria-label` attribute from the grid element.\n     */",
      "getPinnedTopRowCount()": "/** Gets the number of top pinned rows. */",
      "getPinnedBottomRowCount()": "/** Gets the number of bottom pinned rows. */",
      "getPinnedTopRow(index: number)": "/** Gets the top pinned row with the specified index. */",
      "getPinnedBottomRow(index: number)": "/** Gets the bottom pinned row with the specified index. */",
      "expireValueCache()": "/** Expire the value cache. */",
      "getVerticalPixelRange()": "/** Returns an object with two properties:\n     *  - `top`: The top pixel position of the current scroll in the grid\n     *  - `bottom`: The bottom pixel position of the current scroll in the grid\n     */",
      "getHorizontalPixelRange()": "/** Returns an object with two properties:\n     * - `left`: The left pixel position of the current scroll in the grid\n     * - `right`: The right pixel position of the current scroll in the grid\n     */",
      "refreshCells(params?: RefreshCellsParams<TData>)": "/** Performs change detection on all cells, refreshing cells where required. */",
      "flashCells(params?: FlashCellsParams<TData>)": "/** Flash rows, columns or individual cells. */",
      "redrawRows(params?: RedrawRowsParams<TData>)": "/** Remove row(s) from the DOM and recreate them again from scratch. */",
      "refreshHeader()": "/** Redraws the header. Useful if a column name changes, or something else that changes how the column header is displayed. */",
      "isAnyFilterPresent()": "/** Returns `true` if any filter is set. This includes quick filter, column filter, external filter or advanced filter. */",
      "isColumnFilterPresent()": "/** Returns `true` if any column filter is set, otherwise `false`. */",
      "isQuickFilterPresent()": "/** Returns `true` if the Quick Filter is set, otherwise `false`. */",
      "getModel()": "/** Returns the row model inside the table.\n     * From here you can see the original rows, rows after filter has been applied,\n     * rows after aggregation has been applied, and the final set of 'to be displayed' rows.\n     *\n     * @deprecated As of v31.1, getModel() is deprecated and will not be available in future versions.\n     * Please use the appropriate grid API methods instead\n     */",
      "setRowNodeExpanded(rowNode: IRowNode, expanded: boolean, expandParents?: boolean, forceSync?: boolean)": "/** Expand or collapse a specific row node, optionally expanding/collapsing all of its parent nodes.\n     * By default rows are expanded asynchronously for best performance. Set forceSync: `true` if you need to interact with the expanded row immediately after this function.\n     */",
      "onGroupExpandedOrCollapsed()": "/** Informs the grid that row group expanded state has changed and it needs to rerender the group nodes.\n     * Typically called after updating the row node expanded state explicitly, i.e `rowNode.expanded = false`,\n     * across multiple groups and you want to update the grid view in a single rerender instead of on every group change.\n     */",
      "refreshClientSideRowModel(step?: ClientSideRowModelStep)": "/** Refresh the Client-Side Row Model, executing the grouping, filtering and sorting again.\n     * Optionally provide the step you wish the refresh to apply from. Defaults to `everything`.\n     */",
      "isAnimationFrameQueueEmpty()": "/** Returns `true` when there are no more animation frames left to process. */",
      "getRowNode(id: string)": "/** Returns the row node with the given ID.\n     * The row node ID is the one you provide from the callback `getRowId(params)`,\n     * otherwise the ID is a number (cast as string) auto-generated by the grid when\n     * the row data is set.\n     */",
      "getSizesForCurrentTheme()": "/** Gets the sizes that various UI elements will be rendered at with the current theme.\n     * If you override the row or header height using `gridOptions`, the override value you provided will be returned.\n     */",
      "expandAll()": "/** Expand all groups. */",
      "collapseAll()": "/** Collapse all groups. */",
      "addRenderedRowListener(eventName: RenderedRowEvent, rowIndex: number, callback: (...args: any[]) => any)": "/** Registers a callback to a virtual row.\n     * A virtual row is a row that is visually rendered on the screen (rows that are not visible because of the scroll position are not rendered).\n     * Unlike normal events, you do not need to unregister rendered row listeners.\n     * When the rendered row is removed from the grid, all associated rendered row listeners will also be removed.\n     * listen for this event if your `cellRenderer` needs to do cleanup when the row no longer exists.\n     */",
      "getQuickFilter()": "/** Get the current Quick Filter text from the grid, or `undefined` if none is set. */",
      "getAdvancedFilterModel()": "/** Get the state of the Advanced Filter. Used for saving Advanced Filter state */",
      "setAdvancedFilterModel(advancedFilterModel: AdvancedFilterModel | null)": "/** Set the state of the Advanced Filter. Used for restoring Advanced Filter state */",
      "showAdvancedFilterBuilder()": "/** Open the Advanced Filter Builder dialog (if enabled). */",
      "hideAdvancedFilterBuilder()": "/** Closes the Advanced Filter Builder dialog (if enabled).\n     * Un-applied changes are discarded.\n     */",
      "setNodesSelected(params: { nodes: IRowNode[]; newValue: boolean; source?: SelectionEventSourceType; })": "/** Set all of the provided nodes selection state to the provided value.\n     */",
      "selectAll(source?: SelectionEventSourceType)": "/** Select all rows, regardless of filtering and rows that are not visible due to grouping being enabled and their groups not expanded.\n     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`\n     */",
      "deselectAll(source?: SelectionEventSourceType)": "/** Clear all row selections, regardless of filtering.\n     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`\n     */",
      "selectAllFiltered(source?: SelectionEventSourceType)": "/** Select all filtered rows.\n     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`\n     */",
      "deselectAllFiltered(source?: SelectionEventSourceType)": "/** Clear all filtered selections.\n     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`\n     */",
      "getServerSideSelectionState()": "/** Returns an object containing rules matching the selected rows in the SSRM.\n     *\n     * If `groupSelectsChildren=false` the returned object will be flat, and will conform to IServerSideSelectionState.\n     * If `groupSelectsChildren=true` the returned object will be hierarchical, and will conform to IServerSideGroupSelectionState.\n     */",
      "setServerSideSelectionState(state: IServerSideSelectionState | IServerSideGroupSelectionState)": "/** Set the rules matching the selected rows in the SSRM.\n     *\n     * If `groupSelectsChildren=false` the param will be flat, and should conform to IServerSideSelectionState.\n     * If `groupSelectsChildren=true` the param will be hierarchical, and should conform to IServerSideGroupSelectionState.\n     */",
      "selectAllOnCurrentPage(source?: SelectionEventSourceType)": "/** Select all rows on the current page.\n     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`\n     */",
      "deselectAllOnCurrentPage(source?: SelectionEventSourceType)": "/** Clear all filtered on the current page.\n     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`\n     */",
      "showLoadingOverlay()": "/** Show the 'loading' overlay.\n     * @deprecated v32 `showLoadingOverlay` is deprecated. Use the grid option \"loading\"=true instead or setGridOption(\"loading\", true).\n     */",
      "showNoRowsOverlay()": "/** Show the no-rows overlay. If `suppressNoRowsOverlay` is set, or if `loading` is true, this will not do anything. */",
      "hideOverlay()": "/** Hide the no-rows overlay if it is showing. */",
      "getSelectedNodes()": "/** Returns an unsorted list of selected nodes.\n     * Getting the underlying node (rather than the data) is useful when working with tree / aggregated data,\n     * as the node can be traversed.\n     */",
      "getSelectedRows()": "/** Returns an unsorted list of selected rows (i.e. row data that you provided). */",
      "getBestCostNodeSelection()": "/** Returns a list of all selected nodes at 'best cost', a feature to be used with groups / trees.\n     * If a group has all its children selected, then the group appears in the result, but not the children.\n     * Designed for use with `'children'` as the group selection type, where groups don't actually appear in the selection normally.\n     */",
      "getRenderedNodes()": "/** Retrieve rendered nodes. Due to virtualisation this will contain only the current visible rows and those in the buffer. */",
      "ensureColumnVisible(key: string | Column, position?: 'auto' | 'start' | 'middle' | 'end')": "/**  Ensures the column is visible by scrolling the table if needed.\n     *\n     * This will have no effect before the firstDataRendered event has fired.\n     *\n     * @param key - The column to ensure visible\n     * @param position - Where the column will be positioned. Defaults to `auto`\n     * - `auto` - Scrolls the minimum amount to make sure the column is visible.\n     * - `start` - Scrolls the column to the start of the viewport.\n     * - `middle` - Scrolls the column to the middle of the viewport.\n     * - `end` - Scrolls the column to the end of the viewport.\n     */",
      "ensureIndexVisible(index: number, position?: 'top' | 'bottom' | 'middle' | null)": "/** Vertically scrolls the grid until the provided row index is inside the visible viewport.\n     * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.\n     * This will have no effect before the firstDataRendered event has fired.\n     */",
      "ensureNodeVisible(nodeSelector: TData | IRowNode<TData> | ((row: IRowNode<TData>) => boolean), position?: 'top' | 'bottom' | 'middle' | null)": "/** Vertically scrolls the grid until the provided row (or a row matching the provided comparator) is inside the visible viewport.\n     * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.\n     * This will have no effect before the firstDataRendered event has fired.\n     */",
      "forEachLeafNode(callback: (rowNode: IRowNode<TData>) => void)": "/** Similar to `forEachNode`, except lists all the leaf nodes.\n     * This effectively goes through all the data that you provided to the grid before the grid performed any grouping.\n     * If using tree data, goes through all the nodes for the data you provided, including nodes that have children,\n     * but excluding groups the grid created where gaps were missing in the hierarchy.\n     */",
      "forEachNode(callback: (rowNode: IRowNode<TData>, index: number) => void, includeFooterNodes?: boolean)": "/** Iterates through each node (row) in the grid and calls the callback for each node.\n     * This works similar to the `forEach` method on a JavaScript array.\n     * This is called for every node, ignoring any filtering or sorting applied within the grid.\n     * If using the Infinite Row Model, then this gets called for each page loaded in the page cache.\n     */",
      "forEachNodeAfterFilter(callback: (rowNode: IRowNode<TData>, index: number) => void)": "/** Similar to `forEachNode`, except skips any filtered out data. */",
      "forEachNodeAfterFilterAndSort(callback: (rowNode: IRowNode<TData>, index: number) => void)": "/** Similar to `forEachNodeAfterFilter`, except the callbacks are called in the order the rows are displayed in the grid. */",
      "getFilterInstance(key: string | Column, callback?: (filter: TFilter | null) => void)": "/** @deprecated v31.1 To get/set individual filter models, use `getColumnFilterModel` or `setColumnFilterModel` instead.\n     * To get hold of the filter instance, use `getColumnFilterInstance` which returns the instance asynchronously.\n     * This method now only works asynchronously via the callback. The return value will always be `undefined`.\n     */",
      "getColumnFilterInstance(key: string | Column)": "/** Returns the filter component instance for a column.\n     * For getting/setting models for individual column filters, use `getColumnFilterModel` and `setColumnFilterModel` instead of this.\n     * `key` can be a column ID or a `Column` object.\n     */",
      "destroyFilter(key: string | Column)": "/** Destroys a filter. Useful to force a particular filter to be created from scratch again. */",
      "getStatusPanel(key: string)": "/** Gets the status panel instance corresponding to the supplied `id`. */",
      "getColumnDefs()": "/** Returns the current column definitions.\n     */",
      "onFilterChanged(source?: FilterChangedEventSourceType)": "/** Informs the grid that a filter has changed. This is typically called after a filter change through one of the filter APIs.\n     * @param source The source of the filter change event. If not specified defaults to `'api'`.\n     */",
      "onSortChanged()": "/** Gets the grid to act as if the sort was changed.\n     * Useful if you update some values and want to get the grid to reorder them according to the new values.\n     */",
      "setFilterModel(model: FilterModel | null)": "/** Sets the state of all the column filters. Provide it with what you get from `getFilterModel()` to restore filter state.\n     * If inferring cell data types, and row data is provided asynchronously and is yet to be set,\n     * the filter model will be applied asynchronously after row data is added.\n     * To always perform this synchronously, set `cellDataType = false` on the default column definition,\n     * or provide cell data types for every column.\n     */",
      "getFilterModel()": "/** Gets the current state of all the column filters. Used for saving filter state. */",
      "getColumnFilterModel(column: string | Column)": "/** Gets the current filter model for the specified column.\n     * Will return `null` if no active filter.\n     */",
      "setColumnFilterModel(column: string | Column, model: TModel | null)": "/** Sets the filter model for the specified column.\n     * Setting a `model` of `null` will reset the filter (make inactive).\n     * Must wait on the response before calling `api.onFilterChanged()`.\n     */",
      "getFocusedCell()": "/** Returns the focused cell (or the last focused cell if the grid lost focus). */",
      "clearFocusedCell()": "/** Clears the focused cell. */",
      "setFocusedCell(rowIndex: number, colKey: string | Column, rowPinned?: RowPinnedType)": "/** Sets the focus to the specified cell. `rowPinned` can be either 'top', 'bottom' or null (for not pinned). */",
      "setFocusedHeader(colKey: string | Column | ColumnGroup, floatingFilter?: boolean)": "/** Sets the focus to the specified header. If `floatingFilter` is true, the Column's floatingFilter element will be focused. */",
      "addRowDropZone(params: RowDropZoneParams)": "/** Adds a drop zone outside of the grid where rows can be dropped. */",
      "removeRowDropZone(params: RowDropZoneParams)": "/** Removes an external drop zone added by `addRowDropZone`. */",
      "getRowDropZoneParams(events?: RowDropZoneEvents)": "/** Returns the `RowDropZoneParams` to be used by another grid's `addRowDropZone` method. */",
      "isSideBarVisible()": "/** Returns `true` if the side bar is visible. */",
      "setSideBarVisible(show: boolean)": "/** Show/hide the entire side bar, including any visible panel and the tab buttons. */",
      "setSideBarPosition(position: 'left' | 'right')": "/** Sets the side bar position relative to the grid. Possible values are `'left'` or `'right'`. */",
      "openToolPanel(key: string)": "/** Opens a particular tool panel. Provide the ID of the tool panel to open. */",
      "closeToolPanel()": "/** Closes the currently open tool panel (if any). */",
      "getOpenedToolPanel()": "/** Returns the ID of the currently shown tool panel if any, otherwise `null`. */",
      "refreshToolPanel()": "/** Force refresh all tool panels by calling their `refresh` method. */",
      "isToolPanelShowing()": "/** Returns `true` if the tool panel is showing, otherwise `false`. */",
      "getToolPanelInstance(id: string)": "/** Gets the tool panel instance corresponding to the supplied `id`. */",
      "getSideBar()": "/** Returns the current side bar configuration. If a shortcut was used, returns the detailed long form. */",
      "resetRowHeights()": "/** Tells the grid to recalculate the row heights. */",
      "setRowCount(rowCount: number, maxRowFound?: boolean)": "/** Sets the `rowCount` and `maxRowFound` properties.\n     * The second parameter, `maxRowFound`, is optional and if left out, only `rowCount` is set.\n     * Set `rowCount` to adjust the height of the vertical scroll.\n     * Set `maxRowFound` to enable / disable searching for more rows.\n     * Use this method if you add or remove rows into the dataset and need to reset the number of rows or instruct the grid that the entire row count is no longer known.\n     */",
      "onRowHeightChanged()": "/** Tells the grid a row height has changed. To be used after calling `rowNode.setRowHeight(newHeight)`. */",
      "getValue(colKey: string | Column<TValue>, rowNode: IRowNode)": "/** @deprecated v31.3 Use `getCellValue` instead.\n     */",
      "getCellValue(params: { rowNode: IRowNode; colKey: string | Column<TValue>; useFormatter: true; })": "/** Gets the cell value for the given column and `rowNode` (row).\n     * Based on params.useFormatter with either return the value as specified by the `field` or `valueGetter` on the column definition or the formatted value.\n     */",
      "addEventListener(eventType: TEventType, listener: AgEventListener<TData, any, TEventType>)": "/** Add an event listener for the specified `eventType`.\n     * Listener will receive the `event` as a single parameter.\n     * Listeners will be automatically removed when the grid is destroyed.\n     * @example api.addEventListener('rowClicked', (event) => { console.log('Row clicked', event);});\n     */",
      "removeEventListener(eventType: TEventType, listener: AgEventListener<TData, any, TEventType>)": "/** Remove an event listener. */",
      "addGlobalListener(listener: AgGlobalEventListener<TData, any, TEventType>)": "/** Add an event listener for all event types coming from the grid.\n     * Listener will receive `eventType` and `event` as parameters.\n     * Listeners will be automatically removed when the grid is destroyed.\n     * If handling multiple event types it is recommended to use `event.type` to enable TypeScript to infer the event parameters.\n     * @example api.addGlobalListener((eventType, event) => { });\n     */",
      "removeGlobalListener(listener: AgGlobalEventListener<TData, any, TEventType>)": "/** Remove a global event listener. */",
      "destroy()": "/** Will destroy the grid and release resources. If you are using a framework you do not need to call this, as the grid links in with the framework lifecycle. However if you are using Web Components or native JavaScript, you do need to call this, to avoid a memory leak in your application. */",
      "isDestroyed()": "/** Returns `true` if the grid has been destroyed. */",
      "resetQuickFilter()": "/** Reset the Quick Filter cache text on every rowNode. */",
      "getCellRanges()": "/** Returns the list of selected cell ranges. */",
      "addCellRange(params: CellRangeParams)": "/** Adds the provided cell range to the selected ranges. */",
      "clearRangeSelection()": "/** Clears the selected ranges. */",
      "undoCellEditing()": "/** Reverts the last cell edit. */",
      "redoCellEditing()": "/** Re-applies the most recently undone cell edit. */",
      "getCurrentUndoSize()": "/** Returns current number of available cell edit undo operations. */",
      "getCurrentRedoSize()": "/** Returns current number of available cell edit redo operations. */",
      "getChartModels()": "/** Returns a list of models with information about the charts that are currently rendered from the grid. */",
      "getChartRef(chartId: string)": "/** Returns the `ChartRef` using the supplied `chartId`. */",
      "getChartImageDataURL(params: GetChartImageDataUrlParams)": "/** Returns a base64-encoded image data URL for the referenced chartId. */",
      "downloadChart(params: ChartDownloadParams)": "/** Starts a browser-based image download for the referenced chartId. */",
      "openChartToolPanel(params: OpenChartToolPanelParams)": "/** Open the Chart Tool Panel. */",
      "closeChartToolPanel(params: CloseChartToolPanelParams)": "/** Close the Chart Tool Panel. */",
      "createRangeChart(params: CreateRangeChartParams)": "/** Used to programmatically create charts from a range. */",
      "createPivotChart(params: CreatePivotChartParams)": "/** Used to programmatically create pivot charts from a grid. */",
      "createCrossFilterChart(params: CreateCrossFilterChartParams)": "/** Used to programmatically create cross filter charts from a range. */",
      "updateChart(params: UpdateChartParams)": "/** Used to programmatically update a chart. */",
      "restoreChart(chartModel: ChartModel, chartContainer?: HTMLElement)": "/** Restores a chart using the `ChartModel` that was previously obtained from `getChartModels()`. */",
      "copyToClipboard(params?: IClipboardCopyParams)": "/** Copies data to clipboard by following the same rules as pressing Ctrl+C. */",
      "cutToClipboard(params?: IClipboardCopyParams)": "/** Cuts data to clipboard by following the same rules as pressing Ctrl+X. */",
      "copySelectedRowsToClipboard(params?: IClipboardCopyRowsParams)": "/** Copies the selected rows to the clipboard. */",
      "copySelectedRangeToClipboard(params?: IClipboardCopyParams)": "/** Copies the selected ranges to the clipboard. */",
      "copySelectedRangeDown()": "/** Copies the selected range down, similar to `Ctrl + D` in Excel. */",
      "pasteFromClipboard()": "/** Pastes the data from the Clipboard into the focused cell of the grid. If no grid cell is focused, calling this method has no effect. */",
      "showColumnMenuAfterButtonClick(colKey: string | Column, buttonElement: HTMLElement)": "/** @deprecated v31.1 Use `IHeaderParams.showColumnMenu` within a header component, or `api.showColumnMenu` elsewhere. */",
      "showColumnMenuAfterMouseClick(colKey: string | Column, mouseEvent: MouseEvent | Touch)": "/** @deprecated v31.1 Use `IHeaderParams.showColumnMenuAfterMouseClick` within a header component, or `api.showColumnMenu` elsewhere. */",
      "showContextMenu(params?: IContextMenuParams)": "/** Displays the AG Grid context menu\n     */",
      "showColumnChooser(params?: ColumnChooserParams)": "/** Show the column chooser. */",
      "showColumnFilter(colKey: string | Column)": "/** Show the filter for the provided column. */",
      "showColumnMenu(colKey: string | Column)": "/** Show the column menu for the provided column. */",
      "hidePopupMenu()": "/** Hides any visible context menu or column menu. */",
      "hideColumnChooser()": "/** Hide the column chooser if visible. */",
      "tabToNextCell(event?: KeyboardEvent)": "/** Navigates the grid focus to the next cell, as if tabbing. */",
      "tabToPreviousCell(event?: KeyboardEvent)": "/** Navigates the grid focus to the previous cell, as if shift-tabbing. */",
      "getCellRendererInstances(params?: GetCellRendererInstancesParams<TData>)": "/** Returns the list of active cell renderer instances. */",
      "getCellEditorInstances(params?: GetCellEditorInstancesParams<TData>)": "/** Returns the list of active cell editor instances. Optionally provide parameters to restrict to certain columns / row nodes. */",
      "getEditingCells()": "/** If the grid is editing, returns back details of the editing cell(s). */",
      "stopEditing(cancel?: boolean)": "/** If a cell is editing, it stops the editing. Pass `true` if you want to cancel the editing (i.e. don't accept changes). */",
      "startEditingCell(params: StartEditingCellParams)": "/** Start editing the provided cell. If another cell is editing, the editing will be stopped in that other cell. */",
      "addAggFunc(key: string, aggFunc: IAggFunc)": "/** @deprecated v31.1 addAggFunc(key, func) is  deprecated, please use addAggFuncs({ key: func }) instead. */",
      "addAggFuncs(aggFuncs: { [key: string]: IAggFunc; })": "/** Add aggregations function with the specified keys. */",
      "clearAggFuncs()": "/** Clears all aggregation functions (including those provided by the grid). */",
      "applyServerSideTransaction(transaction: ServerSideTransaction)": "/** Apply transactions to the server side row model. */",
      "applyServerSideTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void)": "/** Batch apply transactions to the server side row model. */",
      "applyServerSideRowData(params: { successParams: LoadSuccessParams; route?: string[]; startRow?: number; })": "/** Applies row data to a server side store.\n     * New rows will overwrite rows at the same index in the same way as if provided by a datasource success callback.\n     */",
      "retryServerSideLoads()": "/** Gets all failed server side loads to retry. */",
      "applyTransaction(rowDataTransaction: RowDataTransaction<TData>)": "/** Update row data. Pass a transaction object with lists for `add`, `remove` and `update`. */",
      "applyTransactionAsync(rowDataTransaction: RowDataTransaction<TData>, callback?: (res: RowNodeTransaction<TData>) => void)": "/** Same as `applyTransaction` except executes asynchronously for efficiency. */",
      "flushAsyncTransactions()": "/** Executes any remaining asynchronous grid transactions, if any are waiting to be executed. */",
      "refreshInfiniteCache()": "/** Marks all the currently loaded blocks in the cache for reload.\n     * If you have 10 blocks in the cache, all 10 will be marked for reload.\n     * The old data will continue to be displayed until the new data is loaded.\n     */",
      "purgeInfiniteCache()": "/** Purges the cache.\n     * The grid is then told to refresh. Only the blocks required to display the current data on screen are fetched (typically no more than 2).\n     * The grid will display nothing while the new blocks are loaded.\n     * Use this to immediately remove the old data from the user.\n     */",
      "refreshServerSide(params?: RefreshServerSideParams)": "/** Refresh a server-side store level.\n     * If you pass no parameters, then the top level store is refreshed.\n     * To refresh a child level, pass in the string of keys to get to the desired level.\n     * Once the store refresh is complete, the storeRefreshed event is fired.\n     */",
      "getServerSideGroupLevelState()": "/** Returns info on all server side group levels. */",
      "getInfiniteRowCount()": "/** The row count defines how many rows the grid allows scrolling to. */",
      "isLastRowIndexKnown()": "/** Returns `true` if grid allows for scrolling past the last row to load more rows, thus providing infinite scroll. */",
      "getCacheBlockState()": "/** Returns an object representing the state of the cache. This is useful for debugging and understanding how the cache is working.\n     */",
      "getFirstDisplayedRow()": "/** @deprecated v31.1 `getFirstDisplayedRow` is deprecated. Please use `getFirstDisplayedRowIndex` instead. */",
      "getFirstDisplayedRowIndex()": "/** Get the index of the first displayed row due to scrolling (includes invisible rendered rows in the buffer). */",
      "getLastDisplayedRow()": "/** @deprecated v31.1 `getLastDisplayedRow` is deprecated. Please use `getLastDisplayedRowIndex` instead. */",
      "getLastDisplayedRowIndex()": "/** Get the index of the last displayed row due to scrolling (includes invisible rendered rows in the buffer). */",
      "getDisplayedRowAtIndex(index: number)": "/** Returns the displayed `RowNode` at the given `index`. */",
      "getDisplayedRowCount()": "/** Returns the total number of displayed rows. */",
      "paginationIsLastPageFound()": "/** Returns `true` when the last page is known.\n     * This will always be `true` if you are using the Client-Side Row Model for pagination.\n     * Returns `false` when the last page is not known; this only happens when using Infinite Row Model.\n     */",
      "paginationGetPageSize()": "/** Returns how many rows are being shown per page. */",
      "paginationGetCurrentPage()": "/** Returns the 0-based index of the page which is showing. */",
      "paginationGetTotalPages()": "/** Returns the total number of pages. Returns `null` if `paginationIsLastPageFound() === false`. */",
      "paginationGetRowCount()": "/** The total number of rows. Returns `null` if `paginationIsLastPageFound() === false`. */",
      "paginationGoToNextPage()": "/** Navigates to the next page. */",
      "paginationGoToPreviousPage()": "/** Navigates to the previous page. */",
      "paginationGoToFirstPage()": "/** Navigates to the first page. */",
      "paginationGoToLastPage()": "/** Navigates to the last page. */",
      "paginationGoToPage(page: number)": "/** Goes to the specified page. If the page requested doesn't exist, it will go to the last page. */",
      "sizeColumnsToFit(paramsOrGridWidth?: ISizeColumnsToFitParams | number)": "/** Adjusts the size of columns to fit the available horizontal space.\n     *\n     * Note: it is not recommended to call this method rapidly e.g. in response\n     * to window resize events or as the container size is animated. This can\n     * cause the scrollbar to flicker. Use column flex for smoother results.\n     *\n     * If inferring cell data types with custom column types\n     * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.\n     * To always perform this synchronously, set `cellDataType = false` on the default column definition.\n     **/",
      "setColumnGroupOpened(group: ProvidedColumnGroup | string, newValue: boolean)": "/** Call this if you want to open or close a column group. */",
      "getColumnGroup(name: string, instanceId?: number)": "/** Returns the column group with the given name. */",
      "getProvidedColumnGroup(name: string)": "/** Returns the provided column group with the given name. */",
      "getDisplayNameForColumn(column: Column, location: HeaderLocation)": "/** Returns the display name for a column. Useful if you are doing your own header rendering and want the grid to work out if `headerValueGetter` is used, or if you are doing your own column management GUI, to know what to show as the column name. */",
      "getDisplayNameForColumnGroup(columnGroup: ColumnGroup, location: HeaderLocation)": "/** Returns the display name for a column group (when grouping columns). */",
      "getColumn(key: string | ColDef<TData, TValue> | Column<TValue>)": "/** Returns the column with the given `colKey`, which can either be the `colId` (a string) or the `colDef` (an object). */",
      "getColumns()": "/** Returns all the columns, regardless of visible or not. */",
      "applyColumnState(params: ApplyColumnStateParams)": "/** Applies the state of the columns from a previous state. Returns `false` if one or more columns could not be found. */",
      "getColumnState()": "/** Gets the state of the columns. Typically used when saving column state. */",
      "resetColumnState()": "/** Sets the state back to match the originally provided column definitions. */",
      "getColumnGroupState()": "/** Gets the state of the column groups. Typically used when saving column group state. */",
      "setColumnGroupState(stateItems: { groupId: string; open: boolean; }[])": "/** Sets the state of the column group state from a previous state. */",
      "resetColumnGroupState()": "/** Sets the state back to match the originally provided column definitions. */",
      "isPinning()": "/** Returns `true` if pinning left or right, otherwise `false`. */",
      "isPinningLeft()": "/** Returns `true` if pinning left, otherwise `false`. */",
      "isPinningRight()": "/** Returns `true` if pinning right, otherwise `false`. */",
      "getDisplayedColAfter(col: Column)": "/** Returns the column to the right of the provided column, taking into consideration open / closed column groups and visible columns. This is useful if you need to know what column is beside yours e.g. if implementing your own cell navigation. */",
      "getDisplayedColBefore(col: Column)": "/** Same as `getVisibleColAfter` except gives column to the left. */",
      "setColumnVisible(key: string | Column, visible: boolean)": "/** @deprecated v31.1 setColumnVisible(key, visible) deprecated, please use setColumnsVisible([key], visible) instead. */",
      "setColumnsVisible(keys: (string | Column)[], visible: boolean)": "/** Sets the visibility of columns. Key can be the column ID or `Column` object. */",
      "setColumnPinned(key: string | ColDef | Column, pinned: ColumnPinnedType)": "/** @deprecated v31.1 setColumnPinned(key, pinned) deprecated, please use setColumnsPinned([key], pinned) instead. */",
      "setColumnsPinned(keys: (string | ColDef | Column)[], pinned: ColumnPinnedType)": "/** Set a column's pinned / unpinned state. Key can be the column ID, field, `ColDef` object or `Column` object. */",
      "getAllGridColumns()": "/** Returns all the grid columns, same as `getColumns()`, except\n     *\n     *  a) it has the order of the columns that are presented in the grid\n     *\n     *  b) it's after the 'pivot' step, so if pivoting, has the value columns for the pivot.\n     */",
      "getDisplayedLeftColumns()": "/** Same as `getAllDisplayedColumns` but just for the pinned left portion of the grid. */",
      "getDisplayedCenterColumns()": "/** Same as `getAllDisplayedColumns` but just for the center portion of the grid. */",
      "getDisplayedRightColumns()": "/** Same as `getAllDisplayedColumns` but just for the pinned right portion of the grid. */",
      "getAllDisplayedColumns()": "/** Returns all columns currently displayed (e.g. are visible and if in a group, the group is showing the columns) for the pinned left, centre and pinned right portions of the grid. */",
      "getAllDisplayedVirtualColumns()": "/** Same as `getAllGridColumns()`, except only returns rendered columns, i.e. columns that are not within the viewport and therefore not rendered, due to column virtualisation, are not displayed. */",
      "moveColumn(key: string | ColDef | Column, toIndex: number)": "/** @deprecated v31.1 moveColumn(key, toIndex) deprecated, please use moveColumns([key], toIndex) instead. */",
      "moveColumnByIndex(fromIndex: number, toIndex: number)": "/** Moves the column at `fromIdex` to `toIndex`. The column is first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */",
      "moveColumns(columnsToMoveKeys: (string | ColDef | Column)[], toIndex: number)": "/** Moves columns to `toIndex`. The columns are first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */",
      "moveRowGroupColumn(fromIndex: number, toIndex: number)": "/** Move the column to a new position in the row grouping order. */",
      "setColumnAggFunc(key: string | ColDef | Column, aggFunc: string | IAggFunc | null | undefined)": "/** Sets the agg function for a column. `aggFunc` can be one of the built-in aggregations or a custom aggregation by name or direct function. */",
      "setColumnWidth(key: string | ColDef | Column, newWidth: number, finished?: boolean, source?: ColumnEventType)": "/** @deprecated v31.1 setColumnWidths(key, newWidth) deprecated, please use setColumnWidths( [{key: newWidth}] ) instead. */",
      "setColumnWidths(columnWidths: { key: string | ColDef | Column; newWidth: number; }[], finished?: boolean, source?: ColumnEventType)": "/** Sets the column widths of the columns provided. The finished flag gets included in the resulting event and not used internally by the grid. The finished flag is intended for dragging, where a dragging action will produce many `columnWidth` events, so the consumer of events knows when it receives the last event in a stream. The finished parameter is optional, and defaults to `true`. */",
      "isPivotMode()": "/** Get the pivot mode. */",
      "getPivotResultColumn(pivotKeys: string[], valueColKey: string | ColDef<TData, TValue> | Column<TValue>)": "/** Returns the pivot result column for the given `pivotKeys` and `valueColId`. Useful to then call operations on the pivot column. */",
      "setValueColumns(colKeys: (string | ColDef | Column)[])": "/** Set the value columns to the provided list of columns. */",
      "getValueColumns()": "/** Get a list of the existing value columns. */",
      "removeValueColumn(colKey: string | ColDef | Column)": "/** @deprecated v31.1 removeValueColumn(colKey) deprecated, please use removeValueColumns([colKey]) instead. */",
      "removeValueColumns(colKeys: (string | ColDef | Column)[])": "/** Remove the given list of columns from the existing set of value columns. */",
      "addValueColumn(colKey: string | ColDef | Column)": "/** @deprecated v31.1 addValueColumn(colKey) deprecated, please use addValueColumns([colKey]) instead. */",
      "addValueColumns(colKeys: (string | ColDef | Column)[])": "/** Add the given list of columns to the existing set of value columns. */",
      "setRowGroupColumns(colKeys: (string | ColDef | Column)[])": "/** Set the row group columns. */",
      "removeRowGroupColumn(colKey: string | ColDef | Column)": "/** @deprecated v31.1 removeRowGroupColumn(colKey) deprecated, please use removeRowGroupColumns([colKey]) instead. */",
      "removeRowGroupColumns(colKeys: (string | ColDef | Column)[])": "/** Remove columns from the row groups. */",
      "addRowGroupColumn(colKey: string | ColDef | Column)": "/** @deprecated v31.1 addRowGroupColumn(colKey) deprecated, please use addRowGroupColumns([colKey]) instead. */",
      "addRowGroupColumns(colKeys: (string | ColDef | Column)[])": "/** Add columns to the row groups. */",
      "getRowGroupColumns()": "/** Get row group columns. */",
      "setPivotColumns(colKeys: (string | ColDef | Column)[])": "/** Set the pivot columns. */",
      "removePivotColumn(colKey: string | ColDef | Column)": "/** @deprecated v31.1 removePivotColumn(colKey) deprecated, please use removePivotColumns([colKey]) instead. */",
      "removePivotColumns(colKeys: (string | ColDef | Column)[])": "/** Remove pivot columns. */",
      "addPivotColumn(colKey: string | ColDef | Column)": "/** @deprecated v31.1 addPivotColumn(colKey) deprecated, please use addPivotColumns([colKey]) instead. */",
      "addPivotColumns(colKeys: (string | ColDef | Column)[])": "/** Add pivot columns. */",
      "getPivotColumns()": "/** Get the pivot columns. */",
      "getLeftDisplayedColumnGroups()": "/** Same as `getAllDisplayedColumnGroups` but just for the pinned left portion of the grid. */",
      "getCenterDisplayedColumnGroups()": "/** Same as `getAllDisplayedColumnGroups` but just for the center portion of the grid. */",
      "getRightDisplayedColumnGroups()": "/** Same as `getAllDisplayedColumnGroups` but just for the pinned right portion of the grid. */",
      "getAllDisplayedColumnGroups()": "/** Returns all 'root' column headers. If you are not grouping columns, these return the columns. If you are grouping, these return the top level groups - you can navigate down through each one to get the other lower level headers and finally the columns at the bottom. */",
      "autoSizeColumn(key: string | ColDef | Column, skipHeader?: boolean)": "/** @deprecated v31.1 autoSizeColumn(key) deprecated, please use autoSizeColumns([colKey]) instead. */",
      "autoSizeColumns(keys: (string | ColDef | Column)[], skipHeader?: boolean)": "/** Auto-sizes columns based on their contents. If inferring cell data types with custom column types\n     * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.\n     * To always perform this synchronously, set `cellDataType = false` on the default column definition.\n     */",
      "autoSizeAllColumns(skipHeader?: boolean)": "/** Calls `autoSizeColumns` on all displayed columns. If inferring cell data types with custom column types\n     * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.\n     * To always perform this synchronously, set `cellDataType = false` on the default column definition.\n     */",
      "setPivotResultColumns(colDefs: (ColDef | ColGroupDef)[] | null)": "/** Set the pivot result columns. */",
      "getPivotResultColumns()": "/** Returns the grid's pivot result columns. */",
      "getState()": "/** Get the current state of the grid. Can be used in conjunction with the `initialState` grid option to save and restore grid state. */",
      "getGridOption(key: Key)": "/** Returns the grid option value for a provided key.\n     */",
      "setGridOption(key: Key, value: GridOptions<TData>[Key])": "/** Updates a single gridOption to the new value provided. (Cannot be used on `Initial` properties.)\n     * If updating multiple options, it is recommended to instead use `api.updateGridOptions()` which batches update logic.\n     */",
      "updateGridOptions(options: ManagedGridOptions<TDataUpdate>)": "/** Updates the provided subset of gridOptions with the provided values. (Cannot be used on `Initial` properties.)\n     */"
    }
  },
  "ApiFunctionName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "keyof GridApi"
  },
  "ApiFunction": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TName extends ApiFunctionName"
      ]
    },
    "type": "(beans: BeanCollection, ...args: Parameters<GridApi[TName]>) => ReturnType<GridApi[TName]>"
  },
  "ModifyColumnsNoEventsCallbacks": {
    "meta": {},
    "type": {
      "addGroupCol(col: AgColumn)": "void",
      "removeGroupCol(col: AgColumn)": "void",
      "addPivotCol(col: AgColumn)": "void",
      "removePivotCol(col: AgColumn)": "void",
      "addValueCol(col: AgColumn)": "void",
      "removeValueCol(col: AgColumn)": "void"
    }
  },
  "ColumnStateParams": {
    "meta": {},
    "type": {
      "hide?": "boolean | null",
      "width?": "number",
      "flex?": "number | null",
      "sort?": "'asc' | 'desc' | null",
      "sortIndex?": "number | null",
      "aggFunc?": "string | IAggFunc | null",
      "pivot?": "boolean | null",
      "pivotIndex?": "number | null",
      "pinned?": "ColumnPinnedType",
      "rowGroup?": "boolean | null",
      "rowGroupIndex?": "number | null"
    },
    "docs": {
      "hide?": "/** True if the column is hidden */",
      "width?": "/** Width of the column in pixels */",
      "flex?": "/** Column's flex if flex is set */",
      "sort?": "/** Sort applied to the column */",
      "sortIndex?": "/** The order of the sort, if sorting by many columns */",
      "aggFunc?": "/** The aggregation function applied */",
      "pivot?": "/** True if pivot active */",
      "pivotIndex?": "/** The order of the pivot, if pivoting by many columns */",
      "pinned?": "/** Set if column is pinned */",
      "rowGroup?": "/** True if row group active */",
      "rowGroupIndex?": "/** The order of the row group, if grouping by many columns */"
    }
  },
  "ColumnState": {
    "meta": {},
    "type": {
      "colId": "string",
      "hide?": "boolean | null",
      "width?": "number",
      "flex?": "number | null",
      "sort?": "'asc' | 'desc' | null",
      "sortIndex?": "number | null",
      "aggFunc?": "string | IAggFunc | null",
      "pivot?": "boolean | null",
      "pivotIndex?": "number | null",
      "pinned?": "ColumnPinnedType",
      "rowGroup?": "boolean | null",
      "rowGroupIndex?": "number | null"
    },
    "docs": {
      "colId": "/** ID of the column */",
      "hide?": "/** True if the column is hidden */",
      "width?": "/** Width of the column in pixels */",
      "flex?": "/** Column's flex if flex is set */",
      "sort?": "/** Sort applied to the column */",
      "sortIndex?": "/** The order of the sort, if sorting by many columns */",
      "aggFunc?": "/** The aggregation function applied */",
      "pivot?": "/** True if pivot active */",
      "pivotIndex?": "/** The order of the pivot, if pivoting by many columns */",
      "pinned?": "/** Set if column is pinned */",
      "rowGroup?": "/** True if row group active */",
      "rowGroupIndex?": "/** The order of the row group, if grouping by many columns */"
    }
  },
  "ApplyColumnStateParams": {
    "meta": {},
    "type": {
      "state?": "ColumnState[]",
      "applyOrder?": "boolean",
      "defaultState?": "ColumnStateParams"
    },
    "docs": {
      "state?": "/** The state from `getColumnState` */",
      "applyOrder?": "/** Whether column order should be applied */",
      "defaultState?": "/** State to apply to columns where state is missing for those columns */"
    }
  },
  "ColKey": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "keyof ColDef | keyof ColGroupDef"
  },
  "Maybe": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "T | null | undefined"
  },
  "ColumnCollections": {
    "meta": {},
    "type": {
      "tree": "(AgColumn | AgProvidedColumnGroup)[]",
      "treeDepth": "number",
      "list": "AgColumn[]",
      "map": "{ [id: string]: AgColumn; }"
    }
  },
  "ColumnResizeSet": {
    "meta": {},
    "type": {
      "columns": "AgColumn[]",
      "ratios": "number[]",
      "width": "number"
    }
  },
  "IColumnLimit": {
    "meta": {},
    "type": {
      "key": "Column | string",
      "minWidth?": "number",
      "maxWidth?": "number"
    },
    "docs": {
      "key": "/** Selector for the column to which these dimension limits will apply */",
      "minWidth?": "/** Defines a minimum width for this column (does not override the column minimum width) */",
      "maxWidth?": "/** Defines a maximum width for this column (does not override the column maximum width) */"
    }
  },
  "ISizeColumnsToFitParams": {
    "meta": {},
    "type": {
      "defaultMinWidth?": "number",
      "defaultMaxWidth?": "number",
      "columnLimits?": "IColumnLimit[]"
    },
    "docs": {
      "defaultMinWidth?": "/** Defines a default minimum width for every column (does not override the column minimum width) */",
      "defaultMaxWidth?": "/** Defines a default maximum width for every column (does not override the column maximum width) */",
      "columnLimits?": "/** Provides a minimum and/or maximum width to specific columns */"
    }
  },
  "GroupSafeValueFormatter": {
    "meta": {},
    "type": {
      "groupSafeValueFormatter?": "ValueFormatterFunc"
    }
  },
  "FormatValueFunc": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params: { column: Column; node: IRowNode | null; value: any; }) => string"
  },
  "ComponentMetadata": {
    "meta": {},
    "type": {
      "mandatoryMethodList": "string[]",
      "optionalMethodList": "string[]",
      "functionAdapter?": "(callback: any) => { new (): IComponent<any>; }"
    }
  },
  "ComponentType": {
    "meta": {},
    "type": {
      "propertyName": "string",
      "cellRenderer": "boolean"
    }
  },
  "FrameworkComponentWrapper": {
    "meta": {
      "doc": "/** B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid\n */"
    },
    "type": {
      "wrap(frameworkComponent: { new (): any; } | null, methodList: string[], optionalMethodList: string[], componentType: ComponentType)": "A"
    }
  },
  "WrappableInterface": {
    "meta": {},
    "type": {
      "hasMethod(name: string)": "boolean",
      "callMethod(name: string, args: IArguments)": "void",
      "addMethod(name: string, callback: (...args: any[]) => any)": "void"
    }
  },
  "DefinitionObject": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "GridOptions | ColDef | ColGroupDef | IFilterDef | SetFilterParams | RichSelectParams | ToolPanelDef | StatusPanelDef | MenuItemDef"
  },
  "UserCompDetails": {
    "meta": {},
    "type": {
      "componentClass": "any",
      "componentFromFramework": "boolean",
      "params": "any",
      "type": "ComponentType",
      "popupFromSelector?": "boolean",
      "popupPositionFromSelector?": "'over' | 'under'",
      "newAgStackInstance": "() => AgPromise<any>"
    }
  },
  "VerticalDirection": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Up",
      "Down"
    ],
    "docs": [
      null,
      null
    ]
  },
  "HorizontalDirection": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Left",
      "Right"
    ],
    "docs": [
      null,
      null
    ]
  },
  "Bean": {
    "meta": {},
    "type": {
      "beanName?": "BeanName",
      "wireBeans?(beans: BeanCollection)": "void",
      "postConstruct?()": "void",
      "destroy?()": "void"
    },
    "docs": {
      "beanName?": "/** AG Grid internal - do not use */",
      "wireBeans?(beans: BeanCollection)": "/** AG Grid internal - do not call */",
      "postConstruct?()": "/** AG Grid internal - do not call */",
      "destroy?()": "/** AG Grid internal - do not call */"
    }
  },
  "NamedBean": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Required<Pick<Bean, 'beanName'>>"
  },
  "BeanStubEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'destroyed'"
  },
  "EventOrDestroyed": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TEventType extends string"
      ]
    },
    "type": "TEventType | BeanStubEvent"
  },
  "EventHandlers": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TEventKey extends string",
        "TEvent = any"
      ]
    },
    "type": "{[K in TEventKey]?: (event?: TEvent) => void}"
  },
  "AgEventHandlers": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{[K in AgEventType]?: (event: AgEventTypeParams[K]) => void}"
  },
  "ContextParams": {
    "meta": {},
    "type": {
      "gridId": "string",
      "providedBeanInstances": "Partial<{ [key in TBeanName]: GenericBean<TBeanName, TBeanCollection>; }>",
      "beanClasses": "GenericSingletonBean<TBeanName, TBeanCollection>[]",
      "derivedBeans?": "((context: GenericContext<TBeanName, TBeanCollection>) => { beanName: TBeanName; bean: TBeanCollection[TBeanName]; })[]",
      "beanInitComparator?": "BeanComparator<TBeanName, TBeanCollection>",
      "beanDestroyComparator?": "BeanComparator<TBeanName, TBeanCollection>"
    }
  },
  "SingletonBean": {
    "meta": {},
    "type": {
      "new (): GenericBean<TBeanName, TBeanCollection>": "GenericBean<TBeanName, TBeanCollection>"
    }
  },
  "ControllerName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'headerFilterCell' | 'detailCellRenderer' | 'groupCellRendererCtrl'"
  },
  "UserComponentName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'agColumnHeader' | 'agColumnGroupHeader' | 'agSortIndicator' | 'agAnimateShowChangeCellRenderer' | 'agAnimateSlideCellRenderer' | 'agLoadingCellRenderer' | 'agSkeletonCellRenderer' | 'agCheckboxCellRenderer' | 'agLoadingOverlay' | 'agNoRowsOverlay' | 'agTooltipComponent' | 'agReadOnlyFloatingFilter' | 'agTextColumnFilter' | 'agNumberColumnFilter' | 'agDateColumnFilter' | 'agDateInput' | 'agTextColumnFloatingFilter' | 'agNumberColumnFloatingFilter' | 'agDateColumnFloatingFilter' | 'agMultiColumnFilter' | 'agMultiColumnFloatingFilter' | 'agGroupColumnFilter' | 'agGroupColumnFloatingFilter' | 'agSetColumnFilter' | 'agSetColumnFloatingFilter' | 'agCellEditor' | 'agSelectCellEditor' | 'agTextCellEditor' | 'agNumberCellEditor' | 'agDateCellEditor' | 'agDateStringCellEditor' | 'agCheckboxCellEditor' | 'agLargeTextCellEditor' | 'agRichSelect' | 'agRichSelectCellEditor' | 'agMenuItem' | 'agColumnsToolPanel' | 'agFiltersToolPanel' | 'agGroupRowRenderer' | 'agGroupCellRenderer' | 'agDetailCellRenderer' | 'agSparklineCellRenderer' | 'agAggregationComponent' | 'agSelectedRowCountComponent' | 'agTotalRowCountComponent' | 'agFilteredRowCountComponent' | 'agTotalAndFilteredRowCountComponent'"
  },
  "NamedClass": {
    "meta": {
      "typeParams": [
        "TName = string"
      ]
    },
    "type": {
      "classImp": "new (...args: [ ]) => object",
      "name": "TName"
    }
  },
  "ControllerMeta": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "NamedClass<ControllerName>"
  },
  "ComponentMeta": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "NamedClass<UserComponentName>"
  },
  "CoreBeanCollection": {
    "meta": {},
    "type": {
      "context": "Context",
      "resizeObserverService": "ResizeObserverService",
      "pageBoundsListener": "PageBoundsListener",
      "gos": "GridOptionsService",
      "environment": "Environment",
      "rowRenderer": "RowRenderer",
      "valueService": "ValueService",
      "eventService": "EventService",
      "columnModel": "ColumnModel",
      "columnViewportService": "ColumnViewportService",
      "columnNameService": "ColumnNameService",
      "visibleColsService": "VisibleColsService",
      "columnMoveService": "ColumnMoveService",
      "columnSizeService": "ColumnSizeService",
      "headerNavigationService": "HeaderNavigationService",
      "navigationService": "NavigationService",
      "columnAnimationService": "ColumnAnimationService",
      "focusService": "FocusService",
      "popupService": "PopupService",
      "stylingService": "StylingService",
      "columnHoverService": "ColumnHoverService",
      "userComponentFactory": "UserComponentFactory",
      "userComponentRegistry": "UserComponentRegistry",
      "animationFrameService": "AnimationFrameService",
      "dragService": "DragService",
      "dragAndDropService": "DragAndDropService",
      "sortController": "SortController",
      "columnFilterService?": "ColumnFilterService",
      "filterManager?": "FilterManager",
      "rowContainerHeightService": "RowContainerHeightService",
      "frameworkOverrides": "IFrameworkOverrides",
      "cellPositionUtils": "CellPositionUtils",
      "rowPositionUtils": "RowPositionUtils",
      "selectionService": "ISelectionService",
      "rowCssClassCalculator": "RowCssClassCalculator",
      "rowModel": "IRowModel",
      "ctrlsService": "CtrlsService",
      "ctrlsFactory": "CtrlsFactory",
      "valueCache": "ValueCache",
      "rowNodeEventThrottle": "RowNodeEventThrottle",
      "localeService": "LocaleService",
      "syncService": "SyncService",
      "ariaAnnouncementService": "AriaAnnouncementService",
      "rangeService?": "IRangeService",
      "selectionHandleFactory": "ISelectionHandleFactory",
      "validationService?": "ValidationService",
      "gridApi": "GridApi",
      "gridOptions": "GridOptions",
      "eGridDiv": "HTMLElement",
      "columnApplyStateService": "ColumnApplyStateService",
      "columnFactory": "ColumnFactory",
      "pivotResultColsService": "PivotResultColsService",
      "autoColService?": "IAutoColService",
      "columnDefFactory": "ColumnDefFactory",
      "columnGroupStateService": "ColumnGroupStateService",
      "columnEventDispatcher": "ColumnEventDispatcher",
      "columnAutosizeService": "ColumnAutosizeService",
      "funcColsService": "FuncColsService",
      "quickFilterService?": "QuickFilterService",
      "showRowGroupColsService?": "IShowRowGroupColsService",
      "columnDropZonesService?": "IColumnDropZonesService",
      "headerPositionUtils": "HeaderPositionUtils",
      "dataTypeService?": "DataTypeService",
      "globalEventListener": "AgGlobalEventListener",
      "globalSyncEventListener": "AgGlobalEventListener",
      "stateService?": "StateService",
      "overlayService": "OverlayService",
      "columnGetStateService": "ColumnGetStateService",
      "pinnedRowModel": "PinnedRowModel",
      "menuService": "MenuService",
      "apiEventService": "ApiEventService",
      "undoRedoService?": "UndoRedoService",
      "rowNodeBlockLoader?": "RowNodeBlockLoader",
      "csvCreator?": "ICsvCreator",
      "excelCreator?": "IExcelCreator",
      "clipboardService?": "IClipboardService",
      "mouseEventService": "MouseEventService",
      "cellNavigationService": "CellNavigationService",
      "scrollVisibleService": "ScrollVisibleService",
      "pinnedWidthService": "PinnedWidthService",
      "expressionService": "ExpressionService",
      "autoWidthCalculator": "AutoWidthCalculator",
      "componentMetadataProvider": "ComponentMetadataProvider",
      "agComponentUtils": "AgComponentUtils",
      "frameworkComponentWrapper": "FrameworkComponentWrapper",
      "horizontalResizeService": "HorizontalResizeService",
      "filterMenuFactory": "IMenuFactory",
      "enterpriseMenuFactory?": "IMenuFactory",
      "contextMenuFactory?": "IContextMenuFactory",
      "editService?": "EditService",
      "rowEditService?": "RowEditService",
      "alignedGridsService?": "AlignedGridsService",
      "paginationAutoPageSizeService?": "PaginationAutoPageSizeService",
      "paginationService?": "PaginationService",
      "pageBoundsService": "PageBoundsService",
      "apiFunctionService": "ApiFunctionService",
      "rowModelHelperService?": "RowModelHelperService",
      "detailGridApiService?": "IDetailGridApiService",
      "gridDestroyService": "GridDestroyService",
      "expansionService": "IExpansionService",
      "sideBarService?": "ISideBarService",
      "ssrmTransactionManager?": "IServerSideTransactionManager",
      "columnChooserFactory?": "IColumnChooserFactory",
      "aggFuncService?": "IAggFuncService",
      "advancedFilterService": "IAdvancedFilterService",
      "filterStage?": "IRowNodeStage",
      "sortStage?": "IRowNodeStage",
      "flattenStage?": "IRowNodeStage",
      "groupStage?": "IRowNodeStage",
      "aggregationStage?": "IRowNodeStage",
      "pivotStage?": "IRowNodeStage",
      "filterAggregatesStage?": "IRowNodeStage",
      "rowNodeSorter": "RowNodeSorter",
      "pivotColDefService?": "IPivotColDefService",
      "statusBarService?": "IStatusBarService",
      "chartService?": "IChartService",
      "selectableService": "SelectableService"
    }
  },
  "BeanCollection": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "CoreBeanCollection & { [key in Exclude<BeanName, keyof CoreBeanCollection>]?: unknown; }"
  },
  "BeanName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'advancedFilterExpressionService' | 'advancedFilterService' | 'advancedSettingsMenuFactory' | 'aggFuncService' | 'agGridAngular' | 'agGridReact' | 'agGridVue' | 'agComponentUtils' | 'aggregationStage' | 'alignedGridsService' | 'animationFrameService' | 'apiFunctionService' | 'ariaAnnouncementService' | 'apiEventService' | 'autoColService' | 'autoWidthCalculator' | 'beans' | 'cellEditorFactory' | 'cellNavigationService' | 'cellPositionUtils' | 'cellRendererFactory' | 'cellRendererService' | 'changeDetectionService' | 'chartColumnService' | 'chartCrossFilterService' | 'chartMenuItemMapper' | 'chartMenuListFactory' | 'chartMenuService' | 'chartTranslationService' | 'chartService' | 'clipboardService' | 'columnAutosizeService' | 'columnChooserFactory' | 'columnController' | 'columnDefFactory' | 'columnDropZonesService' | 'columnEditorFactory' | 'columnEventDispatcher' | 'columnFilterService' | 'columnGetStateService' | 'columnSizeService' | 'columnFactory' | 'columnAnimationService' | 'columnHoverService' | 'columnMenuFactory' | 'columnModel' | 'columnMoveService' | 'columnPositionService' | 'columnNameService' | 'columnViewportService' | 'columnGroupStateService' | 'columnApplyStateService' | 'columnUtils' | 'pivotResultColsService' | 'componentMetadataProvider' | 'context' | 'contextMenuFactory' | 'ctrlsFactory' | 'ctrlsService' | 'csvCreator' | 'dataTypeService' | 'visibleColsService' | 'detailGridApiService' | 'dragAndDropService' | 'dragService' | 'editService' | 'excelCreator' | 'enterpriseMenuFactory' | 'environment' | 'eventService' | 'eGridDiv' | 'expansionService' | 'expressionService' | 'filterAggregatesStage' | 'filterManager' | 'filterMenuFactory' | 'filterStage' | 'flattenStage' | 'focusService' | 'funcColsService' | 'frameworkComponentWrapper' | 'frameworkOverrides' | 'globalEventListener' | 'globalSyncEventListener' | 'gridApi' | 'gridDestroyService' | 'gridOptions' | 'gos' | 'gridOptionsWrapper' | 'gridSerializer' | 'groupStage' | 'headerNavigationService' | 'headerPositionUtils' | 'horizontalResizeService' | 'immutableService' | 'lazyBlockLoadingService' | 'licenseManager' | 'localeService' | 'loggerFactory' | 'menuItemMapper' | 'menuService' | 'menuUtils' | 'modelItemUtils' | 'mouseEventService' | 'navigationService' | 'overlayService' | 'paginationAutoPageSizeService' | 'paginationService' | 'pinnedRowModel' | 'pinnedWidthService' | 'pivotColDefService' | 'pivotStage' | 'popupService' | 'quickFilterService' | 'rangeService' | 'resizeObserverService' | 'pageBoundsListener' | 'pageBoundsService' | 'renderStatusService' | 'rowContainerHeightService' | 'rowCssClassCalculator' | 'rowEditService' | 'rowModel' | 'rowNodeBlockLoader' | 'rowNodeEventThrottle' | 'rowModelHelperService' | 'rowNodeSorter' | 'rowPositionUtils' | 'rowRenderer' | 'scrollVisibleService' | 'selectableService' | 'selectionController' | 'selectionHandleFactory' | 'selectionService' | 'showRowGroupColsService' | 'sideBarService' | 'sortController' | 'sortService' | 'sortStage' | 'sparklineTooltipSingleton' | 'ssrmBlockUtils' | 'ssrmExpandListener' | 'ssrmFilterListener' | 'ssrmListenerUtils' | 'ssrmNodeManager' | 'ssrmSortService' | 'ssrmStoreFactory' | 'ssrmStoreUtils' | 'ssrmTransactionManager' | 'stateService' | 'statusBarService' | 'stylingService' | 'syncService' | 'templateService' | 'toolPanelColDefService' | 'undoRedoService' | 'userComponentFactory' | 'userComponentRegistry' | 'valueCache' | 'valueService' | 'validationLogger' | 'validationService'"
  },
  "GenericBean": {
    "meta": {
      "typeParams": [
        "TBeanName",
        "TBeanCollection"
      ]
    },
    "type": {
      "beanName?": "TBeanName",
      "wireBeans?(beans: TBeanCollection)": "void",
      "postConstruct?()": "void",
      "destroy?()": "void"
    },
    "docs": {
      "beanName?": "/** AG Grid internal - do not use */",
      "wireBeans?(beans: TBeanCollection)": "/** AG Grid internal - do not call */",
      "postConstruct?()": "/** AG Grid internal - do not call */",
      "destroy?()": "/** AG Grid internal - do not call */"
    }
  },
  "BeanComparator": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TBeanName extends string",
        "TBeanCollection extends {\n    [key in TBeanName]?: any;\n}"
      ]
    },
    "type": "(bean1: GenericBean<TBeanName, TBeanCollection>, bean2: GenericBean<TBeanName, TBeanCollection>) => number"
  },
  "GenericContextParams": {
    "meta": {
      "typeParams": [
        "TBeanName extends string",
        "TBeanCollection extends {\n    [key in TBeanName]?: any;\n}"
      ]
    },
    "type": {
      "providedBeanInstances": "Partial<{ [key in TBeanName]: GenericBean<TBeanName, TBeanCollection>; }>",
      "beanClasses": "GenericSingletonBean<TBeanName, TBeanCollection>[]",
      "derivedBeans?": "((context: GenericContext<TBeanName, TBeanCollection>) => { beanName: TBeanName; bean: TBeanCollection[TBeanName]; })[]",
      "beanInitComparator?": "BeanComparator<TBeanName, TBeanCollection>",
      "beanDestroyComparator?": "BeanComparator<TBeanName, TBeanCollection>"
    }
  },
  "GenericSingletonBean": {
    "meta": {
      "typeParams": [
        "TBeanName extends string",
        "TBeanCollection extends {\n    [key in TBeanName]?: any;\n}"
      ]
    },
    "type": {
      "new (): GenericBean<TBeanName, TBeanCollection>": "GenericBean<TBeanName, TBeanCollection>"
    }
  },
  "ComponentBean": {
    "meta": {},
    "type": {
      "preConstruct()": "void"
    }
  },
  "BaseBean": {
    "meta": {
      "typeParams": [
        "TBeanCollection"
      ],
      "doc": "/** The BaseBean can be used to avoid having to call super.wireBeans() in every subclass of a shared base bean, .i.e BeanStub, Component\n * It is used to pre-wire beans before the wireBeans() method is called which is equivalent to calling super.wireBeans() in a sub class\n */"
    },
    "type": {
      "preWireBeans?(beans: TBeanCollection)": "void"
    }
  },
  "ReadyParams": {
    "meta": {},
    "type": {
      "gridCtrl": "GridCtrl",
      "gridBodyCtrl": "GridBodyCtrl",
      "center": "RowContainerCtrl",
      "left": "RowContainerCtrl",
      "right": "RowContainerCtrl",
      "bottomCenter": "RowContainerCtrl",
      "bottomLeft": "RowContainerCtrl",
      "bottomRight": "RowContainerCtrl",
      "topCenter": "RowContainerCtrl",
      "topLeft": "RowContainerCtrl",
      "topRight": "RowContainerCtrl",
      "stickyTopCenter": "RowContainerCtrl",
      "stickyTopLeft": "RowContainerCtrl",
      "stickyTopRight": "RowContainerCtrl",
      "stickyBottomCenter": "RowContainerCtrl",
      "stickyBottomLeft": "RowContainerCtrl",
      "stickyBottomRight": "RowContainerCtrl",
      "fakeHScrollComp": "FakeHScrollComp",
      "fakeVScrollComp": "FakeVScrollComp",
      "gridHeaderCtrl": "GridHeaderCtrl",
      "centerHeader": "HeaderRowContainerCtrl",
      "leftHeader": "HeaderRowContainerCtrl",
      "rightHeader": "HeaderRowContainerCtrl"
    }
  },
  "CtrlType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "keyof ReadyParams"
  },
  "DragItem": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "rowNode?": "IRowNode",
      "rowNodes?": "IRowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{ [key: string]: boolean; }",
      "pivotState?": "{ [key: string]: { pivot?: boolean; rowGroup?: boolean; aggFunc?: string | IAggFunc | null; }; }",
      "value?": "TValue"
    },
    "docs": {
      "rowNode?": "/** When dragging a row, this contains the row node being dragged\n     * When dragging multiple rows, this contains the row that started the drag.\n     */",
      "rowNodes?": "/** When dragging multiple rows, this contains all rows being dragged */",
      "columns?": "/** When dragging columns, this contains the columns being dragged */",
      "visibleState?": "/** When dragging columns, this contains the visible state of the columns */",
      "pivotState?": "/** When dragging columns, this contains the pivot state of the columns. This is only populated/used in column tool panel */",
      "value?": "/** Additional state */"
    }
  },
  "DragSourceType": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "ToolPanel",
      "HeaderCell",
      "RowDrag",
      "ChartPanel",
      "AdvancedFilterBuilder"
    ],
    "docs": [
      null,
      null,
      null,
      null,
      null
    ]
  },
  "DragSource": {
    "meta": {},
    "type": {
      "type": "DragSourceType",
      "sourceId?": "string",
      "eElement": "Element",
      "getDragItem": "() => DragItem",
      "dragItemName": "string | (() => string) | null",
      "getDefaultIconName?": "() => DragAndDropIcon",
      "dragSourceDomDataKey?": "string",
      "dragStartPixels?": "number",
      "onDragStarted?": "() => void",
      "onDragStopped?": "() => void",
      "onGridEnter?": "(dragItem: DragItem | null) => void",
      "onGridExit?": "(dragItem: DragItem | null) => void"
    },
    "docs": {
      "type": "/** The type of the drag source, used by the drop target to know where the\n     * drag originated from.\n     */",
      "sourceId?": "/** Can be used to identify a specific component as the source */",
      "eElement": "/** Element which, when dragged, will kick off the DnD process\n     */",
      "getDragItem": "/** If eElement is dragged, then the dragItem is the object that gets passed around.\n     */",
      "dragItemName": "/** This name appears in the ghost icon when dragging.\n     */",
      "getDefaultIconName?": "/** Icon to show when not over a drop zone\n     */",
      "dragSourceDomDataKey?": "/** The drag source DOM Data Key, this is useful to detect if the origin grid is the same\n     * as the target grid.\n     */",
      "dragStartPixels?": "/** After how many pixels of dragging should the drag operation start. Default is 4.\n     */",
      "onDragStarted?": "/** Callback for drag started\n     */",
      "onDragStopped?": "/** Callback for drag stopped\n     */",
      "onGridEnter?": "/** Callback for entering the grid\n     */",
      "onGridExit?": "/** Callback for exiting the grid\n     */"
    }
  },
  "DropTarget": {
    "meta": {},
    "type": {
      "getContainer()": "HTMLElement",
      "getSecondaryContainers?()": "HTMLElement[][]",
      "getIconName?()": "DragAndDropIcon | null",
      "isInterestedIn(type: DragSourceType, el: Element)": "boolean",
      "targetContainsSource?": "boolean",
      "onDragEnter?(params: DraggingEvent)": "void",
      "onDragLeave?(params: DraggingEvent)": "void",
      "onDragging?(params: DraggingEvent)": "void",
      "onDragStop?(params: DraggingEvent)": "void",
      "external?": "boolean"
    },
    "docs": {
      "getContainer()": "/** The main container that will get the drop. */",
      "getSecondaryContainers?()": "/** If any secondary containers. For example when moving columns in AG Grid, we listen for drops\n     * in the header as well as the body (main rows and pinned rows) of the grid. */",
      "getIconName?()": "/** Icon to show when drag is over */",
      "targetContainsSource?": "/** If `true`, the DragSources will only be allowed to be dragged within the DragTarget that contains them.\n     * This is useful for changing order of items within a container, and not moving items across containers.\n     * @default false\n     */",
      "onDragEnter?(params: DraggingEvent)": "/** Callback for when drag enters */",
      "onDragLeave?(params: DraggingEvent)": "/** Callback for when drag leaves */",
      "onDragging?(params: DraggingEvent)": "/** Callback for when dragging */",
      "onDragStop?(params: DraggingEvent)": "/** Callback for when drag stops */"
    }
  },
  "DraggingEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "event": "MouseEvent",
      "x": "number",
      "y": "number",
      "vDirection": "VerticalDirection | null",
      "hDirection": "HorizontalDirection | null",
      "dragSource": "DragSource",
      "dragItem": "DragItem",
      "fromNudge": "boolean",
      "dropZoneTarget": "HTMLElement",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "DragAndDropIcon": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'pinned' | 'move' | 'left' | 'right' | 'group' | 'aggregate' | 'pivot' | 'notAllowed' | 'hide'"
  },
  "DragSourceAndListener": {
    "meta": {},
    "type": {
      "dragSource": "DragListenerParams",
      "mouseDownListener": "(mouseEvent: MouseEvent) => void",
      "touchEnabled": "boolean",
      "touchStartListener": "((touchEvent: TouchEvent) => void) | null"
    }
  },
  "DragListenerParams": {
    "meta": {},
    "type": {
      "dragStartPixels?": "number",
      "eElement": "Element",
      "skipMouseEvent?": "(mouseEvent: MouseEvent) => boolean",
      "onDragStart": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragStop": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragging": "(mouseEvent: MouseEvent | Touch) => void",
      "includeTouch?": "boolean",
      "stopPropagationForTouch?": "boolean"
    },
    "docs": {
      "dragStartPixels?": "/** After how many pixels of dragging should the drag operation start. Default is 4px. */",
      "eElement": "/** Dom element to add the drag handling to */",
      "skipMouseEvent?": "/** Some places may wish to ignore certain events, eg range selection ignores shift clicks */",
      "onDragStart": "/** Callback for drag starting */",
      "onDragStop": "/** Callback for drag stopping */",
      "onDragging": "/** Callback for mouse move while dragging */",
      "includeTouch?": "/** Include touch events for this Drag Listener */",
      "stopPropagationForTouch?": "/** If `true`, it will stop the propagation of Touch Events */"
    }
  },
  "CellEditorInput": {
    "meta": {
      "typeParams": [
        "TValue",
        "P extends ICellEditorParams",
        "I extends AgInputTextField"
      ]
    },
    "type": {
      "getTemplate()": "string",
      "getAgComponents()": "ComponentSelector[]",
      "init(eInput: I, params: P)": "void",
      "getValue()": "TValue | null | undefined",
      "getStartValue()": "string | null | undefined",
      "setCaret?()": "void"
    }
  },
  "IDateCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "min?": "string | Date",
      "max?": "string | Date",
      "step?": "number",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "min?": "/** Min allowed value. Either `Date` object or string in format `'yyyy-mm-dd'`. */",
      "max?": "/** Max allowed value. Either `Date` object or string in format `'yyyy-mm-dd'`. */",
      "step?": "/** Size of the value change when stepping up/down, starting from `min` or the initial value if provided.\n     * Step is also the difference between valid values.\n     * If the user-provided value isn't a multiple of the step value from the starting value, it will be considered invalid.\n     * Defaults to any value allowed.\n     */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IDateStringCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "min?": "string | Date",
      "max?": "string | Date",
      "step?": "number",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "min?": "/** Min allowed value. Either `Date` object or string in format `'yyyy-mm-dd'`. */",
      "max?": "/** Max allowed value. Either `Date` object or string in format `'yyyy-mm-dd'`. */",
      "step?": "/** Size of the value change when stepping up/down, starting from `min` or the initial value if provided.\n     * Step is also the difference between valid values.\n     * If the user-provided value isn't a multiple of the step value from the starting value, it will be considered invalid.\n     * Defaults to any value allowed.\n     */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ILargeTextEditorParams": {
    "meta": {},
    "type": {
      "maxLength": "number",
      "rows": "number",
      "cols": "number",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "maxLength": "/** Max number of characters to allow.\n     * @default 200\n     */",
      "rows": "/** Number of character rows to display.\n     * @default 10\n     */",
      "cols": "/** Number of character columns to display.\n     * @default 60\n     */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "INumberCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "min?": "number",
      "max?": "number",
      "precision?": "number",
      "step?": "number",
      "showStepperButtons?": "boolean",
      "preventStepping?": "boolean",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "min?": "/** Min allowed value. */",
      "max?": "/** Max allowed value. */",
      "precision?": "/** Number of digits allowed after the decimal point. */",
      "step?": "/** Size of the value change when stepping up/down, starting from `min` or the initial value if provided.\n     * Step is also the difference between valid values.\n     * If the user-provided value isn't a multiple of the step value from the starting value, it will be considered invalid.\n     * Defaults to any value allowed.\n     */",
      "showStepperButtons?": "/** Display stepper buttons in editor. Note: Does not work when `preventStepping` is `true`.\n     * @default false\n     */",
      "preventStepping?": "/** Set to `true` to prevent key up/down from stepping the field's value.\n     * @default false\n     */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ISelectCellEditorParams": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "values": "TValue[]",
      "valueListGap?": "number",
      "valueListMaxHeight?": "number | string",
      "valueListMaxWidth?": "number | string"
    },
    "docs": {
      "values": "/** List of values to display */",
      "valueListGap?": "/** The space in pixels between the value display and the list of items.\n     * @default 4\n     */",
      "valueListMaxHeight?": "/** The maximum height of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string. Default: Height of Popup Parent.\n     */",
      "valueListMaxWidth?": "/** The maximum width of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string. Default: Width of the cell being edited.\n     */"
    }
  },
  "ITextCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "useFormatter": "boolean",
      "maxLength?": "number",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "useFormatter": "/** If `true`, the editor will use the provided `colDef.valueFormatter` to format the value displayed in the editor.\n     * Used when the cell value needs formatting prior to editing, such as when using reference data and you\n     * want to display text rather than code. */",
      "maxLength?": "/** Max number of characters to allow.\n     * @default 524288\n     */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SelectCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "values": "TValue[]",
      "valueListGap?": "number",
      "valueListMaxHeight?": "number | string",
      "valueListMaxWidth?": "number | string",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "values": "/** List of values to display */",
      "valueListGap?": "/** The space in pixels between the value display and the list of items.\n     * @default 4\n     */",
      "valueListMaxHeight?": "/** The maximum height of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string. Default: Height of Popup Parent.\n     */",
      "valueListMaxWidth?": "/** The maximum width of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string. Default: Width of the cell being edited.\n     */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "AgProvidedColumnGroupEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'expandedChanged' | 'expandableChanged'"
  },
  "CellPosition": {
    "meta": {},
    "type": {
      "column": "Column",
      "rowIndex": "number",
      "rowPinned": "RowPinnedType"
    },
    "docs": {
      "column": "/** The grid column */",
      "rowIndex": "/** A positive number from 0 to n, where n is the last row the grid is rendering\n     * or -1 if you want to navigate to the grid header */",
      "rowPinned": "/** Either 'top', 'bottom' or null/undefined (for not pinned) */"
    }
  },
  "AbstractColDef": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ],
      "doc": "/** AbstractColDef can be a group or a column definition */"
    },
    "type": {
      "headerName?": "string",
      "headerValueGetter?": "string | HeaderValueGetterFunc<TData, TValue>",
      "headerTooltip?": "string",
      "headerClass?": "HeaderClass<TData, TValue>",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams<TData, TValue>) => boolean",
      "columnGroupShow?": "ColumnGroupShowType",
      "toolPanelClass?": "ToolPanelClass<TData, TValue>",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "tooltipComponent?": "any",
      "tooltipComponentParams?": "any",
      "pivotKeys?": "string[]",
      "cellAriaRole?": "string",
      "context?": "any"
    },
    "docs": {
      "headerName?": "/** The name to render in the column header. If not specified and field is specified, the field name will be used as the header name. */",
      "headerValueGetter?": "/** Function or expression. Gets the value for display in the header. */",
      "headerTooltip?": "/** Tooltip for the column header */",
      "headerClass?": "/** CSS class to use for the header cell. Can be a string, array of strings, or function. */",
      "suppressHeaderKeyboardEvent?": "/** Suppress the grid taking action for the relevant keyboard event when a header is focused. */",
      "columnGroupShow?": "/** Whether to only show the column when the group is open / closed. If not set the column is always displayed as part of the group. */",
      "toolPanelClass?": "/** CSS class to use for the tool panel cell. Can be a string, array of strings, or function. */",
      "suppressColumnsToolPanel?": "/** Set to `true` if you do not want this column or group to appear in the Columns Tool Panel.\n     * @default false\n     */",
      "suppressFiltersToolPanel?": "/** Set to `true` if you do not want this column (filter) or group (filter group) to appear in the Filters Tool Panel.\n     * @default false\n     */",
      "tooltipComponent?": "/** Provide your own tooltip component for the column.\n     * See [Tooltip Component](https://www.ag-grid.com/javascript-data-grid/tooltips/) for framework specific implementation details.\n     */",
      "tooltipComponentParams?": "/** The params used to configure `tooltipComponent`. */",
      "pivotKeys?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "cellAriaRole?": "/** Used for screen reader announcements - the role property of the cells that belong to this column.\n     * @default 'gridcell'\n     */",
      "context?": "/** Context property that can be used to associate arbitrary application data with this column definition.\n     */"
    }
  },
  "ColGroupDef": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** Configuration options for column groups in AG Grid.  */"
    },
    "type": {
      "children": "(ColDef<TData> | ColGroupDef<TData>)[]",
      "groupId?": "string",
      "openByDefault?": "boolean",
      "marryChildren?": "boolean",
      "suppressStickyLabel?": "boolean",
      "headerGroupComponent?": "any",
      "headerGroupComponentParams?": "any",
      "headerName?": "string",
      "headerValueGetter?": "string | HeaderValueGetterFunc<TData, TValue>",
      "headerTooltip?": "string",
      "headerClass?": "HeaderClass<TData, TValue>",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams<TData, TValue>) => boolean",
      "columnGroupShow?": "ColumnGroupShowType",
      "toolPanelClass?": "ToolPanelClass<TData, TValue>",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "tooltipComponent?": "any",
      "tooltipComponentParams?": "any",
      "pivotKeys?": "string[]",
      "cellAriaRole?": "string",
      "context?": "any"
    },
    "docs": {
      "children": "/** A list containing a mix of columns and column groups. */",
      "groupId?": "/** The unique ID to give the column. This is optional. If missing, a unique ID will be generated. This ID is used to identify the column group in the API. */",
      "openByDefault?": "/** Set to `true` if this group should be opened by default.\n     * @default false\n     */",
      "marryChildren?": "/** Set to `true` to keep columns in this group beside each other in the grid. Moving the columns outside of the group (and hence breaking the group) is not allowed.\n     * @default false\n     */",
      "suppressStickyLabel?": "/** If `true` the label of the Column Group will not scroll alongside the grid to always remain visible.\n     * @default false\n     */",
      "headerGroupComponent?": "/** The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used.\n     * See [Header Group Component](https://www.ag-grid.com/javascript-data-grid/component-header/#header-group-components) for framework specific implementation details.\n     */",
      "headerGroupComponentParams?": "/** The params used to configure the `headerGroupComponent`. */",
      "headerName?": "/** The name to render in the column header. If not specified and field is specified, the field name will be used as the header name. */",
      "headerValueGetter?": "/** Function or expression. Gets the value for display in the header. */",
      "headerTooltip?": "/** Tooltip for the column header */",
      "headerClass?": "/** CSS class to use for the header cell. Can be a string, array of strings, or function. */",
      "suppressHeaderKeyboardEvent?": "/** Suppress the grid taking action for the relevant keyboard event when a header is focused. */",
      "columnGroupShow?": "/** Whether to only show the column when the group is open / closed. If not set the column is always displayed as part of the group. */",
      "toolPanelClass?": "/** CSS class to use for the tool panel cell. Can be a string, array of strings, or function. */",
      "suppressColumnsToolPanel?": "/** Set to `true` if you do not want this column or group to appear in the Columns Tool Panel.\n     * @default false\n     */",
      "suppressFiltersToolPanel?": "/** Set to `true` if you do not want this column (filter) or group (filter group) to appear in the Filters Tool Panel.\n     * @default false\n     */",
      "tooltipComponent?": "/** Provide your own tooltip component for the column.\n     * See [Tooltip Component](https://www.ag-grid.com/javascript-data-grid/tooltips/) for framework specific implementation details.\n     */",
      "tooltipComponentParams?": "/** The params used to configure `tooltipComponent`. */",
      "pivotKeys?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "cellAriaRole?": "/** Used for screen reader announcements - the role property of the cells that belong to this column.\n     * @default 'gridcell'\n     */",
      "context?": "/** Context property that can be used to associate arbitrary application data with this column definition.\n     */"
    }
  },
  "IAggFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "IAggFuncParams<TData, TValue>"
      },
      "returnType": "any"
    }
  },
  "IAggFuncParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "values": "(TValue | null)[]",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "pivotResultColumn?": "Column",
      "rowNode": "IRowNode<TData>",
      "data": "TData",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "values": "/** Values to aggregate */",
      "column": "/** Column the aggregation function is working on */",
      "colDef": "/** ColDef of the aggregation column */",
      "pivotResultColumn?": "/** Pivot Result Column being produced using this aggregation */",
      "rowNode": "/** The parent RowNode, where the aggregation result will be shown */",
      "data": "/** data (if any) of the parent RowNode */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "HeaderClassParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "colDef": "AbstractColDef<TData, TValue>",
      "column?": "Column<TValue> | null",
      "columnGroup?": "ColumnGroup | null",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "HeaderClass": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": "string | string[] | ((params: HeaderClassParams<TData, TValue>) => string | string[] | undefined)"
  },
  "ToolPanelClassParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "colDef": "AbstractColDef<TData, TValue>",
      "column?": "Column<TValue> | null",
      "columnGroup?": "ProvidedColumnGroup | null",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ToolPanelClass": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": "string | string[] | ((params: ToolPanelClassParams<TData, TValue>) => string | string[] | undefined)"
  },
  "StringOrNumKeys": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TObj"
      ]
    },
    "type": "keyof TObj & (string | number)"
  },
  "NestedPath": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TValue",
        "Prefix extends string",
        "TValueNestedChild",
        "TDepth extends any[]"
      ]
    },
    "type": "TValue extends object ? `${Prefix}.${TDepth['length'] extends 5 ? any : NestedFieldPaths<TValue, TValueNestedChild, TDepth>}` : never"
  },
  "ColDefField": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": "TData extends any ? NestedFieldPaths<TData, TValue, [ ]> : never"
  },
  "NestedFieldPaths": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TDepth extends any[] = [\n]"
      ]
    },
    "type": "{ [TKey in StringOrNumKeys<TData>]: TData[TKey] extends ((...args: any[]) => any) | undefined ? never : TData[TKey] extends any[] | undefined ? (TData[TKey] extends TValue ? `${TKey}` : never) | `${TKey}.${number}` : (TData[TKey] extends TValue ? `${TKey}` : never) | NestedPath<TData[TKey], `${TKey}`, TValue, [ ...TDepth, any ]>; }[StringOrNumKeys<TData>]"
  },
  "ColDef": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ],
      "doc": "/** Configuration options for columns in AG Grid. */"
    },
    "type": {
      "colId?": "string",
      "field?": "ColDefField<TData, TValue>",
      "type?": "string | string[]",
      "cellDataType?": "boolean | string",
      "valueGetter?": "string | ValueGetterFunc<TData, TValue>",
      "valueFormatter?": "string | ValueFormatterFunc<TData, TValue>",
      "refData?": "{ [key: string]: string; }",
      "keyCreator?": "(params: KeyCreatorParams<TData, TValue>) => string",
      "equals?": "(valueA: TValue | null | undefined, valueB: TValue | null | undefined) => boolean",
      "tooltipField?": "ColDefField<TData>",
      "tooltipValueGetter?": "(params: ITooltipParams<TData, TValue>) => string | any",
      "checkboxSelection?": "boolean | CheckboxSelectionCallback<TData, TValue>",
      "showDisabledCheckboxes?": "boolean",
      "icons?": "{ [key: string]: ((...args: any[]) => any) | string; }",
      "suppressNavigable?": "boolean | SuppressNavigableCallback<TData, TValue>",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams<TData, TValue>) => boolean",
      "suppressPaste?": "boolean | SuppressPasteCallback<TData, TValue>",
      "suppressFillHandle?": "boolean",
      "hide?": "boolean",
      "initialHide?": "boolean",
      "lockVisible?": "boolean",
      "lockPosition?": "boolean | 'left' | 'right'",
      "suppressMovable?": "boolean",
      "useValueFormatterForExport?": "boolean",
      "editable?": "boolean | EditableCallback<TData, TValue>",
      "valueSetter?": "string | ValueSetterFunc<TData, TValue>",
      "valueParser?": "string | ValueParserFunc<TData, TValue>",
      "cellEditor?": "any",
      "cellEditorParams?": "any",
      "cellEditorSelector?": "CellEditorSelectorFunc<TData, TValue>",
      "singleClickEdit?": "boolean",
      "cellEditorPopup?": "boolean",
      "cellEditorPopupPosition?": "'over' | 'under'",
      "useValueParserForImport?": "boolean",
      "onCellValueChanged?": "(event: NewValueParams<TData, TValue>) => void",
      "onCellClicked?": "(event: CellClickedEvent<TData, TValue>) => void",
      "onCellDoubleClicked?": "(event: CellDoubleClickedEvent<TData, TValue>) => void",
      "onCellContextMenu?": "(event: CellContextMenuEvent<TData, TValue>) => void",
      "getQuickFilterText?": "(params: GetQuickFilterTextParams<TData, TValue>) => string",
      "filterValueGetter?": "string | ValueGetterFunc<TData>",
      "floatingFilter?": "boolean",
      "suppressFloatingFilterButton?": "boolean",
      "wrapHeaderText?": "boolean",
      "autoHeaderHeight?": "boolean",
      "headerComponent?": "any",
      "headerComponentParams?": "any",
      "menuTabs?": "ColumnMenuTab[]",
      "columnChooserParams?": "ColumnChooserParams",
      "columnsMenuParams?": "ColumnsMenuParams",
      "suppressMenu?": "boolean",
      "suppressHeaderMenuButton?": "boolean",
      "suppressHeaderFilterButton?": "boolean",
      "suppressHeaderContextMenu?": "boolean",
      "mainMenuItems?": "(string | MenuItemDef<TData>)[] | GetMainMenuItems<TData>",
      "contextMenuItems?": "(string | MenuItemDef<TData>)[] | GetContextMenuItems<TData>",
      "headerCheckboxSelection?": "boolean | HeaderCheckboxSelectionCallback<TData, TValue>",
      "headerCheckboxSelectionFilteredOnly?": "boolean",
      "headerCheckboxSelectionCurrentPageOnly?": "boolean",
      "chartDataType?": "'category' | 'series' | 'time' | 'excluded'",
      "pinned?": "boolean | 'left' | 'right' | null",
      "initialPinned?": "boolean | 'left' | 'right'",
      "lockPinned?": "boolean",
      "pivot?": "boolean",
      "initialPivot?": "boolean",
      "pivotIndex?": "number | null",
      "initialPivotIndex?": "number",
      "pivotComparator?": "(valueA: string, valueB: string) => number",
      "enablePivot?": "boolean",
      "cellStyle?": "CellStyle | CellStyleFunc<TData, TValue>",
      "cellClass?": "string | string[] | CellClassFunc<TData, TValue>",
      "cellClassRules?": "CellClassRules<TData, TValue>",
      "cellRenderer?": "any",
      "cellRendererParams?": "any",
      "cellRendererSelector?": "CellRendererSelectorFunc<TData, TValue>",
      "loadingCellRenderer?": "any",
      "loadingCellRendererParams?": "any",
      "loadingCellRendererSelector?": "CellRendererSelectorFunc<TData, TValue>",
      "autoHeight?": "boolean",
      "wrapText?": "boolean",
      "enableCellChangeFlash?": "boolean",
      "suppressCellFlash?": "boolean",
      "rowDrag?": "boolean | RowDragCallback<TData, TValue>",
      "rowDragText?": "(params: IRowDragItem, dragItemCount: number) => string",
      "dndSource?": "boolean | DndSourceCallback<TData, TValue>",
      "dndSourceOnRowDrag?": "(params: DndSourceOnRowDragParams<TData>) => void",
      "rowGroup?": "boolean",
      "initialRowGroup?": "boolean",
      "rowGroupIndex?": "number | null",
      "initialRowGroupIndex?": "number",
      "enableRowGroup?": "boolean",
      "enableValue?": "boolean",
      "aggFunc?": "string | IAggFunc<TData, TValue> | null",
      "initialAggFunc?": "string | IAggFunc<TData, TValue>",
      "defaultAggFunc?": "string",
      "allowedAggFuncs?": "string[]",
      "showRowGroup?": "string | boolean",
      "sortable?": "boolean",
      "sort?": "SortDirection",
      "initialSort?": "SortDirection",
      "sortIndex?": "number | null",
      "initialSortIndex?": "number",
      "sortingOrder?": "SortDirection[]",
      "comparator?": "(valueA: TValue | null | undefined, valueB: TValue | null | undefined, nodeA: IRowNode<TData>, nodeB: IRowNode<TData>, isDescending: boolean) => number",
      "unSortIcon?": "boolean",
      "colSpan?": "(params: ColSpanParams<TData, TValue>) => number",
      "rowSpan?": "(params: RowSpanParams<TData, TValue>) => number",
      "width?": "number",
      "initialWidth?": "number",
      "minWidth?": "number",
      "maxWidth?": "number",
      "flex?": "number",
      "initialFlex?": "number",
      "resizable?": "boolean",
      "suppressSizeToFit?": "boolean",
      "suppressAutoSize?": "boolean",
      "pivotValueColumn?": "Column | null",
      "pivotTotalColumnIds?": "string[]",
      "suppressSpanHeaderHeight?": "boolean",
      "headerName?": "string",
      "headerValueGetter?": "string | HeaderValueGetterFunc<TData, TValue>",
      "headerTooltip?": "string",
      "headerClass?": "HeaderClass<TData, TValue>",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams<TData, TValue>) => boolean",
      "columnGroupShow?": "ColumnGroupShowType",
      "toolPanelClass?": "ToolPanelClass<TData, TValue>",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "tooltipComponent?": "any",
      "tooltipComponentParams?": "any",
      "pivotKeys?": "string[]",
      "cellAriaRole?": "string",
      "context?": "any",
      "filter?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "any",
      "floatingFilterComponentParams?": "any"
    },
    "docs": {
      "colId?": "/** The unique ID to give the column. This is optional. If missing, the ID will default to the field.\n     *  If both field and colId are missing, a unique ID will be generated.\n     *  This ID is used to identify the column in the API for sorting, filtering etc.\n     */",
      "field?": "/** The field of the row object to get the cell's data from.\n     * Deep references into a row object is supported via dot notation, i.e `'address.firstLine'`.\n     */",
      "type?": "/** A comma separated string or array of strings containing `ColumnType` keys which can be used as a template for a column.\n     * This helps to reduce duplication of properties when you have a lot of common column properties.\n     */",
      "cellDataType?": "/** The data type of the cell values for this column.\n     * Can either infer the data type from the row data (`true` - the default behaviour),\n     * define a specific data type (`string`), or have no data type (`false`).\n     *\n     * If setting a specific data type (`string` value),\n     * this can either be one of the pre-defined data types\n     * `'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`,\n     * or a custom data type that has been defined in the `dataTypeDefinitions` grid option.\n     *\n     * Data type inference only works for the Client-Side Row Model, and requires non-null data.\n     * It will also not work if the `valueGetter`, `valueParser` or `refData` properties are defined,\n     * or if this column is a sparkline.\n     *\n     * @default true\n     */",
      "valueGetter?": "/** Function or expression. Gets the value from your data for display. */",
      "valueFormatter?": "/** A function or expression to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering. */",
      "refData?": "/** Provided a reference data map to be used to map column values to their respective value from the map. */",
      "keyCreator?": "/** Function to return a string key for a value.\n     * This string is used for grouping, Set filtering, and searching within cell editor dropdowns.\n     * When filtering and searching the string is exposed to the user, so make sure to return a human-readable value.\n     */",
      "equals?": "/** Custom comparator for values, used by renderer to know if values have changed. Cells whose values have not changed don't get refreshed.\n     * By default the grid uses `===` which should work for most use cases.\n     */",
      "tooltipField?": "/** The field of the tooltip to apply to the cell. */",
      "tooltipValueGetter?": "/** Callback that should return the string to use for a tooltip, `tooltipField` takes precedence if set.\n     * If using a custom `tooltipComponent` you may return any custom value to be passed to your tooltip component.\n     */",
      "checkboxSelection?": "/** Set to `true` (or return `true` from function) to render a selection checkbox in the column.\n     * @default false\n     */",
      "showDisabledCheckboxes?": "/** Set to `true` to display a disabled checkbox when row is not selectable and checkboxes are enabled.\n     * @default false\n     */",
      "icons?": "/** Icons to use inside the column instead of the grid's default icons. Leave undefined to use defaults.\n     * @initial\n     * */",
      "suppressNavigable?": "/** Set to `true` if this column is not navigable (i.e. cannot be tabbed into), otherwise `false`.\n     * Can also be a callback function to have different rows navigable.\n     * @default false\n     */",
      "suppressKeyboardEvent?": "/** Allows the user to suppress certain keyboard events in the grid cell.\n     * @default false\n     */",
      "suppressPaste?": "/** Pasting is on by default as long as cells are editable (non-editable cells cannot be modified, even with a paste operation).\n     * Set to `true` turn paste operations off.\n     */",
      "suppressFillHandle?": "/** Set to true to prevent the fillHandle from being rendered in any cell that belongs to this column */",
      "hide?": "/** Set to `true` for this column to be hidden.\n     * @default false\n     */",
      "initialHide?": "/** Same as `hide`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "lockVisible?": "/** Set to `true` to block making column visible / hidden via the UI (API will still work).\n     * @default false\n     */",
      "lockPosition?": "/** Lock a column to position to `'left'` or`'right'` to always have this column displayed in that position. `true` is treated as `'left'` */",
      "suppressMovable?": "/** Set to `true` if you do not want this column to be movable via dragging.\n     * @default false\n     */",
      "useValueFormatterForExport?": "/** By default, values are formatted using the column's `valueFormatter` when exporting data from the grid.\n     * This applies to CSV and Excel export, as well as clipboard operations and the fill handle.\n     * Set to `false` to prevent values from being formatted for these operations.\n     * Regardless of this option, if custom handling is provided for the export operation, the value formatter will not be used.\n     * @default true\n     */",
      "editable?": "/** Set to `true` if this column is editable, otherwise `false`. Can also be a function to have different rows editable.\n     * @default false\n     */",
      "valueSetter?": "/** Function or expression. Sets the value into your data for saving. Return `true` if the data changed. */",
      "valueParser?": "/** Function or expression. Parses the value for saving. */",
      "cellEditor?": "/** Provide your own cell editor component for this column's cells.\n     */",
      "cellEditorParams?": "/** Params to be passed to the `cellEditor` component. */",
      "cellEditorSelector?": "/** Callback to select which cell editor to be used for a given row within the same column. */",
      "singleClickEdit?": "/** Set to `true` to have cells under this column enter edit mode after single click.\n     * @default false\n     */",
      "cellEditorPopup?": "/** Set to `true`, to have the cell editor appear in a popup.\n     */",
      "cellEditorPopupPosition?": "/** Set the position for the popup cell editor. Possible values are\n     *  - `over` Popup will be positioned over the cell\n     *  - `under` Popup will be positioned below the cell leaving the cell value visible.\n     *\n     * @default 'over'\n     */",
      "useValueParserForImport?": "/** By default, values are parsed using the column's `valueParser` when importing data to the grid.\n     * This applies to clipboard operations and the fill handle.\n     * Set to `false` to prevent values from being parsed for these operations.\n     * Regardless of this option, if custom handling is provided for the import operation, the value parser will not be used.\n     * @default true\n     */",
      "onCellValueChanged?": "/** Callback for after the value of a cell has changed, either due to editing or the application calling `api.setValue()`. */",
      "onCellClicked?": "/** Callback called when a cell is clicked. */",
      "onCellDoubleClicked?": "/** Callback called when a cell is double clicked. */",
      "onCellContextMenu?": "/** Callback called when a cell is right clicked. */",
      "getQuickFilterText?": "/** A function to tell the grid what Quick Filter text to use for this column if you don't want to use the default (which is calling `toString` on the value). */",
      "filterValueGetter?": "/** Function or expression. Gets the value for filtering purposes.\n     */",
      "floatingFilter?": "/** Whether to display a floating filter for this column.\n     * @default false\n     */",
      "suppressFloatingFilterButton?": "/** If `true`, the button in the floating filter that opens the parent filter in a popup will not be displayed.\n     * Only applies if `floatingFilter = true`.\n     */",
      "wrapHeaderText?": "/** If enabled then column header names that are too long for the column width will wrap onto the next line. Default `false` */",
      "autoHeaderHeight?": "/** If enabled then the column header row will automatically adjust height to accommodate the size of the header cell.\n     * This can be useful when using your own `headerComponent` or long header names in conjunction with `wrapHeaderText`.\n     * @default false\n     */",
      "headerComponent?": "/** The custom header component to be used for rendering the component header. If none specified the default AG Grid header component is used.\n     * See [Header Component](https://www.ag-grid.com/javascript-data-grid/component-header/) for framework specific implementation detail.\n     */",
      "headerComponentParams?": "/** The parameters to be passed to the `headerComponent`. */",
      "menuTabs?": "/** Set to an array containing zero, one or many of the following options: `'filterMenuTab' | 'generalMenuTab' | 'columnsMenuTab'`.\n     * This is used to figure out which menu tabs are present and in which order the tabs are shown.\n     */",
      "columnChooserParams?": "/** Params used to change the behaviour and appearance of the Column Chooser/Columns Menu tab. */",
      "columnsMenuParams?": "/** @deprecated v31.1 Use columnChooserParams instead */",
      "suppressMenu?": "/** @deprecated v31.1 Use suppressHeaderMenuButton instead */",
      "suppressHeaderMenuButton?": "/** Set to `true` if no menu button should be shown for this column header.\n     * @default false\n     */",
      "suppressHeaderFilterButton?": "/** Set to `true` to not display the filter button in the column header.\n     * Doesn't apply when `columnMenu = 'legacy'`.\n     * @default false\n     */",
      "suppressHeaderContextMenu?": "/** Set to `true` to not display the column menu when the column header is right-clicked.\n     * Doesn't apply when `columnMenu = 'legacy'`.\n     * @default false\n     */",
      "mainMenuItems?": "/** Customise the list of menu items available in the column menu.\n     */",
      "contextMenuItems?": "/** Customise the list of menu items available in the context menu.\n     */",
      "headerCheckboxSelection?": "/** If `true` or the callback returns `true`, a 'select all' checkbox will be put into the header. */",
      "headerCheckboxSelectionFilteredOnly?": "/** If `true`, the header checkbox selection will only select filtered items.\n     * @default false\n     */",
      "headerCheckboxSelectionCurrentPageOnly?": "/** If `true`, the header checkbox selection will only select nodes on the current page.\n     * @default false\n     */",
      "chartDataType?": "/** Defines the chart data type that should be used for a column. */",
      "pinned?": "/** Pin a column to one side: `right` or `left`. A value of `true` is converted to `'left'`. */",
      "initialPinned?": "/** Same as `pinned`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "lockPinned?": "/** Set to true to block the user pinning the column, the column can only be pinned via definitions or API.\n     * @default false\n     */",
      "pivot?": "/** Set to true to pivot by this column. */",
      "initialPivot?": "/** Same as `pivot`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "pivotIndex?": "/** Set this in columns you want to pivot by.\n     * If only pivoting by one column, set this to any number (e.g. `0`).\n     * If pivoting by multiple columns, set this to where you want this column to be in the order of pivots (e.g. `0` for first, `1` for second, and so on).\n     */",
      "initialPivotIndex?": "/** Same as `pivotIndex`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "pivotComparator?": "/** Only for CSRM, see [SSRM Pivoting](https://ag-grid.com/javascript-data-grid/server-side-model-pivoting/).\n     *\n     * Comparator to use when ordering the pivot columns, when this column is used to pivot on.\n     * The values will always be strings, as the pivot service uses strings as keys for the pivot groups.\n     * @initial\n     */",
      "enablePivot?": "/** Set to `true` if you want to be able to pivot by this column via the GUI. This will not block the API or properties being used to achieve pivot.\n     * @default false\n     */",
      "cellStyle?": "/** An object of css values / or function returning an object of css values for a particular cell. */",
      "cellClass?": "/** Class to use for the cell. Can be string, array of strings, or function that returns a string or array of strings. */",
      "cellClassRules?": "/** Rules which can be applied to include certain CSS classes.\n     */",
      "cellRenderer?": "/** Provide your own cell Renderer component for this column's cells.\n     * See [Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-cell-renderer/) for framework specific implementation details.\n     */",
      "cellRendererParams?": "/** Params to be passed to the `cellRenderer` component. */",
      "cellRendererSelector?": "/** Callback to select which cell renderer to be used for a given row within the same column. */",
      "loadingCellRenderer?": "/** The renderer to be used while the row is in an unloaded state.\n     * Only used if `suppressServerSideFullWidthLoadingRow` is enabled.\n     */",
      "loadingCellRendererParams?": "/** Params to be passed to the `loadingCellRenderer` component. */",
      "loadingCellRendererSelector?": "/** Callback to select which loading renderer to be used for a given row within the same column. */",
      "autoHeight?": "/** Set to `true` to have the grid calculate the height of a row based on contents of this column.\n     * @default false\n     */",
      "wrapText?": "/** Set to `true` to have the text wrap inside the cell - typically used with `autoHeight`.\n     * @default false\n     */",
      "enableCellChangeFlash?": "/** Set to `true` to flash a cell when it's refreshed.\n     * @default false\n     */",
      "suppressCellFlash?": "/** Set to `true` to prevent this column from flashing on changes. Only applicable if cell flashing is turned on for the grid.\n     * @default false\n     * @deprecated 31.2 Use `enableCellChangeFlash={false}` in the ColDef.\n     */",
      "rowDrag?": "/** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow row dragging.\n     * @default false\n     */",
      "rowDragText?": "/** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.\n     * If this callback is not set, the `rowDragText` callback in the `gridOptions` will be used and\n     * if there is no callback in the `gridOptions` the current cell value will be used.\n     */",
      "dndSource?": "/** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow dragging for native drag and drop.\n     * @default false\n     */",
      "dndSourceOnRowDrag?": "/** Function to allow custom drag functionality for native drag and drop.\n     */",
      "rowGroup?": "/** Set to `true` to row group by this column.\n     * @default false\n     */",
      "initialRowGroup?": "/** Same as `rowGroup`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "rowGroupIndex?": "/** Set this in columns you want to group by.\n     * If only grouping by one column, set this to any number (e.g. `0`).\n     * If grouping by multiple columns, set this to where you want this column to be in the group (e.g. `0` for first, `1` for second, and so on).\n     */",
      "initialRowGroupIndex?": "/** Same as `rowGroupIndex`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "enableRowGroup?": "/** Set to `true` if you want to be able to row group by this column via the GUI.\n     * This will not block the API or properties being used to achieve row grouping.\n     * @default false\n     */",
      "enableValue?": "/** Set to `true` if you want to be able to aggregate by this column via the GUI.\n     * This will not block the API or properties being used to achieve aggregation.\n     * @default false\n     */",
      "aggFunc?": "/** Name of function to use for aggregation. In-built options are: `sum`, `min`, `max`, `count`, `avg`, `first`, `last`. Also accepts a custom aggregation name or an aggregation function. */",
      "initialAggFunc?": "/** Same as `aggFunc`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "defaultAggFunc?": "/** The name of the aggregation function to use for this column when it is enabled via the GUI.\n     * Note that this does not immediately apply the aggregation function like `aggFunc`\n     * @default 'sum'\n     */",
      "allowedAggFuncs?": "/** Aggregation functions allowed on this column e.g. `['sum', 'avg']`.\n     * If missing, all installed functions are allowed.\n     * This will only restrict what the GUI allows a user to select, it does not impact when you set a function via the API. */",
      "showRowGroup?": "/** Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group.\n     * @initial\n     */",
      "sortable?": "/** Set to `false` to disable sorting which is enabled by default.\n     * @default true\n     */",
      "sort?": "/** If sorting by default, set it here. Set to `asc` or `desc`. */",
      "initialSort?": "/** Same as `sort`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "sortIndex?": "/** If sorting more than one column by default, specifies order in which the sorting should be applied. */",
      "initialSortIndex?": "/** Same as `sortIndex`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "sortingOrder?": "/**  Array defining the order in which sorting occurs (if sorting is enabled). An array with any of the following in any order `['asc','desc',null]` */",
      "comparator?": "/** Override the default sorting order by providing a custom sort comparator.\n     *\n     * - `valueA`, `valueB` are the values to compare.\n     * - `nodeA`,  `nodeB` are the corresponding RowNodes. Useful if additional details are required by the sort.\n     * - `isDescending` - `true` if sort direction is `desc`. Not to be used for inverting the return value as the grid already applies `asc` or `desc` ordering.\n     *\n     * Return:\n     *  - `0`  valueA is the same as valueB\n     *  - `> 0` Sort valueA after valueB\n     *  - `< 0` Sort valueA before valueB\n     */",
      "unSortIcon?": "/** Set to `true` if you want the unsorted icon to be shown when no sort is applied to this column.\n     * @default false\n     */",
      "colSpan?": "/** By default, each cell will take up the width of one column. You can change this behaviour to allow cells to span multiple columns. */",
      "rowSpan?": "/** By default, each cell will take up the height of one row. You can change this behaviour to allow cells to span multiple rows.\n     */",
      "width?": "/** Initial width in pixels for the cell. */",
      "initialWidth?": "/** Same as `width`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "minWidth?": "/** Minimum width in pixels for the cell. */",
      "maxWidth?": "/** Maximum width in pixels for the cell. */",
      "flex?": "/** Used instead of `width` when the goal is to fill the remaining empty space of the grid. */",
      "initialFlex?": "/** Same as `flex`, except only applied when creating a new column. Not applied when updating column definitions.\n     * @initial\n     */",
      "resizable?": "/** Set to `false` to disable resizing which is enabled by default.\n     * @default true\n     */",
      "suppressSizeToFit?": "/** Set to `true` if you want this column's width to be fixed during 'size to fit' operations.\n     * @default false\n     */",
      "suppressAutoSize?": "/** Set to `true` if you do not want this column to be auto-resizable by double clicking it's edge.\n     * @default false\n     */",
      "pivotValueColumn?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "pivotTotalColumnIds?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressSpanHeaderHeight?": "/** Set to `true` if you don't want the column header for this column to span the whole height of the header container.\n     * @default false\n     */",
      "headerName?": "/** The name to render in the column header. If not specified and field is specified, the field name will be used as the header name. */",
      "headerValueGetter?": "/** Function or expression. Gets the value for display in the header. */",
      "headerTooltip?": "/** Tooltip for the column header */",
      "headerClass?": "/** CSS class to use for the header cell. Can be a string, array of strings, or function. */",
      "suppressHeaderKeyboardEvent?": "/** Suppress the grid taking action for the relevant keyboard event when a header is focused. */",
      "columnGroupShow?": "/** Whether to only show the column when the group is open / closed. If not set the column is always displayed as part of the group. */",
      "toolPanelClass?": "/** CSS class to use for the tool panel cell. Can be a string, array of strings, or function. */",
      "suppressColumnsToolPanel?": "/** Set to `true` if you do not want this column or group to appear in the Columns Tool Panel.\n     * @default false\n     */",
      "suppressFiltersToolPanel?": "/** Set to `true` if you do not want this column (filter) or group (filter group) to appear in the Filters Tool Panel.\n     * @default false\n     */",
      "tooltipComponent?": "/** Provide your own tooltip component for the column.\n     * See [Tooltip Component](https://www.ag-grid.com/javascript-data-grid/tooltips/) for framework specific implementation details.\n     */",
      "tooltipComponentParams?": "/** The params used to configure `tooltipComponent`. */",
      "pivotKeys?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "cellAriaRole?": "/** Used for screen reader announcements - the role property of the cells that belong to this column.\n     * @default 'gridcell'\n     */",
      "context?": "/** Context property that can be used to associate arbitrary application data with this column definition.\n     */",
      "filter?": "/** Filter component to use for this column.\n     * - Set to `true` to use the default filter.\n     * - Set to the name of a provided filter: `agNumberColumnFilter`, `agTextColumnFilter`, `agDateColumnFilter`, `agMultiColumnFilter`, `agSetColumnFilter`.\n     * - Set to a `IFilterComp`.\n     */",
      "filterParams?": "/** Params to be passed to the filter component specified in `filter`. */",
      "floatingFilterComponent?": "/** The custom component to be used for rendering the floating filter.\n     * If none is specified the default AG Grid is used.\n     */",
      "floatingFilterComponentParams?": "/** Params to be passed to `floatingFilterComponent`. */"
    }
  },
  "ColTypeDef": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": "Omit<ColDef<TData, TValue>, 'type'>"
  },
  "ColumnFunctionCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CheckboxSelectionCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CheckboxSelectionCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "CheckboxSelectionCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "RowDragCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "RowDragCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "RowDragCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "DndSourceCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "DndSourceOnRowDragParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "rowNode": "IRowNode<TData>",
      "dragEvent": "DragEvent",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "rowNode": "/** Row node for the given row */",
      "dragEvent": "/** The DOM event that represents a drag and drop interaction */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "DndSourceCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "DndSourceCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "EditableCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "EditableCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "EditableCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "SuppressPasteCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SuppressPasteCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "SuppressPasteCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "SuppressNavigableCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SuppressNavigableCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "SuppressNavigableCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "HeaderCheckboxSelectionCallbackParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "HeaderCheckboxSelectionCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "HeaderCheckboxSelectionCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "GetQuickFilterTextParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "value": "TValue | null | undefined",
      "node": "IRowNode<TData>",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "value": "/** Value for the cell. */",
      "node": "/** Row node for the given row */",
      "data": "/** Row data associated with the node. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ColumnMenuTab": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'filterMenuTab' | 'generalMenuTab' | 'columnsMenuTab'"
  },
  "ColumnsMenuParams": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `ColumnChooserParams` instead */"
    },
    "type": {
      "suppressSyncLayoutWithGrid?": "boolean",
      "suppressColumnFilter?": "boolean",
      "suppressColumnSelectAll?": "boolean",
      "suppressColumnExpandAll?": "boolean",
      "contractColumnSelection?": "boolean",
      "columnLayout?": "(ColDef | ColGroupDef)[]"
    },
    "docs": {
      "suppressSyncLayoutWithGrid?": "/** To suppress updating the layout of columns as they are rearranged in the grid */",
      "suppressColumnFilter?": "/** To suppress Column Filter section*/",
      "suppressColumnSelectAll?": "/** To suppress Select / Un-select all widget*/",
      "suppressColumnExpandAll?": "/** To suppress Expand / Collapse all widget*/",
      "contractColumnSelection?": "/** By default, column groups start expanded.\n     * Pass true to default to contracted groups*/",
      "columnLayout?": "/** Custom Columns Panel layout */"
    }
  },
  "ColumnChooserParams": {
    "meta": {},
    "type": {
      "suppressSyncLayoutWithGrid?": "boolean",
      "suppressColumnFilter?": "boolean",
      "suppressColumnSelectAll?": "boolean",
      "suppressColumnExpandAll?": "boolean",
      "contractColumnSelection?": "boolean",
      "columnLayout?": "(ColDef | ColGroupDef)[]"
    },
    "docs": {
      "suppressSyncLayoutWithGrid?": "/** To suppress updating the layout of columns as they are rearranged in the grid */",
      "suppressColumnFilter?": "/** To suppress Column Filter section*/",
      "suppressColumnSelectAll?": "/** To suppress Select / Un-select all widget*/",
      "suppressColumnExpandAll?": "/** To suppress Expand / Collapse all widget*/",
      "contractColumnSelection?": "/** By default, column groups start expanded.\n     * Pass true to default to contracted groups*/",
      "columnLayout?": "/** Custom Columns Panel layout */"
    }
  },
  "BaseColDefParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "BaseColDefOptionalDataParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData> | null",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ValueGetterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "getValue": "(field: string) => any",
      "node": "IRowNode<TData> | null",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "getValue": "/** A utility method for getting other column values */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ValueGetterFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ValueGetterParams<TData, TValue>"
      },
      "returnType": "TValue | null | undefined"
    }
  },
  "HeaderLocation": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'chart' | 'columnDrop' | 'columnToolPanel' | 'csv' | 'filterToolPanel' | 'groupFilter' | 'header' | 'model' | 'advancedFilter' | null"
  },
  "HeaderValueGetterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "colDef": "AbstractColDef<TData, TValue>",
      "column?": "Column<TValue> | null",
      "columnGroup?": "ColumnGroup | ProvidedColumnGroup | null",
      "providedColumnGroup": "ProvidedColumnGroup | null",
      "location": "HeaderLocation",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "column?": "/** Column for this callback if applicable*/",
      "columnGroup?": "/** ColumnGroup for this callback if applicable */",
      "providedColumnGroup": "/** Original column group if applicable */",
      "location": "/** Where the column is going to appear */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "HeaderValueGetterFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "HeaderValueGetterParams<TData, TValue>"
      },
      "returnType": "string"
    }
  },
  "ChangedValueParams": {
    "meta": {
      "typeParams": [
        "TData",
        "TValueOld",
        "TValueNew"
      ]
    },
    "type": {
      "oldValue": "TValueOld",
      "newValue": "TValueNew",
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "NewValueParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "oldValue": "TValue | null | undefined",
      "newValue": "TValue | null | undefined",
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ValueSetterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "oldValue": "TValue | null | undefined",
      "newValue": "TValue | null | undefined",
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ValueSetterFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ValueSetterParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "ValueParserParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "oldValue": "TValue | null | undefined",
      "newValue": "string",
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ValueParserFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ValueParserParams<TData, TValue>"
      },
      "returnType": "TValue | null | undefined"
    }
  },
  "ValueFormatterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "value": "TValue | null | undefined",
      "node": "IRowNode<TData> | null",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "value": "/** Value for the cell. */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ValueFormatterFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ValueFormatterParams<TData, TValue>"
      },
      "returnType": "string"
    }
  },
  "KeyCreatorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "value": "TValue | null | undefined",
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "value": "/** Value for the cell. */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ColSpanParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData> | null",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "RowSpanParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData> | null",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SuppressKeyboardEventParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "event": "KeyboardEvent",
      "editing": "boolean",
      "node": "IRowNode<TData>",
      "data": "TData | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "event": "/** The keyboard event the grid received */",
      "editing": "/** Whether the cell is editing or not */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node. Will be `undefined` for group rows. */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SuppressHeaderKeyboardEventParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue> | ColumnGroup",
      "colDef": "ColDef<TData, TValue> | ColGroupDef<TData> | null",
      "headerRowIndex": "number",
      "event": "KeyboardEvent",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "headerRowIndex": "/** The index of the header row of the current focused header */",
      "event": "/** The keyboard event the grid received */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CellClassParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** Column for this callback */",
      "colDef": "/** The colDef associated with the column for this cell */",
      "value": "/** The value to be rendered */",
      "data": "/** The data associated with this row from rowData. Data is `undefined` for row groups.\n     */",
      "node": "/** The RowNode associated with this row */",
      "rowIndex": "/** The index of the row */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CellClassFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "cellClassParams": "CellClassParams<TData, TValue>"
      },
      "returnType": "string | string[] | null | undefined"
    }
  },
  "CellStyleFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "cellClassParams": "CellClassParams<TData, TValue>"
      },
      "returnType": "CellStyle | null | undefined"
    }
  },
  "CellStyle": {
    "meta": {},
    "type": {
      "[cssProperty: string]": "string | number"
    }
  },
  "CellClassRules": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "[cssClassName: string]": "((params: CellClassParams<TData, TValue>) => boolean) | string"
    }
  },
  "CellRendererSelectorFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ICellRendererParams<TData, TValue>"
      },
      "returnType": "CellRendererSelectorResult | undefined"
    }
  },
  "CellEditorSelectorFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ICellEditorParams<TData, TValue>"
      },
      "returnType": "CellEditorSelectorResult | undefined"
    }
  },
  "CellRendererSelectorResult": {
    "meta": {},
    "type": {
      "component?": "any",
      "params?": "any"
    },
    "docs": {
      "component?": "/** Equivalent of setting `colDef.cellRenderer` */",
      "params?": "/** Equivalent of setting `colDef.cellRendererParams` */"
    }
  },
  "CellEditorSelectorResult": {
    "meta": {},
    "type": {
      "component?": "any",
      "params?": "any",
      "popup?": "boolean",
      "popupPosition?": "'over' | 'under'"
    },
    "docs": {
      "component?": "/** Equivalent of setting `colDef.cellEditor` */",
      "params?": "/** Equivalent of setting `colDef.cellEditorParams` */",
      "popup?": "/** Equivalent of setting `colDef.cellEditorPopup` */",
      "popupPosition?": "/** Equivalent of setting `colDef.cellEditorPopupPosition` */"
    }
  },
  "SortDirection": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'asc' | 'desc' | null"
  },
  "ValueParserLiteParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData",
        "TValue"
      ]
    },
    "type": "Omit<ValueParserParams<TData, TValue>, 'data' | 'node' | 'oldValue'>"
  },
  "ValueParserLiteFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData",
        "TValue"
      ]
    },
    "type": {
      "arguments": {
        "params": "ValueParserLiteParams<TData, TValue>"
      },
      "returnType": "TValue | null | undefined"
    }
  },
  "ValueFormatterLiteParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData",
        "TValue"
      ]
    },
    "type": "Omit<ValueFormatterParams<TData, TValue>, 'data' | 'node'>"
  },
  "ValueFormatterLiteFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData",
        "TValue"
      ]
    },
    "type": {
      "arguments": {
        "params": "ValueFormatterLiteParams<TData, TValue>"
      },
      "returnType": "string"
    }
  },
  "DataTypeCheckerParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData",
        "TValue"
      ]
    },
    "type": "Omit<BaseColDefOptionalDataParams<TData, TValue>, 'data' | 'node'> & { value: TValue | null | undefined; }"
  },
  "DataTypeChecker": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData",
        "TValue"
      ]
    },
    "type": {
      "arguments": {
        "params": "DataTypeCheckerParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "BaseCellDataType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'text' | 'number' | 'boolean' | 'date' | 'dateString' | 'object'"
  },
  "BaseDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TValueType extends BaseCellDataType",
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "TextDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** Represents a `'text'` data type (type `string`). */"
    },
    "type": {
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "NumberDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** Represents a `'number'` data type (type `number`). */"
    },
    "type": {
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "BooleanDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** Represents a `'boolean'` data type (type `boolean`). */"
    },
    "type": {
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "DateDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** Represents a `'date'` data type (type `Date`). */"
    },
    "type": {
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "DateStringDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** Represents a `'dateString'` data type (type `string` that represents a date). */"
    },
    "type": {
      "dateParser?": "(value: string | undefined) => Date | undefined",
      "dateFormatter?": "(value: Date | undefined) => string | undefined",
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "dateParser?": "/** Converts a date in `string` format to a `Date`. */",
      "dateFormatter?": "/** Converts a date in `Date` format to a `string`. */",
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "ObjectDataTypeDefinition": {
    "meta": {
      "typeParams": [
        "TData",
        "TValue"
      ],
      "doc": "/** Represents an `'object'` data type (any type). */"
    },
    "type": {
      "baseDataType": "TValueType",
      "extendsDataType": "string",
      "valueParser?": "ValueParserLiteFunc<TData, TValue>",
      "valueFormatter?": "ValueFormatterLiteFunc<TData, TValue>",
      "dataTypeMatcher?": "(value: any) => boolean",
      "columnTypes?": "string | string[]",
      "appendColumnTypes?": "boolean",
      "suppressDefaultProperties?": "boolean"
    },
    "docs": {
      "baseDataType": "/** The underlying data type */",
      "extendsDataType": "/** The data type that this extends. Either one of the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`)\n     * or another custom data type.\n     */",
      "valueParser?": "/** Parses a value into the correct data type.\n     * This will be used as the `colDef.valueParser` (unless overridden),\n     * and in other places where parsing is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value parser of the data type that this extends will be used.\n     */",
      "valueFormatter?": "/** Formats a value for display.\n     * This will be used as the `colDef.valueFormatter` (unless overridden),\n     * and in other places where formatting is required.\n     * As this could be used in places where there is no row,\n     * the `params` do not have row node or data properties.\n     * If not provided, the value formatter of the data type that this extends will be used.\n     */",
      "dataTypeMatcher?": "/** Returns `true` if the `value` is of this data type.\n     * Used when inferring cell data types as well as to ensure values of the\n     * wrong data type cannot be set into this column.\n     * If not provided, the data type matcher of the data type that this extends will be used.\n     */",
      "columnTypes?": "/** A comma separated string or array of strings containing `ColumnType` keys,\n     * which can be used as a template for columns of this data type.\n     */",
      "appendColumnTypes?": "/** If `true`, this data type will append any specified column types to those of the data type that this extends.\n     * If `false`, the column types for this data type will replace any of the data type that this extends.\n     * @default false\n     */",
      "suppressDefaultProperties?": "/** By default, certain column definition properties are set based on the base data type.\n     * If this is set to `true`, these properties will not be set.\n     * @default false\n     */"
    }
  },
  "DataTypeDefinition": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "TextDataTypeDefinition<TData> | NumberDataTypeDefinition<TData> | BooleanDataTypeDefinition<TData> | DateDataTypeDefinition<TData> | DateStringDataTypeDefinition<TData> | ObjectDataTypeDefinition<TData, any>"
  },
  "CoreDataTypeDefinition": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "Omit<TextDataTypeDefinition<TData>, 'extendsDataType'> | Omit<NumberDataTypeDefinition<TData>, 'extendsDataType'> | Omit<BooleanDataTypeDefinition<TData>, 'extendsDataType'> | Omit<DateDataTypeDefinition<TData>, 'extendsDataType'> | Omit<DateStringDataTypeDefinition<TData>, 'extendsDataType'> | Omit<ObjectDataTypeDefinition<TData, any>, 'extendsDataType'>"
  },
  "GridOptions": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "statusBar?": "{ statusPanels: StatusPanelDef[]; }",
      "sideBar?": "SideBarDef | string | string[] | boolean | null",
      "suppressContextMenu?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "columnMenu?": "'legacy' | 'new'",
      "suppressMenuHide?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "tooltipTrigger?": "'hover' | 'focus'",
      "tooltipShowDelay?": "number",
      "tooltipHideDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "tooltipShowMode?": "'standard' | 'whenTruncated'",
      "tooltipInteraction?": "boolean",
      "popupParent?": "HTMLElement | null",
      "copyHeadersToClipboard?": "boolean",
      "copyGroupHeadersToClipboard?": "boolean",
      "clipboardDelimiter?": "string",
      "suppressCopyRowsToClipboard?": "boolean",
      "suppressCopySingleCellRanges?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "suppressCutToClipboard?": "boolean",
      "columnDefs?": "(ColDef<TData> | ColGroupDef<TData>)[] | null",
      "defaultColDef?": "ColDef<TData>",
      "defaultColGroupDef?": "Partial<ColGroupDef<TData>>",
      "columnTypes?": "{ [key: string]: ColTypeDef<TData>; }",
      "dataTypeDefinitions?": "{ [cellDataType: string]: DataTypeDefinition<TData>; }",
      "maintainColumnOrder?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "headerHeight?": "number",
      "groupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "pivotHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "suppressRowGroupHidesColumns?": "boolean",
      "colResizeDefault?": "'shift'",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "autoSizeStrategy?": "SizeColumnsToFitGridStrategy | SizeColumnsToFitProvidedWidthStrategy | SizeColumnsToContentStrategy",
      "components?": "{ [p: string]: any; }",
      "editType?": "'fullRow'",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "readOnlyEdit?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "enterNavigatesVertically?": "boolean",
      "enterNavigatesVerticallyAfterEdit?": "boolean",
      "enableCellEditingOnBackspace?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "defaultCsvExportParams?": "CsvExportParams",
      "suppressCsvExport?": "boolean",
      "defaultExcelExportParams?": "ExcelExportParams",
      "suppressExcelExport?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "includeHiddenColumnsInQuickFilter?": "boolean",
      "quickFilterParser?": "(quickFilter: string) => string[]",
      "quickFilterMatcher?": "(quickFilterParts: string[], rowQuickFilterAggregateText: string) => boolean",
      "applyQuickFilterBeforePivotOrAgg?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "enableAdvancedFilter?": "boolean",
      "advancedFilterModel?": "AdvancedFilterModel | null",
      "includeHiddenColumnsInAdvancedFilter?": "boolean",
      "advancedFilterParent?": "HTMLElement | null",
      "advancedFilterBuilderParams?": "IAdvancedFilterBuilderParams",
      "suppressAdvancedFilterEval?": "boolean",
      "enableCharts?": "boolean",
      "chartThemes?": "string[]",
      "customChartThemes?": "{ [name: string]: AgChartTheme; }",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "chartToolPanelsDef?": "ChartToolPanelsDef",
      "chartMenuItems?": "(string | MenuItemDef)[] | GetChartMenuItems<TData>",
      "loadingCellRenderer?": "any",
      "loadingCellRendererParams?": "any",
      "loadingCellRendererSelector?": "LoadingCellRendererSelectorFunc<TData>",
      "localeText?": "{ [key: string]: string; }",
      "masterDetail?": "boolean",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "detailCellRenderer?": "any",
      "detailCellRendererParams?": "any",
      "detailRowHeight?": "number",
      "detailRowAutoHeight?": "boolean",
      "context?": "any",
      "alignedGrids?": "AlignedGrid[] | (() => AlignedGrid[])",
      "tabIndex?": "number",
      "rowBuffer?": "number",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "enableCellExpressions?": "boolean",
      "suppressTouch?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "suppressBrowserResizeObserver?": "boolean",
      "suppressPropertyNamesCheck?": "boolean",
      "suppressChangeDetection?": "boolean",
      "debug?": "boolean",
      "loading?": "boolean",
      "overlayLoadingTemplate?": "string",
      "loadingOverlayComponent?": "any",
      "loadingOverlayComponentParams?": "any",
      "suppressLoadingOverlay?": "boolean",
      "overlayNoRowsTemplate?": "string",
      "noRowsOverlayComponent?": "any",
      "noRowsOverlayComponentParams?": "any",
      "suppressNoRowsOverlay?": "boolean",
      "pagination?": "boolean",
      "paginationPageSize?": "number",
      "paginationPageSizeSelector?": "number[] | boolean",
      "paginationAutoPageSize?": "boolean",
      "paginateChildRows?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pivotMode?": "boolean",
      "pivotPanelShow?": "'always' | 'onlyWhenPivoting' | 'never'",
      "pivotMaxGeneratedColumns?": "number",
      "pivotDefaultExpanded?": "number",
      "pivotColumnGroupTotals?": "'before' | 'after'",
      "pivotRowTotals?": "'before' | 'after'",
      "pivotSuppressAutoColumn?": "boolean",
      "suppressExpandablePivotGroups?": "boolean",
      "functionsReadOnly?": "boolean",
      "aggFuncs?": "{ [key: string]: IAggFunc<TData>; }",
      "suppressAggFuncInHeader?": "boolean",
      "alwaysAggregateAtRootLevel?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "removePivotHeaderRowWhenSingleValueColumn?": "boolean",
      "animateRows?": "boolean",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDuration?": "number",
      "cellFlashDelay?": "number",
      "cellFadeDuration?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "domLayout?": "DomLayoutType",
      "ensureDomOrder?": "boolean",
      "enableRtl?": "boolean",
      "suppressColumnVirtualisation?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "suppressRowVirtualisation?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "rowDragEntireRow?": "boolean",
      "rowDragMultiRow?": "boolean",
      "rowDragText?": "(params: IRowDragItem, dragItemCount: number) => string",
      "fullWidthCellRenderer?": "any",
      "fullWidthCellRendererParams?": "any",
      "embedFullWidthRows?": "boolean",
      "suppressGroupMaintainValueType?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupDefaultExpanded?": "number",
      "autoGroupColumnDef?": "ColDef<TData>",
      "groupMaintainOrder?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupLockGroupColumns?": "number",
      "groupAggFiltering?": "boolean | IsRowFilterable<TData>",
      "groupIncludeFooter?": "boolean | UseGroupFooter<TData>",
      "groupIncludeTotalFooter?": "boolean",
      "groupTotalRow?": "'top' | 'bottom' | UseGroupTotalRow<TData>",
      "grandTotalRow?": "'top' | 'bottom'",
      "suppressStickyTotalRow?": "boolean | 'grand' | 'group'",
      "groupSuppressBlankHeader?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "showOpenedGroup?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "groupAllowUnbalanced?": "boolean",
      "rowGroupPanelShow?": "'always' | 'onlyWhenGrouping' | 'never'",
      "groupRowRenderer?": "any",
      "groupRowRendererParams?": "any",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "treeData?": "boolean",
      "rowGroupPanelSuppressSort?": "boolean",
      "suppressGroupRowsSticky?": "boolean",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "rowModelType?": "RowModelType",
      "rowData?": "TData[] | null",
      "asyncTransactionWaitMillis?": "number",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "datasource?": "IDatasource",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "serverSideInitialRowCount?": "number",
      "suppressServerSideInfiniteScroll?": "boolean",
      "suppressServerSideFullWidthLoadingRow?": "boolean",
      "cacheBlockSize?": "number",
      "maxBlocksInCache?": "number",
      "maxConcurrentDatasourceRequests?": "number",
      "blockLoadDebounceMillis?": "number",
      "purgeClosedRowNodes?": "boolean",
      "serverSideDatasource?": "IServerSideDatasource",
      "serverSideSortAllLevels?": "boolean",
      "serverSideEnableClientSideSort?": "boolean",
      "serverSideOnlyRefreshFilteredGroups?": "boolean",
      "serverSideSortOnServer?": "boolean",
      "serverSideFilterOnServer?": "boolean",
      "serverSidePivotResultFieldSeparator?": "string",
      "viewportDatasource?": "IViewportDatasource",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressScrollWhenPopupsAreOpen?": "boolean",
      "suppressAnimationFrame?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "scrollbarWidth?": "number",
      "rowSelection?": "'single' | 'multiple'",
      "rowMultiSelectWithClick?": "boolean",
      "suppressRowDeselection?": "boolean",
      "suppressRowClickSelection?": "boolean",
      "suppressCellFocus?": "boolean",
      "suppressHeaderFocus?": "boolean",
      "suppressMultiRangeSelection?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "'x' | 'y' | 'xy'",
      "suppressClearOnFillReduction?": "boolean",
      "sortingOrder?": "SortDirection[]",
      "accentedSort?": "boolean",
      "unSortIcon?": "boolean",
      "suppressMultiSort?": "boolean",
      "alwaysMultiSort?": "boolean",
      "multiSortKey?": "'ctrl'",
      "suppressMaintainUnsortedOrder?": "boolean",
      "icons?": "{ [key: string]: ((...args: any[]) => any) | string; }",
      "rowHeight?": "number",
      "rowStyle?": "RowStyle",
      "rowClass?": "string | string[]",
      "rowClassRules?": "RowClassRules<TData>",
      "suppressRowHoverHighlight?": "boolean",
      "suppressRowTransform?": "boolean",
      "columnHoverHighlight?": "boolean",
      "gridId?": "string",
      "deltaSort?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "enableGroupEdit?": "boolean",
      "initialState?": "GridState",
      "reactiveCustomComponents?": "boolean",
      "getContextMenuItems?": "GetContextMenuItems<TData>",
      "getMainMenuItems?": "GetMainMenuItems<TData>",
      "postProcessPopup?": "(params: PostProcessPopupParams<TData>) => void",
      "processUnpinnedColumns?": "(params: ProcessUnpinnedColumnsParams<TData>) => Column[]",
      "processCellForClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "processHeaderForClipboard?": "(params: ProcessHeaderForExportParams<TData>) => any",
      "processGroupHeaderForClipboard?": "(params: ProcessGroupHeaderForExportParams<TData>) => any",
      "processCellFromClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "sendToClipboard?": "(params: SendToClipboardParams<TData>) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams<TData>) => string[][] | null",
      "isExternalFilterPresent?": "(params: IsExternalFilterPresentParams<TData>) => boolean",
      "doesExternalFilterPass?": "(node: IRowNode<TData>) => boolean",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "createChartContainer?": "(params: ChartRefParams<TData>) => void",
      "focusGridInnerElement?": "(params: FocusGridInnerElementParams<TData>) => boolean",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams<TData>) => HeaderPosition | null",
      "tabToNextHeader?": "(params: TabToNextHeaderParams<TData>) => HeaderPosition | boolean | null",
      "navigateToNextCell?": "(params: NavigateToNextCellParams<TData>) => CellPosition | null",
      "tabToNextCell?": "(params: TabToNextCellParams<TData>) => CellPosition | boolean | null",
      "getLocaleText?": "(params: GetLocaleTextParams<TData>) => string",
      "getDocument?": "() => Document",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams<TData>) => string",
      "getGroupRowAgg?": "(params: GetGroupRowAggParams<TData>) => any",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams<TData>) => boolean",
      "initialGroupOrderComparator?": "(params: InitialGroupOrderComparatorParams<TData>) => number",
      "processPivotResultColDef?": "(colDef: ColDef<TData>) => void",
      "processPivotResultColGroupDef?": "(colGroupDef: ColGroupDef<TData>) => void",
      "getDataPath?": "GetDataPath<TData>",
      "getChildCount?": "(dataItem: any) => number",
      "getServerSideGroupLevelParams?": "(params: GetServerSideGroupLevelParamsParams) => ServerSideGroupLevelParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "isServerSideGroup?": "IsServerSideGroup",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getBusinessKeyForNode?": "(node: IRowNode<TData>) => string",
      "getRowId?": "GetRowIdFunc<TData>",
      "resetRowDataOnUpdate?": "boolean",
      "processRowPostCreate?": "(params: ProcessRowParams<TData>) => void",
      "isRowSelectable?": "IsRowSelectable<TData>",
      "isRowMaster?": "IsRowMaster<TData>",
      "fillOperation?": "(params: FillOperationParams<TData>) => any",
      "postSortRows?": "(params: PostSortRowsParams<TData>) => void",
      "getRowStyle?": "(params: RowClassParams<TData>) => RowStyle | undefined",
      "getRowClass?": "(params: RowClassParams<TData>) => string | string[] | undefined",
      "getRowHeight?": "(params: RowHeightParams<TData>) => number | undefined | null",
      "isFullWidthRow?": "(params: IsFullWidthRowParams<TData>) => boolean",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "void",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "void",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "void",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "void",
      "onCutStart?(event: CutStartEvent<TData>)": "void",
      "onCutEnd?(event: CutEndEvent<TData>)": "void",
      "onPasteStart?(event: PasteStartEvent<TData>)": "void",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "void",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "void",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "void",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "void",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "void",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "void",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "void",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "void",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "void",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "void",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "void",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "void",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "void",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "void",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "void",
      "onFillStart?(event: FillStartEvent<TData>)": "void",
      "onFillEnd?(event: FillEndEvent<TData>)": "void",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "void",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "void",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "void",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "void",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "void",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "void",
      "onGridReady?(event: GridReadyEvent<TData>)": "void",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "void",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "void",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "void",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "void",
      "onDragStarted?(event: DragStartedEvent<TData>)": "void",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "void",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "void",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "void",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "void",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "void",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "void",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "void",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "void",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "void",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "void",
      "onCellClicked?(event: CellClickedEvent<TData>)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "void",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "void",
      "onRowClicked?(event: RowClickedEvent<TData>)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "void",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "void",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "void",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "void",
      "onSortChanged?(event: SortChangedEvent<TData>)": "void",
      "api?": "never"
    },
    "docs": {
      "statusBar?": "/** Specifies the status bar components to use in the status bar.\n     */",
      "sideBar?": "/** Specifies the side bar components.\n     */",
      "suppressContextMenu?": "/** Set to `true` to not show the context menu. Use if you don't want to use the default 'right click' context menu.\n     * @default false\n     */",
      "preventDefaultOnContextMenu?": "/** When using `suppressContextMenu`, you can use the `onCellContextMenu` function to provide your own code to handle cell `contextmenu` events.\n     * This flag is useful to prevent the browser from showing its default context menu.\n     * @default false\n     */",
      "allowContextMenuWithControlKey?": "/** Allows context menu to show, even when `Ctrl` key is held down.\n     * @default false\n     */",
      "columnMenu?": "/** Changes the display type of the column menu.\n     * `'new'` just displays the main list of menu items. `'legacy'` displays a tabbed menu.\n     * @default 'new'\n     * @initial\n     */",
      "suppressMenuHide?": "/** When `true`, the column menu button will always be shown.\n     * When `false, the column menu button will only show when the mouse is over the column header.\n     * If `columnMenu = 'legacy'`, this will default to `false` instead of `true`.\n     * @default true\n     */",
      "enableBrowserTooltips?": "/** Set to `true` to use the browser's default tooltip instead of using the grid's Tooltip Component.\n     * @default false\n     * @initial\n     */",
      "tooltipTrigger?": "/** The trigger that will cause tooltips to show and hide.\n     *  - `hover` - The tooltip will show/hide when a cell/header is hovered.\n     *  - `focus` - The tooltip will show/hide when a cell/header is focused.\n     * @default 'hover'\n     * @initial\n     */",
      "tooltipShowDelay?": "/** The delay in milliseconds that it takes for tooltips to show up once an element is hovered over.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true`.\n     * @default 2000\n     */",
      "tooltipHideDelay?": "/** The delay in milliseconds that it takes for tooltips to hide once they have been displayed.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true` and `tooltipHideTriggers` includes `timeout`.\n     * @default 10000\n     */",
      "tooltipMouseTrack?": "/** Set to `true` to have tooltips follow the cursor once they are displayed.\n     * @default false\n     * @initial\n     */",
      "tooltipShowMode?": "/** This defines when tooltip will show up for Cells, Headers and SetFilter Items.\n     *  - `standard` - The tooltip always shows up when the items configured with Tooltips are hovered.\n     * - `whenTruncated` - The tooltip will only be displayed when the items hovered have truncated (showing ellipsis) values. This property does not work when `enableBrowserTooltips={true}`.\n     * @default `standard`\n     */",
      "tooltipInteraction?": "/** Set to `true` to enable tooltip interaction. When this option is enabled, the tooltip will not hide while the\n     * tooltip itself it being hovered or has focus.\n     * @default false\n     * @initial\n     */",
      "popupParent?": "/** DOM element to use as the popup parent for grid popups (context menu, column menu etc).\n     */",
      "copyHeadersToClipboard?": "/** Set to `true` to also include headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "copyGroupHeadersToClipboard?": "/** Set to `true` to also include group headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "clipboardDelimiter?": "/** Specify the delimiter to use when copying to clipboard.\n     * @default '\\t'\n     */",
      "suppressCopyRowsToClipboard?": "/** Set to `true` to copy the cell range or focused cell to the clipboard and never the selected rows.\n     * @default false\n     */",
      "suppressCopySingleCellRanges?": "/** Set to `true` to copy rows instead of ranges when a range with only a single cell is selected.\n     * @default false\n     */",
      "suppressLastEmptyLineOnPaste?": "/** Set to `true` to work around a bug with Excel (Windows) that adds an extra empty line at the end of ranges copied to the clipboard.\n     * @default false\n     */",
      "suppressClipboardPaste?": "/** Set to `true` to turn off paste operations within the grid.\n     * @default false\n     */",
      "suppressClipboardApi?": "/** Set to `true` to stop the grid trying to use the Clipboard API, if it is blocked, and immediately fallback to the workaround.\n     * @default false\n     */",
      "suppressCutToClipboard?": "/** Set to `true` to block **cut** operations within the grid.\n     * @default false\n     */",
      "columnDefs?": "/** Array of Column / Column Group definitions.\n     */",
      "defaultColDef?": "/** A default column definition. Items defined in the actual column definitions get precedence.\n     */",
      "defaultColGroupDef?": "/** A default column group definition. All column group definitions will use these properties. Items defined in the actual column group definition get precedence.\n     * @initial\n     */",
      "columnTypes?": "/** An object map of custom column types which contain groups of properties that column definitions can reuse by referencing in their `type` property.\n     */",
      "dataTypeDefinitions?": "/** An object map of cell data types to their definitions.\n     * Cell data types can either override/update the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`),\n     * or can be custom data types.\n     */",
      "maintainColumnOrder?": "/** Keeps the order of Columns maintained after new Column Definitions are updated.\n     * @default false\n     */",
      "suppressFieldDotNotation?": "/** If `true`, then dots in field names (e.g. `'address.firstLine'`) are not treated as deep references. Allows you to use dots in your field name if you prefer.\n     * @default false\n     */",
      "headerHeight?": "/** The height in pixels for the row containing the column label header. If not specified, it uses the theme value of `header-height`.\n     */",
      "groupHeaderHeight?": "/** The height in pixels for the rows containing header column groups. If not specified, it uses `headerHeight`.\n     */",
      "floatingFiltersHeight?": "/** The height in pixels for the row containing the floating filters. If not specified, it uses the theme value of `header-height`.\n     */",
      "pivotHeaderHeight?": "/** The height in pixels for the row containing the columns when in pivot mode. If not specified, it uses `headerHeight`.\n     */",
      "pivotGroupHeaderHeight?": "/** The height in pixels for the row containing header column groups when in pivot mode. If not specified, it uses `groupHeaderHeight`.\n     */",
      "allowDragFromColumnsToolPanel?": "/** Allow reordering and pinning columns by dragging columns from the Columns Tool Panel to the grid.\n     * @default false\n     */",
      "suppressMovableColumns?": "/** Set to `true` to suppress column moving, i.e. to make the columns fixed position.\n     * @default false\n     */",
      "suppressColumnMoveAnimation?": "/** If `true`, the `ag-column-moving` class is not added to the grid while columns are moving. In the default themes, this results in no animation when moving columns.\n     * @default false\n     */",
      "suppressDragLeaveHidesColumns?": "/** If `true`, when you drag a column out of the grid (e.g. to the group zone) the column is not hidden.\n     * @default false\n     */",
      "suppressRowGroupHidesColumns?": "/** If `true`, when you drag a column into a row group panel the column is not hidden.\n     * @default false\n     */",
      "colResizeDefault?": "/** Set to `'shift'` to have shift-resize as the default resize operation (same as user holding down `Shift` while resizing).\n     */",
      "suppressAutoSize?": "/** Suppresses auto-sizing columns for columns. In other words, double clicking a column's header's edge will not auto-size.\n     * @default false\n     * @initial\n     */",
      "autoSizePadding?": "/** Number of pixels to add to a column width after the [auto-sizing](./column-sizing/#auto-size-columns-to-fit-cell-contents) calculation.\n     * Set this if you want to add extra room to accommodate (for example) sort icons, or some other dynamic nature of the header.\n     * @default 20\n     */",
      "skipHeaderOnAutoSize?": "/** Set this to `true` to skip the `headerName` when `autoSize` is called by default.\n     * @default false\n     * @initial\n     */",
      "autoSizeStrategy?": "/** Auto-size the columns when the grid is loaded. Can size to fit the grid width, fit a provided width, or fit the cell contents.\n     * @initial\n     */",
      "components?": "/** A map of component names to components.\n     * @initial\n     */",
      "editType?": "/** Set to `'fullRow'` to enable Full Row Editing. Otherwise leave blank to edit one cell at a time.\n     */",
      "singleClickEdit?": "/** Set to `true` to enable Single Click Editing for cells, to start editing with a single click.\n     * @default false\n     */",
      "suppressClickEdit?": "/** Set to `true` so that neither single nor double click starts editing.\n     * @default false\n     */",
      "readOnlyEdit?": "/** Set to `true` to stop the grid updating data after `Edit`, `Clipboard` and `Fill Handle` operations. When this is set, it is intended the application will update the data, eg in an external immutable store, and then pass the new dataset to the grid. <br />**Note:** `rowNode.setDataValue()` does not update the value of the cell when this is `True`, it fires `onCellEditRequest` instead.\n     * @default false\n     */",
      "stopEditingWhenCellsLoseFocus?": "/** Set this to `true` to stop cell editing when grid loses focus.\n     * The default is that the grid stays editing until focus goes onto another cell.\n     * @default false\n     * @initial\n     */",
      "enterNavigatesVertically?": "/** Set to `true` along with `enterNavigatesVerticallyAfterEdit` to have Excel-style behaviour for the `Enter` key.\n     * i.e. pressing the `Enter` key will move down to the cell beneath and `Shift+Enter` will move up to the cell above.\n     * @default false\n     */",
      "enterNavigatesVerticallyAfterEdit?": "/** Set to `true` along with `enterNavigatesVertically` to have Excel-style behaviour for the 'Enter' key.\n     * i.e. pressing the Enter key will move down to the cell beneath and Shift+Enter key will move up to the cell above.\n     * @default false\n     */",
      "enableCellEditingOnBackspace?": "/** Forces Cell Editing to start when backspace is pressed. This is only relevant for MacOS users.\n     */",
      "undoRedoCellEditing?": "/** Set to `true` to enable Undo / Redo while editing.\n     * @initial\n     */",
      "undoRedoCellEditingLimit?": "/** Set the size of the undo / redo stack.\n     * @default 10\n     * @initial\n     */",
      "defaultCsvExportParams?": "/** A default configuration object used to export to CSV.\n     */",
      "suppressCsvExport?": "/** Prevents the user from exporting the grid to CSV.\n     * @default false\n     */",
      "defaultExcelExportParams?": "/** A default configuration object used to export to Excel.\n     */",
      "suppressExcelExport?": "/** Prevents the user from exporting the grid to Excel.\n     * @default false\n     */",
      "excelStyles?": "/** A list (array) of Excel styles to be used when exporting to Excel with styles.\n     * @initial\n     */",
      "quickFilterText?": "/** Rows are filtered using this text as a Quick Filter.\n     */",
      "cacheQuickFilter?": "/** Set to `true` to turn on the Quick Filter cache, used to improve performance when using the Quick Filter.\n     * @default false\n     * @initial\n     */",
      "includeHiddenColumnsInQuickFilter?": "/** Hidden columns are excluded from the Quick Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "quickFilterParser?": "/** Changes how the Quick Filter splits the Quick Filter text into search terms.\n     */",
      "quickFilterMatcher?": "/** Changes the matching logic for whether a row passes the Quick Filter.\n     */",
      "applyQuickFilterBeforePivotOrAgg?": "/** When pivoting, Quick Filter is only applied on the pivoted data\n     * (or aggregated data if `groupAggFiltering = true`).\n     * Set to `true` to apply Quick Filter before pivoting (/aggregating) instead.\n     * @default false\n     */",
      "excludeChildrenWhenTreeDataFiltering?": "/** Set to `true` to override the default tree data filtering behaviour to instead exclude child nodes from filter results.\n     * @default false\n     */",
      "enableAdvancedFilter?": "/** Set to true to enable the Advanced Filter.\n     * @default false\n     */",
      "advancedFilterModel?": "/** @deprecated As of v31, use `initialState.filter.advancedFilterModel` instead.\n     * @initial\n     */",
      "includeHiddenColumnsInAdvancedFilter?": "/** Hidden columns are excluded from the Advanced Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "advancedFilterParent?": "/** DOM element to use as the parent for the Advanced Filter to allow it to appear outside of the grid.\n     * Set to `null` or `undefined` to appear inside the grid.\n     */",
      "advancedFilterBuilderParams?": "/** Customise the parameters passed to the Advanced Filter Builder.\n     */",
      "suppressAdvancedFilterEval?": "/** By default, Advanced Filter sanitises user input and passes it to `new Function()` to provide the best performance.\n     * Set to `true` to prevent this and use defined functions instead.\n     * This will result in slower filtering, but it enables Advanced Filter to work when `unsafe-eval` is disabled.\n     * @default false\n     */",
      "enableCharts?": "/** Set to `true` to Enable Charts.\n     * @default false\n     */",
      "chartThemes?": "/** The list of chart themes that a user can choose from in the chart panel.\n     * @default ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];\n     * @initial\n     */",
      "customChartThemes?": "/** A map containing custom chart themes.\n     * @initial\n     */",
      "chartThemeOverrides?": "/** Chart theme overrides applied to all themes.\n     * @initial\n     */",
      "chartToolPanelsDef?": "/** Allows customisation of the Chart Tool Panels, such as changing the tool panels visibility and order, as well as choosing which charts should be displayed in the chart panel.\n     * @initial\n     */",
      "chartMenuItems?": "/** Get chart menu items. Only applies when using AG Charts Enterprise.\n     */",
      "loadingCellRenderer?": "/** Provide your own loading cell renderer to use when data is loading via a DataSource.\n     * See [Loading Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-loading-cell-renderer/) for framework specific implementation details.\n     */",
      "loadingCellRendererParams?": "/** Params to be passed to the `loadingCellRenderer` component.\n     */",
      "loadingCellRendererSelector?": "/** Callback to select which loading cell renderer to be used when data is loading via a DataSource.\n     * @initial\n     */",
      "localeText?": "/** A map of key->value pairs for localising text within the grid.\n     * @initial\n     */",
      "masterDetail?": "/** Set to `true` to enable Master Detail.\n     * @default false\n     */",
      "keepDetailRows?": "/** Set to `true` to keep detail rows for when they are displayed again.\n     * @default false\n     * @initial\n     */",
      "keepDetailRowsCount?": "/** Sets the number of details rows to keep.\n     * @default 10\n     * @initial\n     */",
      "detailCellRenderer?": "/** Provide a custom `detailCellRenderer` to use when a master row is expanded.\n     * See [Detail Cell Renderer](https://www.ag-grid.com/javascript-data-grid/master-detail-custom-detail/) for framework specific implementation details.\n     */",
      "detailCellRendererParams?": "/** Specifies the params to be used by the Detail Cell Renderer. Can also be a function that provides the params to enable dynamic definitions of the params.\n     */",
      "detailRowHeight?": "/** Set fixed height in pixels for each detail row.\n     * @initial\n     */",
      "detailRowAutoHeight?": "/** Set to `true` to have the detail grid dynamically change it's height to fit it's rows.\n     * @initial\n     */",
      "context?": "/** Provides a context object that is provided to different callbacks the grid uses. Used for passing additional information to the callbacks by your application.\n     * @initial\n     */",
      "alignedGrids?": "/**\n     * A list of grids to treat as Aligned Grids.\n     * Provide a list if the grids / apis already exist or return via a callback to allow the aligned grids to be retrieved asynchronously.\n     * If grids are aligned then the columns and horizontal scrolling will be kept in sync.\n     */",
      "tabIndex?": "/** Change this value to set the tabIndex order of the Grid within your application.\n     * @default 0\n     * @initial\n     */",
      "rowBuffer?": "/** The number of rows rendered outside the viewable area the grid renders.\n     * Having a buffer means the grid will have rows ready to show as the user slowly scrolls vertically.\n     * @default 10\n     */",
      "valueCache?": "/** Set to `true` to turn on the value cache.\n     * @default false\n     * @initial\n     */",
      "valueCacheNeverExpires?": "/** Set to `true` to configure the value cache to not expire after data updates.\n     * @default false\n     * @initial\n     */",
      "enableCellExpressions?": "/** Set to `true` to allow cell expressions.\n     * @default false\n     * @initial\n     */",
      "suppressTouch?": "/** Disables touch support (but does not remove the browser's efforts to simulate mouse events on touch).\n     * @default false\n     * @initial\n     */",
      "suppressFocusAfterRefresh?": "/** Set to `true` to not set focus back on the grid after a refresh. This can avoid issues where you want to keep the focus on another part of the browser.\n     * @default false\n     */",
      "suppressAsyncEvents?": "/** Disables the asynchronous nature of the events introduced in v10, and makes them synchronous. This property only exists for the purpose of supporting legacy code which has a dependency on synchronous events from earlier versions (v9 or earlier) of AG Grid. **It is strongly recommended that you do not change this property unless you have legacy issues.**\n     * @deprecated v31 Events should be handled asynchronously.\n     * @default false\n     * @initial\n     */",
      "suppressBrowserResizeObserver?": "/** The grid will check for `ResizeObserver` and use it if it exists in the browser, otherwise it will use the grid's alternative implementation. Some users reported issues with Chrome's `ResizeObserver`. Use this property to always use the grid's alternative implementation should such problems exist.\n     * @default false\n     * @initial\n     */",
      "suppressPropertyNamesCheck?": "/** Disables showing a warning message in the console if using a `gridOptions` or `colDef` property that doesn't exist.\n     * @default false\n     * @initial\n     */",
      "suppressChangeDetection?": "/** Disables change detection.\n     * @default false\n     */",
      "debug?": "/** Set this to `true` to enable debug information from the grid and related components. Will result in additional logging being output, but very useful when investigating problems.\n     * @default false\n     * @initial\n     */",
      "loading?": "/** Show or hide the loading overlay.\n     */",
      "overlayLoadingTemplate?": "/** Provide a HTML string to override the default loading overlay.\n     */",
      "loadingOverlayComponent?": "/** Provide a custom loading overlay component.\n     * @initial\n     */",
      "loadingOverlayComponentParams?": "/** Customise the parameters provided to the loading overlay component.\n     */",
      "suppressLoadingOverlay?": "/** Disables the 'loading' overlay.\n     * @deprecated v32 - Deprecated. Use `loading=false` instead.\n     * @default false\n     * @initial\n     */",
      "overlayNoRowsTemplate?": "/** Provide a HTML string to override the default no-rows overlay.\n     */",
      "noRowsOverlayComponent?": "/** Provide a custom no-rows overlay component.\n     * @initial\n     */",
      "noRowsOverlayComponentParams?": "/** Customise the parameters provided to the no-rows overlay component.\n     */",
      "suppressNoRowsOverlay?": "/** Set to `true` to prevent the no-rows overlay being shown when there is no row data.\n     * @default false\n     * @initial\n     */",
      "pagination?": "/** Set whether pagination is enabled.\n     * @default false\n     */",
      "paginationPageSize?": "/** How many rows to load per page. If `paginationAutoPageSize` is specified, this property is ignored.\n     * @default 100\n     */",
      "paginationPageSizeSelector?": "/** Determines if the page size selector is shown in the pagination panel or not.\n     * Set to an array of values to show the page size selector with custom list of possible page sizes.\n     * Set to `true` to show the page size selector with the default page sizes `[20, 50, 100]`.\n     * Set to `false` to hide the page size selector.\n     * @default true\n     * @initial\n     */",
      "paginationAutoPageSize?": "/** Set to `true` so that the number of rows to load per page is automatically adjusted by the grid so each page shows enough rows to just fill the area designated for the grid. If `false`, `paginationPageSize` is used.\n     * @default false\n     */",
      "paginateChildRows?": "/** Set to `true` to have pages split children of groups when using Row Grouping or detail rows with Master Detail.\n     * @default false\n     * @initial\n     */",
      "suppressPaginationPanel?": "/** If `true`, the default grid controls for navigation are hidden.\n     * This is useful if `pagination=true` and you want to provide your own pagination controls.\n     * Otherwise, when `pagination=true` the grid automatically shows the necessary controls at the bottom so that the user can navigate through the different pages.\n     * @default false\n     */",
      "pivotMode?": "/** Set to `true` to enable pivot mode.\n     * @default false\n     */",
      "pivotPanelShow?": "/** When to show the 'pivot panel' (where you drag rows to pivot) at the top. Note that the pivot panel will never show if `pivotMode` is off.\n     * @default 'never'\n     * @initial\n     */",
      "pivotMaxGeneratedColumns?": "/** The maximum number of generated columns before the grid halts execution. Upon reaching this number, the grid halts generation of columns\n     * and triggers a `pivotMaxColumnsExceeded` event. `-1` for no limit.\n     * @default -1\n     */",
      "pivotDefaultExpanded?": "/** If pivoting, set to the number of column group levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "pivotColumnGroupTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear within the Pivot Column Groups, in the position specified.\n     */",
      "pivotRowTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear for each value column in the position specified.\n     */",
      "pivotSuppressAutoColumn?": "/** If `true`, the grid will not swap in the grouping column when pivoting. Useful if pivoting using Server Side Row Model or Viewport Row Model and you want full control of all columns including the group column.\n     * @default false\n     * @initial\n     */",
      "suppressExpandablePivotGroups?": "/** When enabled, pivot column groups will appear 'fixed', without the ability to expand and collapse the column groups.\n     * @default false\n     * @initial\n     */",
      "functionsReadOnly?": "/** If `true`, then row group, pivot and value aggregation will be read-only from the GUI. The grid will display what values are used for each, but will not allow the user to change the selection.\n     * @default false\n     */",
      "aggFuncs?": "/** A map of 'function name' to 'function' for custom aggregation functions.\n     * @initial\n     */",
      "suppressAggFuncInHeader?": "/** When `true`, column headers won't include the `aggFunc` name, e.g. `'sum(Bank Balance)`' will just be `'Bank Balance'`.\n     * @default false\n     * @initial\n     */",
      "alwaysAggregateAtRootLevel?": "/** When using aggregations, the grid will always calculate the root level aggregation value.\n     * @default false\n     */",
      "aggregateOnlyChangedColumns?": "/** When using change detection, only the updated column will be re-aggregated.\n     * @default false\n     */",
      "suppressAggFilteredOnly?": "/** Set to `true` so that aggregations are not impacted by filtering.\n     * @default false\n     */",
      "removePivotHeaderRowWhenSingleValueColumn?": "/** Set to `true` to omit the value Column header when there is only a single value column.\n     * @default false\n     * @initial\n     */",
      "animateRows?": "/** Set to `false` to disable Row Animation which is enabled by default.\n     * @default true\n     */",
      "enableCellChangeFlash?": "/** Set to `true` to have cells flash after data changes.\n     * @default false\n     * @deprecated 31.2 use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns.\n     */",
      "cellFlashDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long a cell should remain in its \"flashed\" state.\n     * @default 500\n     */",
      "cellFlashDelay?": "/** @deprecated v31.1 - use `cellFlashDuration` instead.\n     */",
      "cellFadeDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long the \"flashed\" state animation takes to fade away after the timer set by cellFlashDuration has completed.\n     * @default 1000\n     */",
      "cellFadeDelay?": "/** @deprecated v31.1 - use `cellFadeDuration` instead.\n     */",
      "allowShowChangeAfterFilter?": "/** Set to `true` to have cells flash after data changes even when the change is due to filtering.\n     * @default false\n     * @initial\n     */",
      "domLayout?": "/** Switch between layout options: `normal`, `autoHeight`, `print`.\n     * @default 'normal'\n     */",
      "ensureDomOrder?": "/** When `true`, the order of rows and columns in the DOM are consistent with what is on screen.\n     * Disables row animations.\n     * @default false\n     * @initial\n     */",
      "enableRtl?": "/** Set to `true` to operate the grid in RTL (Right to Left) mode.\n     * @default false\n     * @initial\n     */",
      "suppressColumnVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the columns. For example, if you have 100 columns, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "suppressMaxRenderedRowRestriction?": "/** By default the grid has a limit of rendering a maximum of 500 rows at once (remember the grid only renders rows you can see, so unless your display shows more than 500 rows without vertically scrolling this will never be an issue).\n     * <br />**This is only relevant if you are manually setting `rowBuffer` to a high value (rendering more rows than can be seen), or `suppressRowVirtualisation` is true, or if your grid height is able to display more than 500 rows at once.**\n     * @default false\n     * @initial\n     */",
      "suppressRowVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the rows. For example, if you have 100 rows, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "rowDragManaged?": "/** Set to `true` to enable Managed Row Dragging.\n     * @default false\n     */",
      "suppressRowDrag?": "/** Set to `true` to suppress row dragging.\n     * @default false\n     */",
      "suppressMoveWhenRowDragging?": "/** Set to `true` to suppress moving rows while dragging the `rowDrag` waffle. This option highlights the position where the row will be placed and it will only move the row on mouse up.\n     * @default false\n     */",
      "rowDragEntireRow?": "/** Set to `true` to enable clicking and dragging anywhere on the row without the need for a drag handle.\n     * @default false\n     */",
      "rowDragMultiRow?": "/** Set to `true` to enable dragging multiple rows at the same time.\n     * @default false\n     */",
      "rowDragText?": "/** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.\n     * If this callback is not set, the current cell value will be used.\n     * If the `rowDragText` callback is set in the ColDef it will take precedence over this, except when\n     * `rowDragEntireRow=true`.\n     * @initial\n     */",
      "fullWidthCellRenderer?": "/** Provide your own cell renderer component to use for full width rows.\n     * See [Full Width Rows](https://www.ag-grid.com/javascript-data-grid/full-width-rows/) for framework specific implementation details.\n     */",
      "fullWidthCellRendererParams?": "/** Customise the parameters provided to the `fullWidthCellRenderer` component.\n     */",
      "embedFullWidthRows?": "/** Set to `true` to have the Full Width Rows embedded in grid's main container so they can be scrolled horizontally.\n     */",
      "suppressGroupMaintainValueType?": "/** @deprecated v31\n     * When enabled, the grid will cast group values to string type.\n     * @default false\n     * @initial\n     */",
      "groupDisplayType?": "/** Specifies how the results of row grouping should be displayed.\n     *\n     *  The options are:\n     *\n     * - `'singleColumn'`: single group column automatically added by the grid.\n     * - `'multipleColumns'`: a group column per row group is added automatically.\n     * - `'groupRows'`: group rows are automatically added instead of group columns.\n     * - `'custom'`: informs the grid that group columns will be provided.\n     */",
      "groupDefaultExpanded?": "/** If grouping, set to the number of levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "autoGroupColumnDef?": "/** Allows specifying the group 'auto column' if you are not happy with the default. If grouping, this column definition is included as the first column in the grid. If not grouping, this column is not included.\n     */",
      "groupMaintainOrder?": "/** When `true`, preserves the current group order when sorting on non-group columns.\n     * @default false\n     */",
      "groupSelectsChildren?": "/** When `true`, if you select a group, the children of the group will also be selected.\n     * @default false\n     */",
      "groupLockGroupColumns?": "/** If grouping, locks the group settings of a number of columns, e.g. `0` for no group locking. `1` for first group column locked, `-1` for all group columns locked.\n     * @default 0\n     * @initial\n     */",
      "groupAggFiltering?": "/** Set to determine whether filters should be applied on aggregated group values.\n     * @default false\n     */",
      "groupIncludeFooter?": "/** If grouping, this controls whether to show a group footer when the group is expanded.\n     * If `true`, then by default, the footer will contain aggregate data (if any) when shown and the header will be blank.\n     * When closed, the header will contain the aggregate data regardless of this setting (as the footer is hidden anyway).\n     * This is handy for 'total' rows, that are displayed below the data when the group is open, and alongside the group when it is closed.\n     * If a callback function is provided, it can used to select which groups will have a footer added.\n     * @default false\n     *\n     * @deprecated v31.3 - use `groupTotalRow` instead.\n     */",
      "groupIncludeTotalFooter?": "/** Set to `true` to show a 'grand total' group footer across all groups.\n     * @default false\n     *\n     * @deprecated v31.3 - use `grandTotalRow` instead.\n     */",
      "groupTotalRow?": "/** When provided, an extra row group total row will be inserted into row groups at the specified position, to display\n     * when the group is expanded. This row will contain the aggregate values for the group. If a callback function is\n     * provided, it can be used to selectively determine which groups will have a total row added.\n     */",
      "grandTotalRow?": "/** When provided, an extra grand total row will be inserted into the grid at the specified position.\n     * This row displays the aggregate totals of all rows in the grid.\n     */",
      "suppressStickyTotalRow?": "/** Suppress the sticky behaviour of the total rows, can be suppressed individually by passing `'grand'` or `'group'`.\n     */",
      "groupSuppressBlankHeader?": "/** If `true`, and showing footer, aggregate data will always be displayed at both the header and footer levels. This stops the possibly undesirable behaviour of the header details 'jumping' to the footer on expand.\n     * @default false\n     */",
      "groupSelectsFiltered?": "/** If using `groupSelectsChildren`, then only the children that pass the current filter will get selected.\n     * @default false\n     */",
      "showOpenedGroup?": "/** Shows the open group in the group column for non-group rows.\n     * @default false\n     */",
      "groupRemoveSingleChildren?": "/** Set to `true` to collapse groups that only have one child.\n     * @default false\n     */",
      "groupRemoveLowestSingleChildren?": "/** Set to `true` to collapse lowest level groups that only have one child.\n     * @default false\n     */",
      "groupHideOpenParents?": "/** Set to `true` to hide parents that are open. When used with multiple columns for showing groups, it can give a more pleasing user experience.\n     * @default false\n     */",
      "groupAllowUnbalanced?": "/** Set to `true` to prevent the grid from creating a '(Blanks)' group for nodes which do not belong to a group, and display the unbalanced nodes alongside group nodes.\n     * @default false\n     */",
      "rowGroupPanelShow?": "/** When to show the 'row group panel' (where you drag rows to group) at the top.\n     * @default 'never'\n     */",
      "groupRowRenderer?": "/** Provide the Cell Renderer to use when `groupDisplayType = 'groupRows'`.\n     * See [Group Row Cell Renderer](https://www.ag-grid.com/javascript-data-grid/grouping-group-rows/#providing-cell-renderer) for framework specific implementation details.\n     */",
      "groupRowRendererParams?": "/** Customise the parameters provided to the `groupRowRenderer` component.\n     */",
      "suppressMakeColumnVisibleAfterUnGroup?": "/** By default, when a column is un-grouped, i.e. using the Row Group Panel, it is made visible in the grid. This property stops the column becoming visible again when un-grouping.\n     * @default false\n     */",
      "treeData?": "/** Set to `true` to enable the Grid to work with Tree Data. You must also implement the `getDataPath(data)` callback.\n     * @default false\n     */",
      "rowGroupPanelSuppressSort?": "/** Set to `true` to suppress sort indicators and actions from the row group panel.\n     * @default false\n     * @initial\n     */",
      "suppressGroupRowsSticky?": "/** Set to `true` prevent Group Rows from sticking to the top of the grid.\n     * @default false\n     * @initial\n     */",
      "pinnedTopRowData?": "/** Data to be displayed as pinned top rows in the grid.\n     */",
      "pinnedBottomRowData?": "/** Data to be displayed as pinned bottom rows in the grid.\n     */",
      "rowModelType?": "/** Sets the row model type.\n     * @default 'clientSide'\n     * @initial\n     */",
      "rowData?": "/** Set the data to be displayed as rows in the grid.\n     */",
      "asyncTransactionWaitMillis?": "/** How many milliseconds to wait before executing a batch of async transactions.\n     */",
      "suppressModelUpdateAfterUpdateTransaction?": "/** Prevents Transactions changing sort, filter, group or pivot state when transaction only contains updates.\n     * @default false\n     */",
      "datasource?": "/** Provide the datasource for infinite scrolling.\n     */",
      "cacheOverflowSize?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "infiniteInitialRowCount?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "serverSideInitialRowCount?": "/** Set how many loading rows to display to the user for the root level group.\n     * @default 1\n     * @initial\n     */",
      "suppressServerSideInfiniteScroll?": "/** When `true`, the Server-side Row Model will suppress Infinite Scrolling and load all the data at the current level.\n     * @default false\n     * @initial\n     * @deprecated v31.1\n     */",
      "suppressServerSideFullWidthLoadingRow?": "/** When `true`, the Server-side Row Model will not use a full width loading renderer, instead using the colDef `loadingCellRenderer` if present.\n     */",
      "cacheBlockSize?": "/** How many rows for each block in the store, i.e. how many rows returned from the server at a time.\n     * @default 100\n     */",
      "maxBlocksInCache?": "/** How many blocks to keep in the store. Default is no limit, so every requested block is kept. Use this if you have memory concerns, and blocks that were least recently viewed will be purged when the limit is hit. The grid will additionally make sure it has all the blocks needed to display what is currently visible, in case this property is set to a low value.\n     * @initial\n     */",
      "maxConcurrentDatasourceRequests?": "/** How many requests to hit the server with concurrently. If the max is reached, requests are queued.\n     * Set to `-1` for no maximum restriction on requests.\n     * @default 2\n     * @initial\n     */",
      "blockLoadDebounceMillis?": "/** How many milliseconds to wait before loading a block. Useful when scrolling over many blocks, as it prevents blocks loading until scrolling has settled.\n     * @initial\n     */",
      "purgeClosedRowNodes?": "/** When enabled, closing group rows will remove children of that row. Next time the row is opened, child rows will be read from the datasource again. This property only applies when there is Row Grouping or Tree Data.\n     * @default false\n     */",
      "serverSideDatasource?": "/** Provide the `serverSideDatasource` for server side row model.\n     */",
      "serverSideSortAllLevels?": "/** When enabled, always refreshes top level groups regardless of which column was sorted. This property only applies when there is Row Grouping & sorting is handled on the server.\n     * @default false\n     */",
      "serverSideEnableClientSideSort?": "/** When enabled, sorts fully loaded groups in the browser instead of requesting from the server.\n     * @default false\n     */",
      "serverSideOnlyRefreshFilteredGroups?": "/** When enabled, only refresh groups directly impacted by a filter. This property only applies when there is Row Grouping & filtering is handled on the server.\n     * @default false\n     * @initial\n     */",
      "serverSideSortOnServer?": "/** When enabled, Sorting will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSideFilterOnServer?": "/** When enabled, Filtering will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSidePivotResultFieldSeparator?": "/** Used to split pivot field strings for generating pivot result columns when `pivotResultFields` is provided as part of a `getRows` success.\n     * @default '_'\n     * @initial\n     */",
      "viewportDatasource?": "/** To use the viewport row model you need to provide the grid with a `viewportDatasource`.\n     */",
      "viewportRowModelPageSize?": "/** When using viewport row model, sets the page size for the viewport.\n     * @initial\n     */",
      "viewportRowModelBufferSize?": "/** When using viewport row model, sets the buffer size for the viewport.\n     * @initial\n     */",
      "alwaysShowHorizontalScroll?": "/** Set to `true` to always show the horizontal scrollbar.\n     * @default false\n     */",
      "alwaysShowVerticalScroll?": "/** Set to `true` to always show the vertical scrollbar.\n     * @default false\n     */",
      "debounceVerticalScrollbar?": "/** Set to `true` to debounce the vertical scrollbar. Can provide smoother scrolling on slow machines.\n     * @default false\n     * @initial\n     */",
      "suppressHorizontalScroll?": "/** Set to `true` to never show the horizontal scroll. This is useful if the grid is aligned with another grid and will scroll when the other grid scrolls. (Should not be used in combination with `alwaysShowHorizontalScroll`.)\n     * @default false\n     */",
      "suppressScrollOnNewData?": "/** When `true`, the grid will not scroll to the top when new row data is provided. Use this if you don't want the default behaviour of scrolling to the top every time you load new data.\n     * @default false\n     */",
      "suppressScrollWhenPopupsAreOpen?": "/** When `true`, the grid will not allow mousewheel / touchpad scroll when popup elements are present.\n     * @default false\n     */",
      "suppressAnimationFrame?": "/** When `true`, the grid will not use animation frames when drawing rows while scrolling. Use this if the grid is working fast enough that you don't need animation frames and you don't want the grid to flicker.\n     * @default false\n     * @initial\n     */",
      "suppressMiddleClickScrolls?": "/** If `true`, middle clicks will result in `click` events for cells and rows. Otherwise the browser will use middle click to scroll the grid.<br />**Note:** Not all browsers fire `click` events with the middle button. Most will fire only `mousedown` and `mouseup` events, which can be used to focus a cell, but will not work to call the `onCellClicked` function.\n     * @default false\n     */",
      "suppressPreventDefaultOnMouseWheel?": "/** If `true`, mouse wheel events will be passed to the browser. Useful if your grid has no vertical scrolls and you want the mouse to scroll the browser page.\n     * @default false\n     * @initial\n     */",
      "scrollbarWidth?": "/** Tell the grid how wide in pixels the scrollbar is, which is used in grid width calculations. Set only if using non-standard browser-provided scrollbars, so the grid can use the non-standard size in its calculations.\n     * @initial\n     */",
      "rowSelection?": "/** Type of Row Selection: `single`, `multiple`.\n     */",
      "rowMultiSelectWithClick?": "/** Set to `true` to allow multiple rows to be selected using single click.\n     * @default false\n     */",
      "suppressRowDeselection?": "/** If `true`, rows will not be deselected if you hold down `Ctrl` and click the row or press `Space`.\n     * @default false\n     */",
      "suppressRowClickSelection?": "/** If `true`, row selection won't happen when rows are clicked. Use when you only want checkbox selection.\n     * @default false\n     */",
      "suppressCellFocus?": "/** If `true`, cells won't be focusable. This means keyboard navigation will be disabled for grid cells, but remain enabled in other elements of the grid such as column headers, floating filters, tool panels.\n     * @default false\n     */",
      "suppressHeaderFocus?": "/** If `true`, header cells won't be focusable. This means keyboard navigation will be disabled for grid header cells, but remain enabled in other elements of the grid such as grid cells and tool panels.\n     * @default false\n     */",
      "suppressMultiRangeSelection?": "/** If `true`, only a single range can be selected.\n     * @default false\n     */",
      "enableCellTextSelection?": "/** Set to `true` to be able to select the text within cells.\n     *\n     * **Note:** When this is set to `true`, the clipboard service is disabled and only selected text is copied.\n     * @default false\n     */",
      "enableRangeSelection?": "/** Set to `true` to enable Range Selection.\n     * @default false\n     */",
      "enableRangeHandle?": "/** Set to `true` to enable the Range Handle.\n     * @default false\n     */",
      "enableFillHandle?": "/** Set to `true` to enable the Fill Handle.\n     * @default false\n     */",
      "fillHandleDirection?": "/** Set to `'x'` to force the fill handle direction to horizontal, or set to `'y'` to force the fill handle direction to vertical.\n     * @default 'xy'\n     */",
      "suppressClearOnFillReduction?": "/** Set this to `true` to prevent cell values from being cleared when the Range Selection is reduced by the Fill Handle.\n     * @default false\n     */",
      "sortingOrder?": "/** Array defining the order in which sorting occurs (if sorting is enabled). Values can be `'asc'`, `'desc'` or `null`. For example: `sortingOrder: ['asc', 'desc']`.\n     * @default [null, 'asc', 'desc']\n     */",
      "accentedSort?": "/** Set to `true` to specify that the sort should take accented characters into account. If this feature is turned on the sort will be slower.\n     * @default false\n     */",
      "unSortIcon?": "/** Set to `true` to show the 'no sort' icon.\n     * @default false\n     */",
      "suppressMultiSort?": "/** Set to `true` to suppress multi-sort when the user shift-clicks a column header.\n     * @default false\n     */",
      "alwaysMultiSort?": "/** Set to `true` to always multi-sort when the user clicks a column header, regardless of key presses.\n     * @default false\n     */",
      "multiSortKey?": "/** Set to `'ctrl'` to have multi sorting work using the `Ctrl` (or `Command ⌘` for Mac) key.\n     */",
      "suppressMaintainUnsortedOrder?": "/** Set to `true` to suppress sorting of un-sorted data to match original row data.\n     * @default false\n     */",
      "icons?": "/** Icons to use inside the grid instead of the grid's default icons.\n     * @initial\n     */",
      "rowHeight?": "/** Default row height in pixels.\n     * @default 25\n     */",
      "rowStyle?": "/** The style properties to apply to all rows. Set to an object of key (style names) and values (style values).\n     */",
      "rowClass?": "/** CSS class(es) for all rows. Provide either a string (class name) or array of strings (array of class names).\n     */",
      "rowClassRules?": "/** Rules which can be applied to include certain CSS classes.\n     */",
      "suppressRowHoverHighlight?": "/** Set to `true` to not highlight rows by adding the `ag-row-hover` CSS class.\n     * @default false\n     */",
      "suppressRowTransform?": "/** Uses CSS `top` instead of CSS `transform` for positioning rows. Useful if the transform function is causing issues such as used in row spanning.\n     * @default false\n     * @initial\n     */",
      "columnHoverHighlight?": "/** Set to `true` to highlight columns by adding the `ag-column-hover` CSS class.\n     * @default false\n     */",
      "gridId?": "/** Provide a custom `gridId` for this instance of the grid. Value will be set on the root DOM node using the attribute `grid-id` as well as being accessible via the `gridApi.getGridId()` method.\n     * @initial\n     */",
      "deltaSort?": "/** When enabled, sorts only the rows added/updated by a transaction.\n     * @default false\n     */",
      "treeDataDisplayType?": "/**/",
      "enableGroupEdit?": "/** @initial\n     */",
      "initialState?": "/** Initial state for the grid. Only read once on initialization. Can be used in conjunction with `api.getState()` to save and restore grid state.\n     * @initial\n     */",
      "reactiveCustomComponents?": "/** **React only**.\n     *\n     * @deprecated As of v32 custom components are created reactively by default.\n     * Set this property to `false` to switch to the legacy way of declaring custom components imperatively.\n     * @initial\n     * @default true\n     */",
      "getContextMenuItems?": "/** For customising the context menu.\n     */",
      "getMainMenuItems?": "/** For customising the main 'column header' menu.\n     * @initial\n     */",
      "postProcessPopup?": "/** Allows user to process popups after they are created. Applications can use this if they want to, for example, reposition the popup.\n     */",
      "processUnpinnedColumns?": "/** Allows the user to process the columns being removed from the pinned section because the viewport is too small to accommodate them.\n     * Returns an array of columns to be removed from the pinned areas.\n     * @initial\n     */",
      "processCellForClipboard?": "/** Allows you to process cells for the clipboard. Handy if for example you have `Date` objects that need to have a particular format if importing into Excel.\n     */",
      "processHeaderForClipboard?": "/** Allows you to process header values for the clipboard.\n     */",
      "processGroupHeaderForClipboard?": "/** Allows you to process group header values for the clipboard.\n     */",
      "processCellFromClipboard?": "/** Allows you to process cells from the clipboard. Handy if for example you have number fields, and want to block non-numbers from getting into the grid.\n     */",
      "sendToClipboard?": "/** Allows you to get the data that would otherwise go to the clipboard. To be used when you want to control the 'copy to clipboard' operation yourself.\n     */",
      "processDataFromClipboard?": "/** Allows complete control of the paste operation, including cancelling the operation (so nothing happens) or replacing the data with other data.\n     */",
      "isExternalFilterPresent?": "/** Grid calls this method to know if an external filter is present.\n     */",
      "doesExternalFilterPass?": "/** Should return `true` if external filter passes, otherwise `false`.\n     */",
      "getChartToolbarItems?": "/** Callback to be used to customise the chart toolbar items.\n     * @initial\n     */",
      "createChartContainer?": "/** Callback to enable displaying the chart in an alternative chart container.\n     * @initial\n     */",
      "focusGridInnerElement?": "/** Allows overriding the element that will be focused when the grid receives focus from outside elements (tabbing into the grid).\n     * @returns `True` if this function should override the grid's default behavior, `False` to allow the grid's default behavior.\n     */",
      "navigateToNextHeader?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a header is focused. Return the next Header position to navigate to or `null` to stay on current header.\n     */",
      "tabToNextHeader?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a header is focused.\n     * Return the next header position to navigate to, `true` to stay on the current header,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "navigateToNextCell?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a cell is focused. Return the next Cell position to navigate to or `null` to stay on current cell.\n     */",
      "tabToNextCell?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a cell is focused.\n     * Return the next cell position to navigate to, `true` to stay on the current cell,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "getLocaleText?": "/** A callback for localising text within the grid.\n     * @initial\n     */",
      "getDocument?": "/** Allows overriding what `document` is used. Currently used by Drag and Drop (may extend to other places in the future). Use this when you want the grid to use a different `document` than the one available on the global scope. This can happen if docking out components (something which Electron supports)\n     */",
      "paginationNumberFormatter?": "/** Allows user to format the numbers in the pagination panel, i.e. 'row count' and 'page number' labels. This is for pagination panel only, to format numbers inside the grid's cells (i.e. your data), then use `valueFormatter` in the column definitions.\n     * @initial\n     */",
      "getGroupRowAgg?": "/** Callback to use when you need access to more then the current column for aggregation.\n     */",
      "isGroupOpenByDefault?": "/** (Client-side Row Model only) Allows groups to be open by default.\n     */",
      "initialGroupOrderComparator?": "/** Allows default sorting of groups.\n     */",
      "processPivotResultColDef?": "/** Callback to be used with pivoting, to allow changing the second column definition.\n     */",
      "processPivotResultColGroupDef?": "/** Callback to be used with pivoting, to allow changing the second column group definition.\n     */",
      "getDataPath?": "/** Callback to be used when working with Tree Data when `treeData = true`.\n     */",
      "getChildCount?": "/** Allows setting the child count for a group row.\n     * @initial\n     */",
      "getServerSideGroupLevelParams?": "/** Allows providing different params for different levels of grouping.\n     * @initial\n     */",
      "isServerSideGroupOpenByDefault?": "/** Allows groups to be open by default.\n     */",
      "isApplyServerSideTransaction?": "/** Allows cancelling transactions.\n     */",
      "isServerSideGroup?": "/** SSRM Tree Data: Allows specifying which rows are expandable.\n     */",
      "getServerSideGroupKey?": "/** SSRM Tree Data: Allows specifying group keys.\n     */",
      "getBusinessKeyForNode?": "/** Return a business key for the node. If implemented, each row in the DOM will have an attribute `row-business-key='abc'` where `abc` is what you return as the business key.\n     * This is useful for automated testing, as it provides a way for your tool to identify rows based on unique business keys.\n     */",
      "getRowId?": "/** Allows setting the ID for a particular row node based on the data.\n     * @initial\n     */",
      "resetRowDataOnUpdate?": "/** When enabled, getRowId() callback is implemented and new Row Data is set, the grid will disregard all previous rows and treat the new Row Data as new data. As a consequence, all Row State (eg selection, rendered rows) will be reset.\n     * @default false\n     */",
      "processRowPostCreate?": "/** Callback fired after the row is rendered into the DOM. Should not be used to initiate side effects.\n     */",
      "isRowSelectable?": "/** Callback to be used to determine which rows are selectable. By default rows are selectable, so return `false` to make a row un-selectable.\n     */",
      "isRowMaster?": "/** Callback to be used with Master Detail to determine if a row should be a master row. If `false` is returned no detail row will exist for this row.\n     */",
      "fillOperation?": "/** Callback to fill values instead of simply copying values or increasing number values using linear progression.\n     */",
      "postSortRows?": "/** Callback to perform additional sorting after the grid has sorted the rows.\n     */",
      "getRowStyle?": "/** Callback version of property `rowStyle` to set style for each row individually. Function should return an object of CSS values or undefined for no styles.\n     */",
      "getRowClass?": "/** Callback version of property `rowClass` to set class(es) for each row individually. Function should return either a string (class name), array of strings (array of class names) or undefined for no class.\n     */",
      "getRowHeight?": "/** Callback version of property `rowHeight` to set height for each row individually. Function should return a positive number of pixels, or return `null`/`undefined` to use the default row height.\n     */",
      "isFullWidthRow?": "/** Tells the grid if this row should be rendered as full width.\n     */",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "/** The tool panel visibility has changed. Fires twice if switching between panels - once with the old panel and once with the new panel.\n     */",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "/** The tool panel size has been changed.\n     */",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "/** The column menu visibility has changed. Fires twice if switching between tabs - once with the old tab and once with the new tab.\n     */",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "/** The context menu visibility has changed (opened or closed).\n     */",
      "onCutStart?(event: CutStartEvent<TData>)": "/** Cut operation has started.\n     */",
      "onCutEnd?(event: CutEndEvent<TData>)": "/** Cut operation has ended.\n     */",
      "onPasteStart?(event: PasteStartEvent<TData>)": "/** Paste operation has started.\n     */",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "/** Paste operation has ended.\n     */",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "/** A column, or group of columns, was hidden / shown.\n     */",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "/** A column, or group of columns, was pinned / unpinned.\n     */",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "/** A column was resized.\n     */",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "/** A column was moved.\n     */",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "/** A value column was added or removed.\n     */",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "/** The pivot mode flag was changed.\n     */",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "/** A pivot column was added, removed or order changed.\n     */",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "/** A column group was opened / closed.\n     */",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "/** User set new columns.\n     */",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "/** The list of grid columns changed.\n     */",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "/** The list of displayed columns changed. This can result from columns open / close, column move, pivot, group, etc.\n     */",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "/** The list of rendered columns changed (only columns in the visible scrolled viewport are rendered by default).\n     */",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "/** Shotgun - gets called when either a) new columns are set or b) `api.applyColumnState()` is used, so everything has changed.\n     */",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "/** A mouse cursor is initially moved over a column header.\n     */",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "/** A mouse cursor is moved out of a column header.\n     */",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "/** A click is performed on a column header.\n     */",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "/** A context menu action, such as right-click or context menu key press, is performed on a column header.\n     */",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "/** Only used by Angular, React and VueJS AG Grid components (not used if doing plain JavaScript).\n     * If the grid receives changes due to bound properties, this event fires after the grid has finished processing the change.\n     */",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "/** Value has changed after editing (this event will not fire if editing was cancelled, eg ESC was pressed) or\n     *  if cell value has changed as a result of cut, paste, cell clear (pressing Delete key),\n     * fill handle, copy range down, undo and redo.\n     */",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "/** Value has changed after editing. Only fires when `readOnlyEdit=true`.\n     */",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "/** A cell's value within a row has changed. This event corresponds to Full Row Editing only.\n     */",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "/** Editing a cell has started.\n     */",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "/** Editing a cell has stopped.\n     */",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "/** Editing a row has started (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStarted` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "/** Editing a row has stopped (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStopped` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "/** Undo operation has started.\n     */",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "/** Undo operation has ended.\n     */",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "/** Redo operation has started.\n     */",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "/** Redo operation has ended.\n     */",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "/** Range delete operation (cell clear) has started.\n     */",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "/** Range delete operation (cell clear) has ended.\n     */",
      "onFillStart?(event: FillStartEvent<TData>)": "/** Fill operation has started.\n     */",
      "onFillEnd?(event: FillEndEvent<TData>)": "/** Fill operation has ended.\n     */",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "/** Filter has been opened.\n     */",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "/** Filter has been modified and applied.\n     */",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "/** Filter was modified but not applied. Used when filters have 'Apply' buttons.\n     */",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "/** Advanced Filter Builder visibility has changed (opened or closed).\n     */",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "/** A chart has been created.\n     */",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "/** The data range for the chart has been changed.\n     */",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "/** Formatting changes have been made by users through the Customize Panel.\n     */",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "/** A chart has been destroyed.\n     */",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "/** DOM event `keyDown` happened on a cell.\n     */",
      "onGridReady?(event: GridReadyEvent<TData>)": "/** The grid has initialised and is ready for most api calls, but may not be fully rendered yet  */",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "/** Invoked immediately before the grid is destroyed. This is useful for cleanup logic that needs to run before the grid is torn down.\n     */",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "/** Fired the first time data is rendered into the grid. Use this event if you want to auto resize columns based on their contents */",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "/** The size of the grid `div` has changed. In other words, the grid was resized.\n     */",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "/** Displayed rows have changed. Triggered after sort, filter or tree expand / collapse events.\n     */",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "/** A row was removed from the DOM, for any reason. Use to clean up resources (if any) used by the row.\n     */",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "/** Which rows are rendered in the DOM has changed.\n     */",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "/** The body was scrolled horizontally or vertically.\n     */",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "/** Main body of the grid has stopped scrolling, either horizontally or vertically.\n     */",
      "onDragStarted?(event: DragStartedEvent<TData>)": "/** When dragging starts. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "/** When dragging stops. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "/** Grid state has been updated.\n     */",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "/** Triggered every time the paging state changes. Some of the most common scenarios for this event to be triggered are:\n     *\n     *  - The page size changes.\n     *  - The current shown page is changed.\n     *  - New data is loaded onto the grid.\n     */",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "/** A drag has started, or dragging was already started and the mouse has re-entered the grid having previously left the grid.\n     */",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "/** The mouse has moved while dragging.\n     */",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "/** The mouse has left the grid while dragging.\n     */",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "/** The drag has finished over the grid.\n     */",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "/** A row group column was added, removed or reordered.\n     */",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "/** A row group was opened or closed.\n     */",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "/** Fired when calling either of the API methods `expandAll()` or `collapseAll()`.\n     */",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "/** Exceeded the `pivotMaxGeneratedColumns` limit when generating columns.\n     */",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "/** The client has set new pinned row data into the grid.\n     */",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "/** Client-Side Row Model only. The client has updated data for the grid by either a) setting new Row Data or b) Applying a Row Transaction.\n     */",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "/** Async transactions have been applied. Contains a list of all transaction results.\n     */",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "/** A server side store has finished refreshing.\n     */",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "/** Header is focused.\n     */",
      "onCellClicked?(event: CellClickedEvent<TData>)": "/** Cell is clicked.\n     */",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "/** Cell is double clicked.\n     */",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "/** Cell is focused.\n     */",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "/** Mouse entered cell.\n     */",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "/** Mouse left cell.\n     */",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "/** Mouse down on cell.\n     */",
      "onRowClicked?(event: RowClickedEvent<TData>)": "/** Row is clicked.\n     */",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "/** Row is double clicked.\n     */",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "/** Row is selected or deselected. The event contains the node in question, so call the node's `isSelected()` method to see if it was just selected or deselected.\n     */",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "/** Row selection is changed. Use the grid API `getSelectedNodes()` or `getSelectedRows()` to get the new list of selected nodes / row data.\n     */",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "/** Cell is right clicked.\n     */",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "/** A change to range selection has occurred.\n     */",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "/** A tooltip has been displayed */",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "/** A tooltip was hidden */",
      "onSortChanged?(event: SortChangedEvent<TData>)": "/** Sort has changed. The grid also listens for this and updates the model.\n     */",
      "api?": "/** @deprecated Since v31 api is no longer attached to GridOptions. See https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api for how to access the api in your framework.\n     */"
    }
  },
  "RowGroupingDisplayType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'singleColumn' | 'multipleColumns' | 'groupRows' | 'custom'"
  },
  "TreeDataDisplayType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'auto' | 'custom'"
  },
  "GetDataPath": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "data": "TData"
      },
      "returnType": "string[]"
    }
  },
  "IsServerSideGroup": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "dataItem": "any"
      },
      "returnType": "boolean"
    }
  },
  "IsRowFilterable": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetGroupAggFilteringParams<TData>"
      },
      "returnType": "boolean"
    }
  },
  "UseGroupFooter": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetGroupIncludeFooterParams<TData>"
      },
      "returnType": "boolean"
    }
  },
  "UseGroupTotalRow": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetGroupIncludeTotalRowParams<TData>"
      },
      "returnType": "'top' | 'bottom' | undefined"
    }
  },
  "IsApplyServerSideTransaction": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "params": "IsApplyServerSideTransactionParams"
      },
      "returnType": "boolean"
    }
  },
  "GetServerSideGroupKey": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "dataItem": "any"
      },
      "returnType": "string"
    }
  },
  "IsRowMaster": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "dataItem": "TData"
      },
      "returnType": "boolean"
    }
  },
  "IsRowSelectable": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "node": "IRowNode<TData>"
      },
      "returnType": "boolean"
    }
  },
  "RowClassRules": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "[cssClassName: string]": "((params: RowClassParams<TData>) => boolean) | string"
    }
  },
  "RowStyle": {
    "meta": {},
    "type": {
      "[cssProperty: string]": "string | number"
    }
  },
  "RowClassParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "data": "/** The data associated with this row from rowData. Data is `undefined` for row groups.\n     */",
      "node": "/** The RowNode associated with this row */",
      "rowIndex": "/** The index of the row */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetContextMenuItems": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetContextMenuItemsParams<TData, TContext>"
      },
      "returnType": "(string | MenuItemDef<TData, TContext>)[]"
    }
  },
  "GetChartToolbarItems": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "params": "GetChartToolbarItemsParams"
      },
      "returnType": "ChartToolbarMenuItemOptions[]"
    }
  },
  "GetMainMenuItems": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetMainMenuItemsParams<TData, TContext>"
      },
      "returnType": "(string | MenuItemDef<TData, TContext>)[]"
    }
  },
  "GetChartMenuItems": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetChartMenuItemsParams<TData, TContext>"
      },
      "returnType": "(string | MenuItemDef<TData, TContext>)[]"
    }
  },
  "GetRowNodeIdFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "data": "TData"
      },
      "returnType": "string"
    }
  },
  "GetRowIdFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetRowIdParams<TData>"
      },
      "returnType": "string"
    }
  },
  "ChartRef": {
    "meta": {},
    "type": {
      "chartId": "string",
      "chart": "any",
      "chartElement": "HTMLElement",
      "destroyChart": "() => void",
      "focusChart": "() => void"
    },
    "docs": {
      "chartId": "/** The id of the created chart.\n     */",
      "chart": "/** The chart instance that is produced by AG Charts which can be used to interact with the chart directly.\n     */",
      "chartElement": "/** The chart DOM element, which the application is responsible for placing into the DOM.\n     */",
      "destroyChart": "/** The application is responsible for calling this when the chart is no longer needed.\n     */",
      "focusChart": "/** Focuses the chart.\n     * If opening the dialog via the API, the chart is not focused by default, and this method can be used.\n     */"
    }
  },
  "ChartRefParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "any",
      "chartId": "string",
      "chart": "any",
      "chartElement": "HTMLElement",
      "destroyChart": "() => void",
      "focusChart": "() => void"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "chartId": "/** The id of the created chart.\n     */",
      "chart": "/** The chart instance that is produced by AG Charts which can be used to interact with the chart directly.\n     */",
      "chartElement": "/** The chart DOM element, which the application is responsible for placing into the DOM.\n     */",
      "destroyChart": "/** The application is responsible for calling this when the chart is no longer needed.\n     */",
      "focusChart": "/** Focuses the chart.\n     * If opening the dialog via the API, the chart is not focused by default, and this method can be used.\n     */"
    }
  },
  "ServerSideGroupLevelParams": {
    "meta": {},
    "type": {
      "suppressInfiniteScroll?": "boolean",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    },
    "docs": {
      "suppressInfiniteScroll?": "/** Whether to have infinite scroll active or not for the level.\n     */",
      "maxBlocksInCache?": "/** For Infinite Scroll only.\n     * How many blocks to keep in cache.\n     * If missing, defaults to grid options `maxBlocksInCache`.\n     */",
      "cacheBlockSize?": "/** For Infinite Scroll only.\n     * Cache block size.\n     * If missing, defaults to grid options `cacheBlockSize`.\n     */"
    }
  },
  "ServerSideStoreParams": {
    "meta": {
      "doc": "/** @deprecated use ServerSideGroupLevelParams instead */"
    },
    "type": {
      "suppressInfiniteScroll?": "boolean",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    },
    "docs": {
      "suppressInfiniteScroll?": "/** Whether to have infinite scroll active or not for the level.\n     */",
      "maxBlocksInCache?": "/** For Infinite Scroll only.\n     * How many blocks to keep in cache.\n     * If missing, defaults to grid options `maxBlocksInCache`.\n     */",
      "cacheBlockSize?": "/** For Infinite Scroll only.\n     * Cache block size.\n     * If missing, defaults to grid options `cacheBlockSize`.\n     */"
    }
  },
  "LoadingCellRendererSelectorFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ILoadingCellRendererParams<TData>"
      },
      "returnType": "LoadingCellRendererSelectorResult | undefined"
    }
  },
  "LoadingCellRendererSelectorResult": {
    "meta": {},
    "type": {
      "component?": "any",
      "params?": "any"
    },
    "docs": {
      "component?": "/** Equivalent of setting `loadingCellRenderer` */",
      "params?": "/** Equivalent of setting `loadingCellRendererParams` */"
    }
  },
  "DomLayoutType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'normal' | 'autoHeight' | 'print'"
  },
  "RowPosition": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "rowPinned": "RowPinnedType"
    },
    "docs": {
      "rowIndex": "/** A positive number from 0 to n, where n is the last row the grid is rendering\n     * or -1 if you want to navigate to the grid header */",
      "rowPinned": "/** Either 'top', 'bottom' or null/undefined (for not pinned) */"
    }
  },
  "Variable": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ cssName: string; changeKey: ChangeKey; defaultValue: number; }"
  },
  "ChangeKey": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'themeChanged' | 'headerHeightChanged' | 'rowHeightChanged' | 'listItemHeightChanged'"
  },
  "AgEventTypeParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": "BuildEventTypeMap<AgPublicEventType | AgInternalEventType, { columnEverythingChanged: ColumnEverythingChangedEvent<TData, TContext>; newColumnsLoaded: NewColumnsLoadedEvent<TData, TContext>; columnPivotModeChanged: ColumnPivotModeChangedEvent<TData, TContext>; pivotMaxColumnsExceeded: PivotMaxColumnsExceededEvent<TData, TContext>; columnRowGroupChanged: ColumnRowGroupChangedEvent<TData, TContext>; expandOrCollapseAll: ExpandOrCollapseAllEvent<TData, TContext>; columnPivotChanged: ColumnPivotChangedEvent<TData, TContext>; gridColumnsChanged: GridColumnsChangedEvent<TData, TContext>; columnValueChanged: ColumnValueChangedEvent<TData, TContext>; columnMoved: ColumnMovedEvent<TData, TContext>; columnVisible: ColumnVisibleEvent<TData, TContext>; columnPinned: ColumnPinnedEvent<TData, TContext>; columnGroupOpened: ColumnGroupOpenedEvent<TData, TContext>; columnResized: ColumnResizedEvent<TData, TContext>; displayedColumnsChanged: DisplayedColumnsChangedEvent<TData, TContext>; virtualColumnsChanged: VirtualColumnsChangedEvent<TData, TContext>; columnHeaderMouseOver: ColumnHeaderMouseOverEvent<TData, TContext>; columnHeaderMouseLeave: ColumnHeaderMouseLeaveEvent<TData, TContext>; columnHeaderClicked: ColumnHeaderClickedEvent<TData, TContext>; columnHeaderContextMenu: ColumnHeaderContextMenuEvent<TData, TContext>; asyncTransactionsFlushed: AsyncTransactionsFlushedEvent<TData, TContext>; rowGroupOpened: RowGroupOpenedEvent<TData, TContext>; rowDataUpdated: RowDataUpdatedEvent<TData, TContext>; pinnedRowDataChanged: PinnedRowDataChangedEvent<TData, TContext>; rangeSelectionChanged: RangeSelectionChangedEvent<TData, TContext>; chartCreated: ChartCreatedEvent<TData, TContext>; chartRangeSelectionChanged: ChartRangeSelectionChangedEvent<TData, TContext>; chartOptionsChanged: ChartOptionsChangedEvent<TData, TContext>; chartDestroyed: ChartDestroyedEvent<TData, TContext>; toolPanelVisibleChanged: ToolPanelVisibleChangedEvent<TData, TContext>; toolPanelSizeChanged: ToolPanelSizeChangedEvent<TData, TContext>; modelUpdated: ModelUpdatedEvent<TData, TContext>; cutStart: CutStartEvent<TData, TContext>; cutEnd: CutEndEvent<TData, TContext>; pasteStart: PasteStartEvent<TData, TContext>; pasteEnd: PasteEndEvent<TData, TContext>; fillStart: FillStartEvent<TData, TContext>; fillEnd: FillEndEvent<TData, TContext>; rangeDeleteStart: RangeDeleteStartEvent<TData, TContext>; rangeDeleteEnd: RangeDeleteEndEvent<TData, TContext>; undoStarted: UndoStartedEvent<TData, TContext>; undoEnded: UndoEndedEvent<TData, TContext>; redoStarted: RedoStartedEvent<TData, TContext>; redoEnded: RedoEndedEvent<TData, TContext>; cellClicked: CellClickedEvent<TData, TContext>; cellDoubleClicked: CellDoubleClickedEvent<TData, TContext>; cellMouseDown: CellMouseDownEvent<TData, TContext>; cellContextMenu: CellContextMenuEvent<TData, TContext>; cellValueChanged: CellValueChangedEvent<TData, TContext>; cellEditRequest: CellEditRequestEvent<TData, TContext>; rowValueChanged: RowValueChangedEvent<TData, TContext>; headerFocused: HeaderFocusedEvent<TData, TContext>; cellFocused: CellFocusedEvent<TData, TContext>; rowSelected: RowSelectedEvent<TData, TContext>; selectionChanged: SelectionChangedEvent<TData, TContext>; tooltipShow: TooltipShowEvent<TData, TContext>; tooltipHide: TooltipHideEvent<TData, TContext>; cellKeyDown: CellKeyDownEvent<TData, TContext>; cellMouseOver: CellMouseOverEvent<TData, TContext>; cellMouseOut: CellMouseOutEvent<TData, TContext>; filterChanged: FilterChangedEvent<TData, TContext>; filterModified: FilterModifiedEvent<TData, TContext>; filterOpened: FilterOpenedEvent<TData, TContext>; advancedFilterBuilderVisibleChanged: AdvancedFilterBuilderVisibleChangedEvent<TData, TContext>; sortChanged: SortChangedEvent<TData, TContext>; virtualRowRemoved: VirtualRowRemovedEvent<TData, TContext>; rowClicked: RowClickedEvent<TData, TContext>; rowDoubleClicked: RowDoubleClickedEvent<TData, TContext>; gridReady: GridReadyEvent<TData, TContext>; gridPreDestroyed: GridPreDestroyedEvent<TData, TContext>; gridSizeChanged: GridSizeChangedEvent<TData, TContext>; viewportChanged: ViewportChangedEvent<TData, TContext>; firstDataRendered: FirstDataRenderedEvent<TData, TContext>; dragStarted: DragStartedEvent<TData, TContext>; dragStopped: DragStoppedEvent<TData, TContext>; rowEditingStarted: RowEditingStartedEvent<TData, TContext>; rowEditingStopped: RowEditingStoppedEvent<TData, TContext>; cellEditingStarted: CellEditingStartedEvent<TData, TContext>; cellEditingStopped: CellEditingStoppedEvent<TData, TContext>; bodyScroll: BodyScrollEvent<TData, TContext>; bodyScrollEnd: BodyScrollEndEvent<TData, TContext>; paginationChanged: PaginationChangedEvent<TData, TContext>; componentStateChanged: ComponentStateChangedEvent<TData, TContext>; storeRefreshed: StoreRefreshedEvent<TData, TContext>; stateUpdated: StateUpdatedEvent<TData, TContext>; columnMenuVisibleChanged: ColumnMenuVisibleChangedEvent<TData, TContext>; contextMenuVisibleChanged: ContextMenuVisibleChangedEvent<TData, TContext>; rowDragEnter: RowDragEnterEvent<TData, TContext>; rowDragMove: RowDragMoveEvent<TData, TContext>; rowDragLeave: RowDragLeaveEvent<TData, TContext>; rowDragEnd: RowDragEndEvent<TData, TContext>; scrollbarWidthChanged: ScrollbarWidthChangedEvent<TData, TContext>; keyShortcutChangedCellStart: KeyShortcutChangedCellStartEvent<TData, TContext>; keyShortcutChangedCellEnd: KeyShortcutChangedCellEndEvent<TData, TContext>; pinnedHeightChanged: PinnedHeightChangedEvent<TData, TContext>; cellFocusCleared: CellFocusClearedEvent<TData, TContext>; fullWidthRowFocused: FullWidthRowFocusedEvent<TData, TContext>; checkboxChanged: CheckboxChangedEvent<TData, TContext>; heightScaleChanged: HeightScaleChangedEvent<TData, TContext>; suppressMovableColumns: SuppressMovableColumnsEvent<TData, TContext>; suppressMenuHide: SuppressMenuHideEvent<TData, TContext>; suppressFieldDotNotation: SuppressFieldDotNotationEvent<TData, TContext>; columnPanelItemDragStart: ColumnPanelItemDragStartEvent<TData, TContext>; columnPanelItemDragEnd: ColumnPanelItemDragEndEvent<TData, TContext>; bodyHeightChanged: BodyHeightChangedEvent<TData, TContext>; columnContainerWidthChanged: ColumnContainerWidthChangedEvent<TData, TContext>; displayedColumnsWidthChanged: DisplayedColumnsWidthChangedEvent<TData, TContext>; scrollVisibilityChanged: ScrollVisibilityChangedEvent<TData, TContext>; columnHoverChanged: ColumnHoverChangedEvent<TData, TContext>; flashCells: FlashCellsEvent<TData, TContext>; paginationPixelOffsetChanged: PaginationPixelOffsetChangedEvent<TData, TContext>; displayedRowsChanged: DisplayedRowsChangedEvent<TData, TContext>; leftPinnedWidthChanged: LeftPinnedWidthChangedEvent<TData, TContext>; rightPinnedWidthChanged: RightPinnedWidthChangedEvent<TData, TContext>; rowContainerHeightChanged: RowContainerHeightChangedEvent<TData, TContext>; headerHeightChanged: HeaderHeightChangedEvent<TData, TContext>; columnHeaderHeightChanged: ColumnHeaderHeightChangedEvent<TData, TContext>; gridStylesChanged: GridStylesChangedEvent<TData, TContext>; storeUpdated: StoreUpdatedEvent<TData, TContext>; filterDestroyed: FilterDestroyedEvent<TData, TContext>; rowDataUpdateStarted: RowDataUpdateStartedEvent<TData, TContext>; rowCountReady: RowCountReadyEvent<TData, TContext>; advancedFilterEnabledChanged: AdvancedFilterEnabledChangedEvent<TData, TContext>; dataTypesInferred: DataTypesInferredEvent<TData, TContext>; fieldValueChanged: FieldValueChangedEvent<TData, TContext>; fieldPickerValueSelected: FieldPickerValueSelectedEvent<TData, TContext>; richSelectListRowSelected: RichSelectListRowSelectedEvent<TData, TContext>; sideBarUpdated: SideBarUpdatedEvent<TData, TContext>; alignedGridScroll: AlignedGridScrollEvent<TData, TContext>; alignedGridColumn: AlignedGridColumnEvent<TData, TContext>; gridOptionsChanged: GridOptionsChangedEvent<TData, TContext>; chartTitleEdit: ChartTitleEditEvent<TData, TContext>; recalculateRowBounds: RecalculateRowBoundsEvent<TData, TContext>; stickyTopOffsetChanged: StickyTopOffsetChangedEvent<TData, TContext>; }>"
  },
  "AgEvent": {
    "meta": {
      "typeParams": [
        "TEventType extends string = string"
      ]
    },
    "type": {
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "AgGridEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TEventType extends string = string"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AgGlobalEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AgEventListener": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TEventType extends AgEventType = AgEventType"
      ]
    },
    "type": "(params: AgEventTypeParams<TData, TContext>[TEventType]) => void"
  },
  "AgGlobalEventListener": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TContext = any",
        "T extends AgEventType = AgEventType"
      ]
    },
    "type": "(eventType: T, event: AgEventTypeParams<TData, TContext>[T]) => void"
  },
  "ModelUpdatedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "animate": "boolean | undefined",
      "keepRenderedRows": "boolean | undefined",
      "newData": "boolean | undefined",
      "newPage": "boolean",
      "newPageSize?": "boolean",
      "keepUndoRedoStack?": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'modelUpdated'"
    },
    "docs": {
      "animate": "/** If true, the grid will try and animate the rows to the new positions */",
      "keepRenderedRows": "/** If true, the grid has new data loaded, eg user called setRowData(), otherwise\n     * it's the same data but sorted or filtered, in which case this is true, and rows\n     * can animate around (eg rowNode id 24 is the same row node as last time). */",
      "newData": "/** If true, then this update was a result of setRowData() getting called. This\n     * gets the grid to scroll to the top again. */",
      "newPage": "/** True when pagination and a new page is navigated to. */",
      "newPageSize?": "/** True when page size changes from the page size selector. */",
      "keepUndoRedoStack?": "/** true if all we did is changed row height, data still the same, no need to clear the undo/redo stacks */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PaginationChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "animate?": "boolean",
      "keepRenderedRows?": "boolean",
      "newData?": "boolean",
      "newPage": "boolean",
      "newPageSize?": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'paginationChanged'"
    },
    "docs": {
      "animate?": "/** True if rows were animated to new position */",
      "keepRenderedRows?": "/** True if rows were kept (otherwise complete redraw) */",
      "newData?": "/** True if data was new (i.e user set new data) */",
      "newPage": "/** True if user went to a new page */",
      "newPageSize?": "/** True if user changed the page size */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ToolPanelSizeChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "started": "boolean",
      "ended": "boolean",
      "width": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'toolPanelSizeChanged'"
    },
    "docs": {
      "started": "/** True if this is the first change to the Tool Panel size. */",
      "ended": "/** True if this is the last change to the Tool Panel size. */",
      "width": "/** New width of the ToolPanel component. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPivotModeChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnPivotModeChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "VirtualColumnsChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "afterScroll": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'virtualColumnsChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnEverythingChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnEverythingChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "NewColumnsLoadedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'newColumnsLoaded'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "GridColumnsChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridColumnsChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "DisplayedColumnsChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'displayedColumnsChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDataUpdatedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rowDataUpdated'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDataUpdateStartedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "firstRowData": "TData | null",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rowDataUpdateStarted'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PinnedRowDataChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'pinnedRowDataChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PinnedHeightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'pinnedHeightChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "SelectionEventSourceType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'api' | 'apiSelectAll' | 'apiSelectAllFiltered' | 'apiSelectAllCurrentPage' | 'checkboxSelected' | 'rowClicked' | 'rowDataChanged' | 'rowGroupChanged' | 'selectableChanged' | 'spaceKey' | 'uiSelectAll' | 'uiSelectAllFiltered' | 'uiSelectAllCurrentPage' | 'gridInitializing'"
  },
  "SelectionChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "SelectionEventSourceType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'selectionChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FilterChangedEventSourceType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'api' | 'quickFilter' | 'columnFilter' | 'advancedFilter'"
  },
  "FilterChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source?": "FilterChangedEventSourceType",
      "afterDataChange?": "boolean",
      "afterFloatingFilter?": "boolean",
      "columns": "Column[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'filterChanged'"
    },
    "docs": {
      "source?": "/** The source that triggered the filter change event. Can be one of the following:\n     * - `api` - triggered by an API call\n     * - `quickFilter` - triggered by user filtering from Quick Filter\n     * - `columnFilter` - triggered by user filtering from Column Menu\n     * - `advancedFilter` - triggered by user filtering from Advanced Filter\n     */",
      "afterDataChange?": "/** True if the filter was changed as a result of data changing */",
      "afterFloatingFilter?": "/** True if filter was changed via floating filter */",
      "columns": "/** Columns affected by the filter change. Array contents depend on the source of the event.\n     *\n     * - Expect 1 element for UI-driven column filter changes.\n     * - Expect 0-N elements (all affected columns) for calls to `api.setFilterModel()`.\n     * - Expect 0-N elements (removed columns) for calls to `api.setColumnDefs()`.\n     * - Expect 0 elements for quick-filters and calls to `api.onFilterChanged()`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FilterModifiedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "filterInstance": "IFilterComp",
      "column": "Column",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'filterModified'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FilterOpenedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "source": "FilterRequestSource",
      "eGui": "HTMLElement",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'filterOpened'"
    },
    "docs": {
      "column": "/** Column / ProvidedColumnGroup that contains the filter */",
      "source": "/** Source of the open request */",
      "eGui": "/** Parent element of the filter */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FilterDestroyedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'columnChanged' | 'gridDestroyed' | 'advancedFilterEnabled' | 'paramsUpdated'",
      "column": "Column",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'filterDestroyed'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "SortChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "string",
      "columns?": "Column[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'sortChanged'"
    },
    "docs": {
      "source": "/** Source of the sort change. */",
      "columns?": "/** The list of columns impacted by the sort change.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "GridReadyEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridReady'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "GridPreDestroyedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "state": "GridState",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridPreDestroyed'"
    },
    "docs": {
      "state": "/** Current state of the grid */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnContainerWidthChanged": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnContainerWidthChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "DisplayedColumnsWidthChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'displayedColumnsWidthChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnHoverChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnHoverChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "BodyHeightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'bodyHeightChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ComponentStateChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'componentStateChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPanelItemDragStartEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnPanelItemDragStart'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPanelItemDragEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnPanelItemDragEnd'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AgDragEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "target": "Element",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "target": "/** The DOM element that started the event. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "DragStartedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "type": "'dragStarted'",
      "target": "Element",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "target": "/** The DOM element that started the event. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "DragStoppedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "type": "'dragStopped'",
      "target": "Element",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "target": "/** The DOM element that started the event. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CheckboxChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "id": "string",
      "name": "string",
      "selected?": "boolean",
      "previousValue": "boolean | undefined",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'checkboxChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "GridSizeChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "clientWidth": "number",
      "clientHeight": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridSizeChanged'"
    },
    "docs": {
      "clientWidth": "/** The grid's DIV's clientWidth */",
      "clientHeight": "/** The grid's DIV's clientHeight */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PivotMaxColumnsExceededEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "message": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'pivotMaxColumnsExceeded'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDragEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "T extends AgEventType = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "nodes": "IRowNode<TData>[]",
      "event": "MouseEvent",
      "eventPath?": "EventTarget[]",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "IRowNode<TData>",
      "y": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "eventPath?": "/** The `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n     * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n     * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n     * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?'\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDragEnterEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "nodes": "IRowNode<TData>[]",
      "event": "MouseEvent",
      "eventPath?": "EventTarget[]",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "IRowNode<TData>",
      "y": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "eventPath?": "/** The `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n     * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n     * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n     * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?'\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDragEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "nodes": "IRowNode<TData>[]",
      "event": "MouseEvent",
      "eventPath?": "EventTarget[]",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "IRowNode<TData>",
      "y": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "eventPath?": "/** The `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n     * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n     * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n     * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?'\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDragMoveEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "nodes": "IRowNode<TData>[]",
      "event": "MouseEvent",
      "eventPath?": "EventTarget[]",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "IRowNode<TData>",
      "y": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "eventPath?": "/** The `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n     * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n     * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n     * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?'\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDragLeaveEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "nodes": "IRowNode<TData>[]",
      "event": "MouseEvent",
      "eventPath?": "EventTarget[]",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "IRowNode<TData>",
      "y": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "eventPath?": "/** The `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n     * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n     * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n     * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?'\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CutStartEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'ui' | 'contextMenu'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'cutStart'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CutEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'ui' | 'contextMenu'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'cutEnd'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PasteStartEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'pasteStart'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PasteEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'pasteEnd'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FillStartEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'fillStart'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FillEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "initialRange": "CellRange",
      "finalRange": "CellRange",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'fillEnd'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RangeDeleteStartEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'deleteKey'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rangeDeleteStart'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RangeDeleteEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'deleteKey'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rangeDeleteEnd'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "UndoStartedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'ui'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'undoStarted'"
    },
    "docs": {
      "source": "/** Source of the event. `api` if via API method. `ui` if via keyboard shortcut. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "UndoEndedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'ui'",
      "operationPerformed": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'undoEnded'"
    },
    "docs": {
      "source": "/** Source of the event. `api` if via API method. `ui` if via keyboard shortcut. */",
      "operationPerformed": "/** `true` if any undo operations were performed. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RedoStartedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'ui'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'redoStarted'"
    },
    "docs": {
      "source": "/** Source of the event. `api` if via API method. `ui` if via keyboard shortcut. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RedoEndedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "'api' | 'ui'",
      "operationPerformed": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'redoEnded'"
    },
    "docs": {
      "source": "/** Source of the event. `api` if via API method. `ui` if via keyboard shortcut. */",
      "operationPerformed": "/** `true` if any redo operations were performed. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ViewportChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "firstRow": "number",
      "lastRow": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'viewportChanged'"
    },
    "docs": {
      "firstRow": "/** Index of the first rendered row */",
      "lastRow": "/** Index of the last rendered row */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FirstDataRenderedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "firstRow": "number",
      "lastRow": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'firstDataRendered'"
    },
    "docs": {
      "firstRow": "/** Index of the first rendered row */",
      "lastRow": "/** Index of the last rendered row */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RangeSelectionChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "id?": "string",
      "started": "boolean",
      "finished": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rangeSelectionChanged'"
    },
    "docs": {
      "started": "/** True for the first change event, otherwise false */",
      "finished": "/** True for the last change event, otherwise false */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartCreatedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "chartId": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartCreated'"
    },
    "docs": {
      "chartId": "/** Id of the created chart. This can later be used to reference the chart via api methods. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartCreated": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v32 Use ChartCreatedEvent instead */"
    },
    "type": {
      "chartId": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartCreated'"
    },
    "docs": {
      "chartId": "/** Id of the created chart. This can later be used to reference the chart via api methods. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartRangeSelectionChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "chartId": "string",
      "id": "string",
      "cellRange": "CellRangeParams",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartRangeSelectionChanged'"
    },
    "docs": {
      "chartId": "/** Id of the effected chart. */",
      "id": "/** Same as `chartId`. */",
      "cellRange": "/** New cellRange selected. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartRangeSelectionChanged": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v32 Use ChartRangeSelectionChangedEvent instead */"
    },
    "type": {
      "chartId": "string",
      "id": "string",
      "cellRange": "CellRangeParams",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartRangeSelectionChanged'"
    },
    "docs": {
      "chartId": "/** Id of the effected chart. */",
      "id": "/** Same as `chartId`. */",
      "cellRange": "/** New cellRange selected. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartOptionsChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "chartId": "string",
      "chartType": "ChartType",
      "chartThemeName": "string",
      "chartOptions": "AgChartThemeOverrides",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartOptionsChanged'"
    },
    "docs": {
      "chartId": "/** Id of the effected chart. */",
      "chartType": "/** ChartType */",
      "chartThemeName": "/** Chart theme name of currently selected theme. */",
      "chartOptions": "/** Chart options.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartOptionsChanged": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v32 Use ChartOptionsChangedEvent instead */"
    },
    "type": {
      "chartId": "string",
      "chartType": "ChartType",
      "chartThemeName": "string",
      "chartOptions": "AgChartThemeOverrides",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartOptionsChanged'"
    },
    "docs": {
      "chartId": "/** Id of the effected chart. */",
      "chartType": "/** ChartType */",
      "chartThemeName": "/** Chart theme name of currently selected theme. */",
      "chartOptions": "/** Chart options.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartDestroyedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "chartId": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartDestroyed'"
    },
    "docs": {
      "chartId": "/** Id of the effected chart. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartDestroyed": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v32 Use ChartDestroyedEvent instead */"
    },
    "type": {
      "chartId": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartDestroyed'"
    },
    "docs": {
      "chartId": "/** Id of the effected chart. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnGroupOpenedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "columnGroup?": "ProvidedColumnGroup",
      "columnGroups": "ProvidedColumnGroup[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnGroupOpened'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ScrollDirection": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Vertical",
      "Horizontal"
    ],
    "docs": [
      null,
      null
    ]
  },
  "BaseBodyScrollEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "direction": "ScrollDirection",
      "left": "number",
      "top": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "BodyScrollEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "direction": "ScrollDirection",
      "left": "number",
      "top": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "BodyScrollEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "direction": "ScrollDirection",
      "left": "number",
      "top": "number",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "TooltipEvent": {
    "meta": {
      "typeParams": [
        "T extends 'tooltipShow' | 'tooltipHide'",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "parentGui": "HTMLElement",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "TooltipShowEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "tooltipGui": "HTMLElement",
      "parentGui": "HTMLElement",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "TooltipHideEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "parentGui": "HTMLElement",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "PaginationPixelOffsetChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'paginationPixelOffsetChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "StickyTopOffsetChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'stickyTopOffsetChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CommonCellFocusParams": {
    "meta": {},
    "type": {
      "rowIndex": "number | null",
      "column": "Column | string | null",
      "rowPinned": "RowPinnedType",
      "isFullWidthCell?": "boolean"
    },
    "docs": {
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell?": "/** Whether the cell a full width cell or a regular cell */"
    }
  },
  "CellFocusClearedParams": {
    "meta": {},
    "type": {
      "rowIndex": "number | null",
      "column": "Column | string | null",
      "rowPinned": "RowPinnedType",
      "isFullWidthCell?": "boolean"
    },
    "docs": {
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell?": "/** Whether the cell a full width cell or a regular cell */"
    }
  },
  "CellFocusedParams": {
    "meta": {},
    "type": {
      "forceBrowserFocus?": "boolean",
      "preventScrollOnBrowserFocus?": "boolean",
      "rowIndex": "number | null",
      "column": "Column | string | null",
      "rowPinned": "RowPinnedType",
      "isFullWidthCell?": "boolean"
    },
    "docs": {
      "forceBrowserFocus?": "/** Whether browser focus is also set (false when editing) */",
      "preventScrollOnBrowserFocus?": "/** When `forceBrowserFocus` is `true`, should scroll be prevented */",
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell?": "/** Whether the cell a full width cell or a regular cell */"
    }
  },
  "HeaderFocusedParams": {
    "meta": {},
    "type": {
      "column": "Column | ColumnGroup"
    }
  },
  "HeaderFocusedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'headerFocused'",
      "column": "Column | ColumnGroup"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellFocusClearedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'cellFocusCleared'",
      "rowIndex": "number | null",
      "column": "Column | string | null",
      "rowPinned": "RowPinnedType",
      "isFullWidthCell?": "boolean"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */",
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell?": "/** Whether the cell a full width cell or a regular cell */"
    }
  },
  "CellFocusedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'cellFocused'",
      "forceBrowserFocus?": "boolean",
      "preventScrollOnBrowserFocus?": "boolean",
      "rowIndex": "number | null",
      "column": "Column | string | null",
      "rowPinned": "RowPinnedType",
      "isFullWidthCell?": "boolean"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */",
      "forceBrowserFocus?": "/** Whether browser focus is also set (false when editing) */",
      "preventScrollOnBrowserFocus?": "/** When `forceBrowserFocus` is `true`, should scroll be prevented */",
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell?": "/** Whether the cell a full width cell or a regular cell */"
    }
  },
  "FullWidthRowFocusedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "fromBelow": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'fullWidthRowFocused'",
      "forceBrowserFocus?": "boolean",
      "preventScrollOnBrowserFocus?": "boolean",
      "rowIndex": "number | null",
      "column": "Column | string | null",
      "rowPinned": "RowPinnedType",
      "isFullWidthCell?": "boolean"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */",
      "forceBrowserFocus?": "/** Whether browser focus is also set (false when editing) */",
      "preventScrollOnBrowserFocus?": "/** When `forceBrowserFocus` is `true`, should scroll be prevented */",
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell?": "/** Whether the cell a full width cell or a regular cell */"
    }
  },
  "ExpandCollapseAllEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v32 Please use `ExpandOrCollapseAllEvent` instead.\n */"
    },
    "type": {
      "source": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'expandOrCollapseAll'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ExpandOrCollapseAllEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "source": "string",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'expandOrCollapseAll'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnEventType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'sizeColumnsToFit' | 'autosizeColumns' | 'autosizeColumnHeaderHeight' | 'alignedGridChanged' | 'filterChanged' | 'filterDestroyed' | 'gridOptionsChanged' | 'gridInitializing' | 'toolPanelDragAndDrop' | 'toolPanelUi' | 'uiColumnMoved' | 'uiColumnResized' | 'uiColumnDragged' | 'uiColumnExpanded' | 'uiColumnSorted' | 'contextMenu' | 'columnMenu' | 'rowModelUpdated' | 'rowDataUpdated' | 'api' | 'flex' | 'pivotChart' | 'columnRowGroupChanged' | 'cellDataTypeInferred' | 'viewportSizeFeature'"
  },
  "ColumnEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType | ColumnEventName = any",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnResizedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "finished": "boolean",
      "flexColumns": "Column[] | null",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "finished": "/** Set to true for last event in a sequence of move events */",
      "flexColumns": "/** Any columns resized due to flex */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPivotChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnRowGroupChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnValueChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnMovedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "toIndex?": "number",
      "finished": "boolean",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "toIndex?": "/** The position the column was moved to */",
      "finished": "/** `True` when the column has finished moving. */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnVisibleEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "visible?": "boolean",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "visible?": "/** True if column was set to visible, false if set to hide, undefined if in a single call some columns were shown while others hidden */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPinnedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "pinned": "ColumnPinnedType",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "TEventType"
    },
    "docs": {
      "pinned": "/** Either 'left', 'right', or null (it not pinned) */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnHeaderMouseOverEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnHeaderMouseOver'"
    },
    "docs": {
      "column": "/** Column or column-group related to the header that triggered the event */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnHeaderMouseLeaveEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnHeaderMouseLeave'"
    },
    "docs": {
      "column": "/** Column or column-group related to the header that triggered the event */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnHeaderClickedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnHeaderClicked'"
    },
    "docs": {
      "column": "/** Column or column-group related to the header that triggered the event */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnHeaderContextMenuEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnHeaderContextMenu'"
    },
    "docs": {
      "column": "/** Column or column-group related to the header that triggered the event */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ContextMenuVisibleChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/**-------------------*/\n/** VISIBILITY EVENTS */\n/**-------------------*/"
    },
    "type": {
      "visible": "boolean",
      "source": "'api' | 'ui'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'contextMenuVisibleChanged'"
    },
    "docs": {
      "visible": "/** True if now visible; false if now hidden. */",
      "source": "/** Source of the visibility status change. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AdvancedFilterBuilderVisibleChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "visible": "boolean",
      "source": "'api' | 'ui'",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'advancedFilterBuilderVisibleChanged'"
    },
    "docs": {
      "visible": "/** True if now visible; false if now hidden. */",
      "source": "/** Source of the visibility status change. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ToolPanelVisibleChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "visible": "boolean",
      "source": "'sideBarButtonClicked' | 'sideBarInitializing' | 'api'",
      "key": "string",
      "switchingToolPanel": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'toolPanelVisibleChanged'"
    },
    "docs": {
      "visible": "/** True if now visible; false if now hidden. */",
      "key": "/** Key of tool panel. */",
      "switchingToolPanel": "/** True if switching between tool panels. False if showing/hiding. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnMenuVisibleChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "visible": "boolean",
      "switchingTab": "boolean",
      "key": "'generalMenuTab' | 'filterMenuTab' | 'columnsMenuTab' | 'columnMenu' | 'columnFilter' | 'floatingFilter' | 'columnChooser'",
      "column": "Column | null",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnMenuVisibleChanged'"
    },
    "docs": {
      "visible": "/** True if now visible; false if now hidden. */",
      "switchingTab": "/** True if switching between tabs. False if showing/hiding. Only applies to legacy tabbed menu. */",
      "key": "/** Currently displayed menu/tab.\n     * If filter launched from floating filter, will be `'floatingFilter'`.\n     * If using `columnMenu = 'new'` (default behaviour), will be `'columnMenu'` for the column menu,\n     * `'columnFilter'` for the column filter, and `'columnChooser'` for the column chooser.\n     * If using AG Grid Enterprise and `columnMenu = 'legacy'`,\n     * will be the tab `'generalMenuTab'`, `'filterMenuTab'` or `'columnsMenuTab'`.\n     * If using AG Grid Community and `columnMenu = 'legacy'`, will be `'columnMenu'`.\n     */",
      "column": "/** Column the menu is opened for. Will be `null` if not launched from a column\n     * (e.g. column chooser from the API, or column menu via right-click on an empty header).\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "BaseRowEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData",
        "TContext"
      ],
      "doc": "/**------------*/\n/** ROW EVENTS */\n/**------------*/"
    },
    "type": {
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowWithDataEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Base interface for row events that always have data set. */"
    },
    "type": {
      "data": "TData",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowGroupOpenedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "expanded": "boolean",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "expanded": "/** True if the group is expanded. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowValueChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowSelectedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "VirtualRowRemovedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowClickedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowDoubleClickedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowEditingStartedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowEditingStoppedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FullWidthCellKeyDownEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TValue = any"
      ],
      "doc": "/**------------*/\n/** CELL EVENTS */\n/**------------*/"
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellWithDataEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType",
        "TData = any",
        "TValue = any"
      ],
      "doc": "/** Use for cell events that will always have a data property. */"
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellKeyDownEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellClickedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellMouseDownEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellDoubleClickedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellMouseOverEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellMouseOutEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellContextMenuEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellEditingStartedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellEditingStoppedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "oldValue": "TValue | null | undefined",
      "newValue": "TValue | null | undefined",
      "valueChanged": "boolean",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "oldValue": "/** The old value before editing */",
      "newValue": "/** The new value after editing */",
      "valueChanged": "/** Property indicating if the value of the editor has changed */",
      "value": "/** The value for the cell if available otherwise undefined. */",
      "data": "/** The user provided data for the row. Data is `undefined` for row groups. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellValueChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "oldValue": "TValue | null | undefined",
      "newValue": "TValue | null | undefined",
      "source": "string | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CellEditRequestEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "oldValue": "TValue | null | undefined",
      "newValue": "TValue | null | undefined",
      "source": "string | undefined",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "value": "TValue | null | undefined",
      "data": "TData",
      "node": "IRowNode<TData>",
      "rowIndex": "number | null",
      "rowPinned": "RowPinnedType",
      "event?": "Event | null",
      "eventPath?": "EventTarget[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "eventPath?": "/** If the browser `event` is present the `eventPath` persists the `event.composedPath()` result for access within AG Grid event handlers.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AsyncTransactionsFlushedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "results": "(RowNodeTransaction<TData> | ServerSideTransactionResult)[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'asyncTransactionsFlushed'"
    },
    "docs": {
      "results": "/** Array of result objects. for SSRM it's always list of `ServerSideTransactionResult`.\n     * For Client-Side Row Model it's a list of `RowNodeTransaction`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AsyncTransactionsFlushed": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v32 Use AsyncTransactionsFlushedEvent */"
    },
    "type": {
      "results": "(RowNodeTransaction<TData> | ServerSideTransactionResult)[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'asyncTransactionsFlushed'"
    },
    "docs": {
      "results": "/** Array of result objects. for SSRM it's always list of `ServerSideTransactionResult`.\n     * For Client-Side Row Model it's a list of `RowNodeTransaction`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "StoreRefreshedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "route?": "string[]",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'storeRefreshed'"
    },
    "docs": {
      "route?": "/** The route of the store which has finished refreshing, undefined if root level */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "StateUpdatedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "sources": "(keyof GridState | 'gridInitializing')[]",
      "state": "GridState",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'stateUpdated'"
    },
    "docs": {
      "sources": "/** Which parts of the state triggered the update, or `gridInitializing` when the state has been created during grid initialization */",
      "state": "/** The updated state */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ScrollVisibilityChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'scrollVisibilityChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "StoreUpdatedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'storeUpdated'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "LeftPinnedWidthChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'leftPinnedWidthChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RightPinnedWidthChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rightPinnedWidthChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowContainerHeightChanged": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rowContainerHeightChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FlashCellsEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/**-----------------*/\n/** Internal EVENTS */\n/**-----------------*/"
    },
    "type": {
      "cells": "any",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'flashCells'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "DisplayedRowsChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "afterScroll": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'displayedRowsChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "CssVariablesChanged": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "themeChanged?": "boolean",
      "headerHeightChanged?": "boolean",
      "rowHeightChanged?": "boolean",
      "listItemHeightChanged?": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridStylesChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AdvancedFilterEnabledChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "enabled": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'advancedFilterEnabledChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "DataTypesInferredEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'dataTypesInferred'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FieldValueEvent": {
    "meta": {
      "typeParams": [
        "T extends AgEventType = 'fieldValueChanged'",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "any",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "T"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FieldPickerValueSelectedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'fieldPickerValueSelected'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RichSelectListRowSelectedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'richSelectListRowSelected'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AlignedGridColumnEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "event": "ColumnEvent<any>",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'alignedGridColumn'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AlignedGridScrollEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "event": "BodyScrollEvent",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'alignedGridScroll'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "GridOptionsChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "options": "GridOptions",
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridOptionsChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ScrollbarWidthChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'scrollbarWidthChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "KeyShortcutChangedCellStartEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'keyShortcutChangedCellStart'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "KeyShortcutChangedCellEndEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'keyShortcutChangedCellEnd'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "HeightScaleChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'heightScaleChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "SuppressMovableColumnsEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'suppressMovableColumns'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "SuppressMenuHideEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'suppressMenuHide'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "SuppressFieldDotNotationEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'suppressFieldDotNotation'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnContainerWidthChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnContainerWidthChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowContainerHeightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rowContainerHeightChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "HeaderHeightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'headerHeightChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnHeaderHeightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'columnHeaderHeightChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "GridStylesChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'gridStylesChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RowCountReadyEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'rowCountReady'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "FieldValueChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'fieldValueChanged'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "SideBarUpdatedEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'sideBarUpdated'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "ChartTitleEditEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'chartTitleEdit'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "RecalculateRowBoundsEvent": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext",
      "type": "'recalculateRowBounds'"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "type": "/** Event identifier */"
    }
  },
  "AgPublicEventType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(typeof PUBLIC_EVENTS)[number]"
  },
  "AgInternalEventType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(typeof INTERNAL_EVENTS)[number]"
  },
  "AgEventType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "AgPublicEventType | AgInternalEventType"
  },
  "FilterWrapper": {
    "meta": {},
    "type": {
      "compiledElement": "any",
      "column": "AgColumn",
      "filterPromise": "AgPromise<IFilterComp> | null",
      "filter?": "IFilterComp",
      "compDetails": "UserCompDetails | null"
    }
  },
  "IFloatingFilterParent": {
    "meta": {},
    "type": {
      "onFloatingFilterChanged(type: string | null, value: any)": "void"
    },
    "docs": {
      "onFloatingFilterChanged(type: string | null, value: any)": "/** Notification that a new floating-filter value was input by the user.\n     *\n     * @param type operation type selected.\n     * @param value model-typed value entered.\n     */"
    }
  },
  "InbuiltParentType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "IFloatingFilterParent & IFilter"
  },
  "IFloatingFilterParentCallback": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "P = InbuiltParentType"
      ]
    },
    "type": "(parentFilterInstance: P) => void"
  },
  "IFloatingFilterParams": {
    "meta": {
      "typeParams": [
        "P = InbuiltParentType",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column",
      "filterParams": "IFilterParams",
      "suppressFilterButton": "boolean",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: IFloatingFilterParentCallback<P>) => void",
      "showParentFilter": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** The column this filter is for. */",
      "filterParams": "/** The params object passed to the filter.\n     * This is to allow the floating filter access to the configuration of the parent filter.\n     * For example, the provided filters use debounceMs from the parent filter params.\n     * */",
      "suppressFilterButton": "/** @deprecated v31.1 Use `colDef.suppressFloatingFilterButton` instead. */",
      "currentParentModel": "/** This is a shortcut to invoke getModel on the parent filter.\n     * If the parent filter doesn't exist (filters are lazily created as needed)\n     * then it returns null rather than calling getModel() on the parent filter.\n     */",
      "parentFilterInstance": "/** Gets a reference to the parent filter. The result is returned asynchronously\n     * via a callback as the parent filter may not exist yet. If it does\n     * not exist, it is created and asynchronously returned (AG Grid itself\n     * does not create components asynchronously, however if providing a framework\n     * provided filter e.g. React, it might be).\n     *\n     * The floating filter can then call any method it likes on the parent filter.\n     * The parent filter will typically provide its own method for the floating\n     * filter to call to set the filter. For example, if creating custom filter A,\n     * it should have a method your floating A can call to set the state\n     * when the user updates via the floating filter.\n     */",
      "showParentFilter": "/** Shows the parent filter popup.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "BaseFloatingFilter": {
    "meta": {},
    "type": {
      "afterGuiAttached?()": "void"
    },
    "docs": {
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */"
    }
  },
  "IFloatingFilter": {
    "meta": {
      "typeParams": [
        "P = any"
      ]
    },
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "void",
      "refresh?(params: IFloatingFilterParams<P>)": "void",
      "afterGuiAttached?()": "void"
    },
    "docs": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "/** Gets called every time the parent filter changes.\n     * Your floating filter would typically refresh its UI to reflect the new filter state.\n     * The provided parentModel is what the parent filter returns from its getModel() method.\n     * The event is the FilterChangedEvent that the grid fires.\n     */",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "/** @deprecated v31.1 - Use `refresh` instead */",
      "refresh?(params: IFloatingFilterParams<P>)": "/** A hook to perform any necessary operations when the column definition is updated. */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */"
    }
  },
  "IFloatingFilterComp": {
    "meta": {
      "typeParams": [
        "P = any"
      ]
    },
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "void",
      "refresh?(params: IFloatingFilterParams<P>)": "void",
      "afterGuiAttached?()": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IFloatingFilterParams<P>)": "AgPromise<void> | void"
    },
    "docs": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "/** Gets called every time the parent filter changes.\n     * Your floating filter would typically refresh its UI to reflect the new filter state.\n     * The provided parentModel is what the parent filter returns from its getModel() method.\n     * The event is the FilterChangedEvent that the grid fires.\n     */",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "/** @deprecated v31.1 - Use `refresh` instead */",
      "refresh?(params: IFloatingFilterParams<P>)": "/** A hook to perform any necessary operations when the column definition is updated. */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IFloatingFilterParams<P>)": "/** The init(params) method is called on the component once. */"
    }
  },
  "BaseFloatingFilterChange": {
    "meta": {},
    "type": {
      "model": "ProvidedFilterModel",
      "apply": "boolean"
    }
  },
  "FloatingFilterInputService": {
    "meta": {},
    "type": {
      "setupGui(parentElement: HTMLElement)": "void",
      "setEditable(editable: boolean)": "void",
      "getValue()": "string | null | undefined",
      "setValue(value: string | null | undefined, silent?: boolean)": "void",
      "setValueChangedListener(listener: (e: KeyboardEvent) => void)": "void",
      "setParams(params: { ariaLabel: string; autoComplete?: boolean | string; })": "void",
      "beanName?": "BeanName",
      "wireBeans?(beans: BeanCollection)": "void",
      "postConstruct?()": "void",
      "destroy?()": "void"
    },
    "docs": {
      "beanName?": "/** AG Grid internal - do not use */",
      "wireBeans?(beans: BeanCollection)": "/** AG Grid internal - do not call */",
      "postConstruct?()": "/** AG Grid internal - do not call */",
      "destroy?()": "/** AG Grid internal - do not call */"
    }
  },
  "ModelUnion": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "TextFilterModel | NumberFilterModel"
  },
  "FilterRequestSource": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'COLUMN_MENU' | 'TOOLBAR' | 'NO_UI'"
  },
  "DateFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'date'",
      "dateFrom": "string | null",
      "dateTo": "string | null",
      "type?": "ISimpleFilterModelType | null"
    },
    "docs": {
      "filterType?": "/** Filter type is always `'date'` */",
      "dateFrom": "/** The date value(s) associated with the filter. The type is `string` and format is always\n     * `YYYY-MM-DD hh:mm:ss` e.g. 2019-05-24 00:00:00. Custom filters can have no values (hence both\n     * are optional). Range filter has two values (from and to).\n     */",
      "dateTo": "/** Range filter `to` date value.\n     */",
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "DateFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "IDateFilterParams & IFilterParams<TData>"
  },
  "IDateFilterParams": {
    "meta": {
      "doc": "/** Parameters used in `colDef.filterParams` to configure a Date Filter (`agDateColumnFilter`).\n */"
    },
    "type": {
      "comparator?": "IDateComparatorFunc",
      "browserDatePicker?": "boolean",
      "minValidYear?": "number",
      "maxValidYear?": "number",
      "minValidDate?": "Date | string",
      "maxValidDate?": "Date | string",
      "inRangeFloatingFilterDateFormat?": "string",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "filterOptions?": "(IFilterOptionDef | ISimpleFilterModelType)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "maxNumConditions?": "number",
      "numAlwaysVisibleConditions?": "number",
      "filterPlaceholder?": "FilterPlaceholderFunction | string",
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "comparator?": "/** Required if the data for the column are not native JS `Date` objects. */",
      "browserDatePicker?": "/** Defines whether the grid uses the browser date picker or a plain text box.\n     *  - `true`: Force the browser date picker to be used.\n     *  - `false`: Force a plain text box to be used.\n     *\n     * If a date component is not provided, then the grid will use the browser date picker\n     * for all supported browsers and a plain text box for other browsers.\n     */",
      "minValidYear?": "/** This is the minimum year that may be entered in a date field for the value to be considered valid.\n     * @default 1000\n     * */",
      "maxValidYear?": "/** This is the maximum year that may be entered in a date field for the value to be considered valid. Default is no restriction. */",
      "minValidDate?": "/** The minimum valid date that can be entered in the filter.\n     * It can be a Date object or a string in the format `YYYY-MM-DD`.\n     * If set, this will override `minValidYear` - the minimum valid year setting.\n     */",
      "maxValidDate?": "/** The maximum valid date that can be entered in the filter.\n     * It can be a Date object or a string in the format `YYYY-MM-DD`.\n     * If set, this will override `maxValidYear` - the maximum valid year setting.\n     */",
      "inRangeFloatingFilterDateFormat?": "/** Defines the date format for the floating filter text when an `inRange` filter has been applied.\n     *\n     * @default YYYY-MM-DD\n     */",
      "inRangeInclusive?": "/** If `true`, the `'inRange'` filter option will include values equal to the start and end of the range. */",
      "includeBlanksInEquals?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'equals'` filter option. */",
      "includeBlanksInLessThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'lessThan'` and `'lessThanOrEqual'` filter options. */",
      "includeBlanksInGreaterThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'greaterThan'` and `'greaterThanOrEqual'` filter options. */",
      "includeBlanksInRange?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'inRange'` filter option. */",
      "filterOptions?": "/** Array of filter options to present to the user.\n     */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n     * You can change this default by setting this property.\n     * Options: `AND`, `OR`\n     */",
      "maxNumConditions?": "/** Maximum number of conditions allowed in the filter.\n     *\n     * @default 2\n     */",
      "numAlwaysVisibleConditions?": "/** By default only one condition is shown, and additional conditions are made visible when the previous conditions are entered\n     * (up to `maxNumConditions`). To have more conditions shown by default, set this to the number required.\n     * Conditions will be disabled until the previous conditions have been entered.\n     * Note that this cannot be greater than `maxNumConditions` - anything larger will be ignored.\n     *\n     * @default 1\n     */",
      "filterPlaceholder?": "/** Placeholder text for the filter textbox\n     */",
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "IDateComparatorFunc": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "filterLocalDateAtMidnight": "Date",
        "cellValue": "any"
      },
      "returnType": "number"
    }
  },
  "ProvidedFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "IProvidedFilterParams & IFilterParams<TData>"
  },
  "IProvidedFilterParams": {
    "meta": {
      "doc": "/** Common parameters in `colDef.filterParams` used by all provided filters. Extended by the specific filter types.\n */"
    },
    "type": {
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "IProvidedFilter": {
    "meta": {
      "doc": "/** Interface contract for the public aspects of the ProvidedFilter implementation(s). */"
    },
    "type": {
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "boolean",
      "getModelFromUi()": "any",
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "/** Applies the model shown in the UI (so that `getModel()` will now return what was in the UI\n     * when `applyModel()` was called).\n     * @param source The source of the method call. Default 'api'.\n     */",
      "getModelFromUi()": "/** Returns the filter model from the UI. If changes have been made to the UI but not yet\n     * applied, this model will reflect those changes.\n     */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "ScalarFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "IScalarFilterParams & IFilterParams<TData>"
  },
  "IScalarFilterParams": {
    "meta": {
      "doc": "/** Common parameters in `colDef.filterParams` used by all scalar filters. Extended by the specific filter types.\n */"
    },
    "type": {
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "filterOptions?": "(IFilterOptionDef | ISimpleFilterModelType)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "maxNumConditions?": "number",
      "numAlwaysVisibleConditions?": "number",
      "filterPlaceholder?": "FilterPlaceholderFunction | string",
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "inRangeInclusive?": "/** If `true`, the `'inRange'` filter option will include values equal to the start and end of the range. */",
      "includeBlanksInEquals?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'equals'` filter option. */",
      "includeBlanksInLessThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'lessThan'` and `'lessThanOrEqual'` filter options. */",
      "includeBlanksInGreaterThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'greaterThan'` and `'greaterThanOrEqual'` filter options. */",
      "includeBlanksInRange?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'inRange'` filter option. */",
      "filterOptions?": "/** Array of filter options to present to the user.\n     */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n     * You can change this default by setting this property.\n     * Options: `AND`, `OR`\n     */",
      "maxNumConditions?": "/** Maximum number of conditions allowed in the filter.\n     *\n     * @default 2\n     */",
      "numAlwaysVisibleConditions?": "/** By default only one condition is shown, and additional conditions are made visible when the previous conditions are entered\n     * (up to `maxNumConditions`). To have more conditions shown by default, set this to the number required.\n     * Conditions will be disabled until the previous conditions have been entered.\n     * Note that this cannot be greater than `maxNumConditions` - anything larger will be ignored.\n     *\n     * @default 1\n     */",
      "filterPlaceholder?": "/** Placeholder text for the filter textbox\n     */",
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "Comparator": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "T"
      ]
    },
    "type": {
      "arguments": {
        "left": "T",
        "right": "T"
      },
      "returnType": "number"
    }
  },
  "JoinOperator": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'AND' | 'OR'"
  },
  "ISimpleFilter": {
    "meta": {
      "doc": "/** Interface contract for the public aspects of the SimpleFilter implementation(s). */"
    },
    "type": {
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "boolean",
      "getModelFromUi()": "any",
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void",
      "onFloatingFilterChanged(type: string | null, value: any)": "void"
    },
    "docs": {
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "/** Applies the model shown in the UI (so that `getModel()` will now return what was in the UI\n     * when `applyModel()` was called).\n     * @param source The source of the method call. Default 'api'.\n     */",
      "getModelFromUi()": "/** Returns the filter model from the UI. If changes have been made to the UI but not yet\n     * applied, this model will reflect those changes.\n     */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */",
      "onFloatingFilterChanged(type: string | null, value: any)": "/** Notification that a new floating-filter value was input by the user.\n     *\n     * @param type operation type selected.\n     * @param value model-typed value entered.\n     */"
    }
  },
  "IFilterPlaceholderFunctionParams": {
    "meta": {},
    "type": {
      "filterOptionKey": "ISimpleFilterModelType",
      "filterOption": "string",
      "placeholder": "string"
    },
    "docs": {
      "filterOptionKey": "/** The filter option key\n     */",
      "filterOption": "/** The filter option name as localised text\n     */",
      "placeholder": "/** The default placeholder text\n     */"
    }
  },
  "FilterPlaceholderFunction": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params: IFilterPlaceholderFunctionParams) => string"
  },
  "SimpleFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "ISimpleFilterParams & IFilterParams<TData>"
  },
  "ISimpleFilterParams": {
    "meta": {
      "doc": "/** Common parameters in `colDef.filterParams` used by all simple filters. Extended by the specific filter types.\n */"
    },
    "type": {
      "filterOptions?": "(IFilterOptionDef | ISimpleFilterModelType)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "maxNumConditions?": "number",
      "numAlwaysVisibleConditions?": "number",
      "filterPlaceholder?": "FilterPlaceholderFunction | string",
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "filterOptions?": "/** Array of filter options to present to the user.\n     */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n     * You can change this default by setting this property.\n     * Options: `AND`, `OR`\n     */",
      "maxNumConditions?": "/** Maximum number of conditions allowed in the filter.\n     *\n     * @default 2\n     */",
      "numAlwaysVisibleConditions?": "/** By default only one condition is shown, and additional conditions are made visible when the previous conditions are entered\n     * (up to `maxNumConditions`). To have more conditions shown by default, set this to the number required.\n     * Conditions will be disabled until the previous conditions have been entered.\n     * Note that this cannot be greater than `maxNumConditions` - anything larger will be ignored.\n     *\n     * @default 1\n     */",
      "filterPlaceholder?": "/** Placeholder text for the filter textbox\n     */",
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "ISimpleFilterModelType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'empty' | 'equals' | 'notEqual' | 'lessThan' | 'lessThanOrEqual' | 'greaterThan' | 'greaterThanOrEqual' | 'inRange' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'blank' | 'notBlank'"
  },
  "ISimpleFilterModel": {
    "meta": {},
    "type": {
      "type?": "ISimpleFilterModelType | null",
      "filterType?": "string"
    },
    "docs": {
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "ICombinedSimpleModel": {
    "meta": {
      "typeParams": [
        "M extends ISimpleFilterModel"
      ]
    },
    "type": {
      "operator": "JoinOperator",
      "conditions": "M[]",
      "filterType?": "string"
    }
  },
  "Tuple": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "(T | null)[]"
  },
  "NumberFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'number'",
      "filter?": "number | null",
      "filterTo?": "number | null",
      "type?": "ISimpleFilterModelType | null"
    },
    "docs": {
      "filterType?": "/** Filter type is always `'number'` */",
      "filter?": "/** The number value(s) associated with the filter.\n     * Custom filters can have no values (hence both are optional).\n     * Range filter has two values (from and to).\n     */",
      "filterTo?": "/** Range filter `to` value.\n     */",
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "NumberFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "INumberFilterParams & IFilterParams<TData>"
  },
  "INumberFilterParams": {
    "meta": {
      "doc": "/** Parameters used in `colDef.filterParams` to configure a Number Filter (`agNumberColumnFilter`).\n */"
    },
    "type": {
      "allowedCharPattern?": "string",
      "numberParser?": "(text: string | null) => number | null",
      "numberFormatter?": "(value: number | null) => string | null",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "filterOptions?": "(IFilterOptionDef | ISimpleFilterModelType)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "maxNumConditions?": "number",
      "numAlwaysVisibleConditions?": "number",
      "filterPlaceholder?": "FilterPlaceholderFunction | string",
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "allowedCharPattern?": "/** When specified, the input field will be of type `text`, and this will be used as a regex of all the characters that are allowed to be typed.\n     * This will be compared against any typed character and prevent the character from appearing in the input if it does not match.\n     */",
      "numberParser?": "/** Typically used alongside `allowedCharPattern`, this provides a custom parser to convert the value entered in the filter inputs into a number that can be used for comparisons.\n     */",
      "numberFormatter?": "/** Typically used alongside `allowedCharPattern`, this provides a custom formatter to convert the number value in the filter model\n     * into a string to be used in the filter input. This is the inverse of the `numberParser`.\n     */",
      "inRangeInclusive?": "/** If `true`, the `'inRange'` filter option will include values equal to the start and end of the range. */",
      "includeBlanksInEquals?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'equals'` filter option. */",
      "includeBlanksInLessThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'lessThan'` and `'lessThanOrEqual'` filter options. */",
      "includeBlanksInGreaterThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'greaterThan'` and `'greaterThanOrEqual'` filter options. */",
      "includeBlanksInRange?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'inRange'` filter option. */",
      "filterOptions?": "/** Array of filter options to present to the user.\n     */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n     * You can change this default by setting this property.\n     * Options: `AND`, `OR`\n     */",
      "maxNumConditions?": "/** Maximum number of conditions allowed in the filter.\n     *\n     * @default 2\n     */",
      "numAlwaysVisibleConditions?": "/** By default only one condition is shown, and additional conditions are made visible when the previous conditions are entered\n     * (up to `maxNumConditions`). To have more conditions shown by default, set this to the number required.\n     * Conditions will be disabled until the previous conditions have been entered.\n     * Note that this cannot be greater than `maxNumConditions` - anything larger will be ignored.\n     *\n     * @default 1\n     */",
      "filterPlaceholder?": "/** Placeholder text for the filter textbox\n     */",
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "INumberFloatingFilterParams": {
    "meta": {},
    "type": {
      "browserAutoComplete?": "boolean | string",
      "column": "Column",
      "filterParams": "IFilterParams",
      "suppressFilterButton": "boolean",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: IFloatingFilterParentCallback<P>) => void",
      "showParentFilter": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "browserAutoComplete?": "/** Overrides the browser's autocomplete/autofill behaviour by updating the autocomplete attribute on the input field used in the floating filter input.\n     * Possible values are:\n     * - `true` to allow the **default** browser autocomplete/autofill behaviour.\n     * - `false` to disable the browser autocomplete/autofill behavior by setting the `autocomplete` attribute to `off`.\n     * - A **string** to be used as the [autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute value.\n     * Some browsers do not respect setting the HTML attribute `autocomplete=\"off\"` and display the auto-fill prompts anyway.\n     * @default false\n     */",
      "column": "/** The column this filter is for. */",
      "filterParams": "/** The params object passed to the filter.\n     * This is to allow the floating filter access to the configuration of the parent filter.\n     * For example, the provided filters use debounceMs from the parent filter params.\n     * */",
      "suppressFilterButton": "/** @deprecated v31.1 Use `colDef.suppressFloatingFilterButton` instead. */",
      "currentParentModel": "/** This is a shortcut to invoke getModel on the parent filter.\n     * If the parent filter doesn't exist (filters are lazily created as needed)\n     * then it returns null rather than calling getModel() on the parent filter.\n     */",
      "parentFilterInstance": "/** Gets a reference to the parent filter. The result is returned asynchronously\n     * via a callback as the parent filter may not exist yet. If it does\n     * not exist, it is created and asynchronously returned (AG Grid itself\n     * does not create components asynchronously, however if providing a framework\n     * provided filter e.g. React, it might be).\n     *\n     * The floating filter can then call any method it likes on the parent filter.\n     * The parent filter will typically provide its own method for the floating\n     * filter to call to set the filter. For example, if creating custom filter A,\n     * it should have a method your floating A can call to set the state\n     * when the user updates via the floating filter.\n     */",
      "showParentFilter": "/** Shows the parent filter popup.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "TextFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'text'",
      "filter?": "string | null",
      "filterTo?": "string | null",
      "type?": "ISimpleFilterModelType | null"
    },
    "docs": {
      "filterType?": "/** Filter type is always `'text'` */",
      "filter?": "/** The text value associated with the filter.\n     * It's optional as custom filters may not have a text value.\n     */",
      "filterTo?": "/** The 2nd text value associated with the filter, if supported.\n     */",
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "TextMatcherParams": {
    "meta": {},
    "type": {
      "filterOption": "string | null | undefined",
      "value": "any",
      "filterText": "string | null",
      "textFormatter?": "TextFormatter",
      "node": "IRowNode<TData> | null",
      "data": "TData",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "filterOption": "/** The applicable filter option being tested.\n     * One of: `equals`, `notEqual`, `contains`, `notContains`, `startsWith`, `endsWith`.\n     */",
      "value": "/** The value about to be filtered.\n     * If this column has a value getter, this value will be coming from the value getter,\n     * otherwise it is the raw value injected into the grid.\n     * If a `textFormatter` is provided, this value will have been formatted.\n     * If no `textFormatter` is provided and `caseSensitive` is not provided or is `false`,\n     * the value will have been converted to lower case.\n     */",
      "filterText": "/** The value to filter by.\n     * If a `textFormatter` is provided, this value will have been formatted.\n     * If no `textFormatter` is provided and `caseSensitive` is not provided or is `false`,\n     * the value will have been converted to lower case.\n     */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "TextMatcher": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "params": "TextMatcherParams"
      },
      "returnType": "boolean"
    }
  },
  "TextFormatter": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "from?": "string | null"
      },
      "returnType": "string | null"
    }
  },
  "TextFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "ITextFilterParams & IFilterParams<TData>"
  },
  "ITextFilterParams": {
    "meta": {
      "doc": "/** Parameters used in `colDef.filterParams` to configure a  Text Filter (`agTextColumnFilter`).\n */"
    },
    "type": {
      "textMatcher?": "TextMatcher",
      "caseSensitive?": "boolean",
      "textFormatter?": "(from: string) => string | null",
      "trimInput?": "boolean",
      "filterOptions?": "(IFilterOptionDef | ISimpleFilterModelType)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "maxNumConditions?": "number",
      "numAlwaysVisibleConditions?": "number",
      "filterPlaceholder?": "FilterPlaceholderFunction | string",
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "textMatcher?": "/** Used to override how to filter based on the user input.\n     * Returns `true` if the value passes the filter, otherwise `false`.\n     */",
      "caseSensitive?": "/** By default, text filtering is case-insensitive. Set this to `true` to make text filtering case-sensitive.\n     * @default false\n     */",
      "textFormatter?": "/** Formats the text before applying the filter compare logic.\n     * Useful if you want to substitute accented characters, for example.\n     */",
      "trimInput?": "/** If `true`, the input that the user enters will be trimmed when the filter is applied, so any leading or trailing whitespace will be removed.\n     * If only whitespace is entered, it will be left as-is.\n     * If you enable `trimInput`, it is best to also increase the `debounceMs` to give users more time to enter text.\n     * @default false\n     */",
      "filterOptions?": "/** Array of filter options to present to the user.\n     */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n     * You can change this default by setting this property.\n     * Options: `AND`, `OR`\n     */",
      "maxNumConditions?": "/** Maximum number of conditions allowed in the filter.\n     *\n     * @default 2\n     */",
      "numAlwaysVisibleConditions?": "/** By default only one condition is shown, and additional conditions are made visible when the previous conditions are entered\n     * (up to `maxNumConditions`). To have more conditions shown by default, set this to the number required.\n     * Conditions will be disabled until the previous conditions have been entered.\n     * Note that this cannot be greater than `maxNumConditions` - anything larger will be ignored.\n     *\n     * @default 1\n     */",
      "filterPlaceholder?": "/** Placeholder text for the filter textbox\n     */",
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "ITextInputFloatingFilterParams": {
    "meta": {},
    "type": {
      "browserAutoComplete?": "boolean | string",
      "column": "Column",
      "filterParams": "IFilterParams",
      "suppressFilterButton": "boolean",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: IFloatingFilterParentCallback<P>) => void",
      "showParentFilter": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "browserAutoComplete?": "/** Overrides the browser's autocomplete/autofill behaviour by updating the autocomplete attribute on the input field used in the floating filter input.\n     * Possible values are:\n     * - `true` to allow the **default** browser autocomplete/autofill behaviour.\n     * - `false` to disable the browser autocomplete/autofill behavior by setting the `autocomplete` attribute to `off`.\n     * - A **string** to be used as the [autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute value.\n     * Some browsers do not respect setting the HTML attribute `autocomplete=\"off\"` and display the auto-fill prompts anyway.\n     * @default false\n     */",
      "column": "/** The column this filter is for. */",
      "filterParams": "/** The params object passed to the filter.\n     * This is to allow the floating filter access to the configuration of the parent filter.\n     * For example, the provided filters use debounceMs from the parent filter params.\n     * */",
      "suppressFilterButton": "/** @deprecated v31.1 Use `colDef.suppressFloatingFilterButton` instead. */",
      "currentParentModel": "/** This is a shortcut to invoke getModel on the parent filter.\n     * If the parent filter doesn't exist (filters are lazily created as needed)\n     * then it returns null rather than calling getModel() on the parent filter.\n     */",
      "parentFilterInstance": "/** Gets a reference to the parent filter. The result is returned asynchronously\n     * via a callback as the parent filter may not exist yet. If it does\n     * not exist, it is created and asynchronously returned (AG Grid itself\n     * does not create components asynchronously, however if providing a framework\n     * provided filter e.g. React, it might be).\n     *\n     * The floating filter can then call any method it likes on the parent filter.\n     * The parent filter will typically provide its own method for the floating\n     * filter to call to set the filter. For example, if creating custom filter A,\n     * it should have a method your floating A can call to set the state\n     * when the user updates via the floating filter.\n     */",
      "showParentFilter": "/** Shows the parent filter popup.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ITextFloatingFilterParams": {
    "meta": {},
    "type": {
      "browserAutoComplete?": "boolean | string",
      "column": "Column",
      "filterParams": "IFilterParams",
      "suppressFilterButton": "boolean",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: IFloatingFilterParentCallback<P>) => void",
      "showParentFilter": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "browserAutoComplete?": "/** Overrides the browser's autocomplete/autofill behaviour by updating the autocomplete attribute on the input field used in the floating filter input.\n     * Possible values are:\n     * - `true` to allow the **default** browser autocomplete/autofill behaviour.\n     * - `false` to disable the browser autocomplete/autofill behavior by setting the `autocomplete` attribute to `off`.\n     * - A **string** to be used as the [autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute value.\n     * Some browsers do not respect setting the HTML attribute `autocomplete=\"off\"` and display the auto-fill prompts anyway.\n     * @default false\n     */",
      "column": "/** The column this filter is for. */",
      "filterParams": "/** The params object passed to the filter.\n     * This is to allow the floating filter access to the configuration of the parent filter.\n     * For example, the provided filters use debounceMs from the parent filter params.\n     * */",
      "suppressFilterButton": "/** @deprecated v31.1 Use `colDef.suppressFloatingFilterButton` instead. */",
      "currentParentModel": "/** This is a shortcut to invoke getModel on the parent filter.\n     * If the parent filter doesn't exist (filters are lazily created as needed)\n     * then it returns null rather than calling getModel() on the parent filter.\n     */",
      "parentFilterInstance": "/** Gets a reference to the parent filter. The result is returned asynchronously\n     * via a callback as the parent filter may not exist yet. If it does\n     * not exist, it is created and asynchronously returned (AG Grid itself\n     * does not create components asynchronously, however if providing a framework\n     * provided filter e.g. React, it might be).\n     *\n     * The floating filter can then call any method it likes on the parent filter.\n     * The parent filter will typically provide its own method for the floating\n     * filter to call to set the filter. For example, if creating custom filter A,\n     * it should have a method your floating A can call to set the state\n     * when the user updates via the floating filter.\n     */",
      "showParentFilter": "/** Shows the parent filter popup.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "QuickFilterServiceEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'quickFilterChanged'"
  },
  "GridParams": {
    "meta": {},
    "type": {
      "globalEventListener?": "(...args: any[]) => any",
      "globalSyncEventListener?": "(...args: any[]) => any",
      "frameworkOverrides?": "IFrameworkOverrides",
      "providedBeanInstances?": "{ [key: string]: any; }",
      "modules?": "Module[]"
    },
    "docs": {
      "modules?": "/** Modules to be registered directly with this grid instance.\n     */"
    }
  },
  "Params": {
    "meta": {},
    "type": {
      "modules?": "Module[]"
    },
    "docs": {
      "modules?": "/** Modules to be registered directly with this grid instance.\n     */"
    }
  },
  "RowAnimationCssClasses": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'ag-row-animation' | 'ag-row-no-animation'"
  },
  "IGridBodyComp": {
    "meta": {},
    "type": {
      "setColumnMovingCss(cssClass: string, on: boolean)": "void",
      "setCellSelectableCss(cssClass: string | null, on: boolean)": "void",
      "setTopHeight(height: number)": "void",
      "setTopDisplay(display: string)": "void",
      "setBottomHeight(height: number)": "void",
      "setBottomDisplay(display: string)": "void",
      "setStickyTopHeight(height: string)": "void",
      "setStickyTopTop(offsetTop: string)": "void",
      "setStickyTopWidth(width: string)": "void",
      "setStickyBottomHeight(height: string)": "void",
      "setStickyBottomBottom(offsetBottom: string)": "void",
      "setStickyBottomWidth(width: string)": "void",
      "setColumnCount(count: number)": "void",
      "setRowCount(count: number)": "void",
      "setRowAnimationCssOnBodyViewport(cssClass: RowAnimationCssClasses, animate: boolean)": "void",
      "setAlwaysVerticalScrollClass(cssClass: string | null, on: boolean)": "void",
      "setPinnedTopBottomOverflowY(overflow: 'scroll' | 'hidden')": "void",
      "registerBodyViewportResizeListener(listener: () => void)": "void",
      "setBodyViewportWidth(width: string)": "void",
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "ScrollSource": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Container",
      "FakeContainer"
    ],
    "docs": [
      null,
      null
    ]
  },
  "NavigateParams": {
    "meta": {},
    "type": {
      "scrollIndex": "number",
      "scrollType": "'top' | 'bottom' | null",
      "scrollColumn": "AgColumn | null",
      "focusIndex": "number",
      "focusColumn": "AgColumn",
      "isAsync?": "boolean"
    },
    "docs": {
      "scrollIndex": "/** The rowIndex to vertically scroll to. */",
      "scrollType": "/** The position to put scroll index. */",
      "scrollColumn": "/**  The column to horizontally scroll to. */",
      "focusIndex": "/** For page up/down, we want to scroll to one row/column but focus another (ie. scrollRow could be stub). */"
    }
  },
  "RowContainerName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'left' | 'right' | 'center' | 'fullWidth' | 'topLeft' | 'topRight' | 'topCenter' | 'topFullWidth' | 'stickyTopLeft' | 'stickyTopRight' | 'stickyTopCenter' | 'stickyTopFullWidth' | 'stickyBottomLeft' | 'stickyBottomRight' | 'stickyBottomCenter' | 'stickyBottomFullWidth' | 'bottomLeft' | 'bottomRight' | 'bottomCenter' | 'bottomFullWidth'"
  },
  "RowContainerType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'left' | 'right' | 'center' | 'fullWidth'"
  },
  "GetRowCtrls": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(renderer: RowRenderer) => RowCtrl[]"
  },
  "RowContainerOptions": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ type: RowContainerType; container: string; viewport?: string; pinnedType?: ColumnPinnedType; fullWidth?: boolean; getRowCtrls: GetRowCtrls; }"
  },
  "IRowContainerComp": {
    "meta": {},
    "type": {
      "setViewportHeight(height: string)": "void",
      "setRowCtrls(params: { rowCtrls: RowCtrl[]; useFlushSync?: boolean; })": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "setContainerWidth(width: string)": "void",
      "setOffsetTop(offset: string)": "void"
    }
  },
  "RowDropZoneEvents": {
    "meta": {},
    "type": {
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void"
    },
    "docs": {
      "onDragEnter?": "/** Callback function that will be executed when the rowDrag enters the target. */",
      "onDragLeave?": "/** Callback function that will be executed when the rowDrag leaves the target */",
      "onDragging?": "/** Callback function that will be executed when the rowDrag is dragged inside the target.\n     * Note: this gets called multiple times.\n     */",
      "onDragStop?": "/** Callback function that will be executed when the rowDrag drops rows within the target. */"
    }
  },
  "RowDropZoneParams": {
    "meta": {},
    "type": {
      "getContainer": "() => HTMLElement",
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void"
    },
    "docs": {
      "getContainer": "/** A callback method that returns the DropZone HTMLElement. */",
      "onDragEnter?": "/** Callback function that will be executed when the rowDrag enters the target. */",
      "onDragLeave?": "/** Callback function that will be executed when the rowDrag leaves the target */",
      "onDragging?": "/** Callback function that will be executed when the rowDrag is dragged inside the target.\n     * Note: this gets called multiple times.\n     */",
      "onDragStop?": "/** Callback function that will be executed when the rowDrag drops rows within the target. */"
    }
  },
  "SetScrollsVisibleParams": {
    "meta": {},
    "type": {
      "horizontalScrollShowing": "boolean",
      "verticalScrollShowing": "boolean"
    }
  },
  "IGridComp": {
    "meta": {},
    "type": {
      "setRtlClass(cssClass: string)": "void",
      "destroyGridUi()": "void",
      "forceFocusOutOfContainer(up: boolean)": "void",
      "getFocusableContainers()": "FocusableContainer[]",
      "setCursor(value: string | null)": "void",
      "setUserSelect(value: string | null)": "void",
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "OptionalGridComponents": {
    "meta": {},
    "type": {
      "paginationSelector?": "ComponentSelector",
      "gridHeaderDropZonesSelector?": "ComponentSelector",
      "sideBarSelector?": "ComponentSelector",
      "statusBarSelector?": "ComponentSelector",
      "watermarkSelector?": "ComponentSelector"
    }
  },
  "GetKeys": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T",
        "U"
      ]
    },
    "type": "{ [K in keyof T]: U extends T[K] ? K : T[K] extends U | null | undefined ? K : never; }[keyof T]"
  },
  "KeysOfType": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "U"
      ]
    },
    "type": "Exclude<GetKeys<GridOptions, U>, AnyGridOptions>"
  },
  "BooleanProps": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Exclude<KeysOfType<boolean>, AnyGridOptions>"
  },
  "NoArgFuncs": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "KeysOfType<() => any>"
  },
  "AnyArgFuncs": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "KeysOfType<(arg: 'NO_MATCH') => any>"
  },
  "CallbackProps": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Exclude<KeysOfType<(params: AgGridCommon<any, any>) => any>, NoArgFuncs | AnyArgFuncs>"
  },
  "ExtractParamsFromCallback": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TCallback"
      ]
    },
    "type": "TCallback extends (params: infer PA) => any ? PA : never"
  },
  "ExtractReturnTypeFromCallback": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TCallback"
      ]
    },
    "type": "TCallback extends (params: AgGridCommon<any, any>) => infer RT ? RT : never"
  },
  "WrappedCallback": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "K extends CallbackProps",
        "OriginalCallback extends GridOptions[K]"
      ]
    },
    "type": "undefined | ((params: WithoutGridCommon<ExtractParamsFromCallback<OriginalCallback>>) => ExtractReturnTypeFromCallback<OriginalCallback>)"
  },
  "PropertyChangeSet": {
    "meta": {},
    "type": {
      "id": "number",
      "properties": "(keyof GridOptions)[]"
    },
    "docs": {
      "id": "/** Unique id which can be used to link changes of multiple properties that were updated together.\n     * i.e a user updated multiple properties at the same time.\n     */",
      "properties": "/** All the properties that have been updated in this change set */"
    }
  },
  "PropertyChangedSource": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'api' | 'gridOptionsUpdated'"
  },
  "PropertyChangedEvent": {
    "meta": {},
    "type": {
      "type": "'gridPropertyChanged'",
      "changeSet": "PropertyChangeSet | undefined",
      "source": "PropertyChangedSource"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "GridOptionsOrBooleanCoercedValue": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "K extends keyof GridOptions"
      ]
    },
    "type": "K extends BooleanProps ? boolean : GridOptions[K]"
  },
  "PropertyValueChangedEvent": {
    "meta": {
      "typeParams": [
        "K extends keyof GridOptions"
      ]
    },
    "type": {
      "type": "K",
      "changeSet": "PropertyChangeSet | undefined",
      "currentValue": "GridOptionsOrBooleanCoercedValue<K>",
      "previousValue": "GridOptionsOrBooleanCoercedValue<K>",
      "source": "PropertyChangedSource"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "PropertyChangedListener": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(event: PropertyChangedEvent) => void"
  },
  "PropertyValueChangedListener": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "K extends keyof GridOptions"
      ]
    },
    "type": "(event: PropertyValueChangedEvent<K>) => void"
  },
  "IAbstractHeaderCellComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "IHeaderResizeFeature": {
    "meta": {},
    "type": {
      "toggleColumnResizing(resizing: boolean)": "void"
    }
  },
  "HeaderCellCtrlInstanceId": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "BrandedType<string, 'HeaderCellCtrlInstanceId'>"
  },
  "IHeaderCellComp": {
    "meta": {},
    "type": {
      "setWidth(width: string)": "void",
      "setAriaSort(sort?: ColumnSortState)": "void",
      "setUserCompDetails(compDetails: UserCompDetails)": "void",
      "getUserCompInstance()": "IHeader | undefined",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "HeaderAriaDescriptionKey": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'filter' | 'menu' | 'sort' | 'selectAll' | 'filterButton'"
  },
  "IHeaderParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column",
      "displayName": "string",
      "enableSorting": "boolean | undefined",
      "enableMenu": "boolean",
      "enableFilterButton": "boolean",
      "enableFilterIcon": "boolean",
      "showColumnMenu": "(source: HTMLElement) => void",
      "showColumnMenuAfterMouseClick": "(mouseEvent: MouseEvent | Touch) => void",
      "showFilter": "(source: HTMLElement) => void",
      "progressSort": "(multiSort?: boolean) => void",
      "setSort": "(sort: SortDirection, multiSort?: boolean) => void",
      "template?": "string",
      "eGridHeader": "HTMLElement",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** The column the header is for. */",
      "displayName": "/** The name to display for the column.\n     * If the column is using a headerValueGetter, the displayName will take this into account.\n     */",
      "enableSorting": "/** Whether sorting is enabled for the column.\n     * Only put sort logic into your header if this is true.\n     */",
      "enableMenu": "/** Whether menu is enabled for the column.\n     * Only display a menu button in your header if this is true.\n     */",
      "enableFilterButton": "/** Whether filter button should be displayed in the header (for new column menu).\n     */",
      "enableFilterIcon": "/** Whether filter icon should be displayed in the header (for legacy tabbed column menu).\n     */",
      "showColumnMenu": "/** Callback to request the grid to show the column menu.\n     * Pass in the html element of the column menu button to have the\n     * grid position the menu over the button.\n     */",
      "showColumnMenuAfterMouseClick": "/** Callback to request the grid to show the column menu.\n     * Similar to `showColumnMenu`, but will position the menu next to the provided `mouseEvent`.\n     */",
      "showFilter": "/** Callback to request the grid to show the filter.\n     * Pass in the html element of the filter button to have the\n     * grid position the menu over the button.\n     */",
      "progressSort": "/** Callback to progress the sort for this column.\n     * The grid will decide the next sort direction eg ascending, descending or 'no sort'.\n     * Pass `multiSort=true` if you want to do a multi sort (eg user has Shift held down when they click).\n     */",
      "setSort": "/** Callback to set the sort for this column.\n     * Pass the sort direction to use ignoring the current sort eg one of 'asc', 'desc' or null (for no sort).\n     * Pass `multiSort=true` if you want to do a multi sort (eg user has Shift held down when they click)\n     */",
      "template?": "/** Custom header template if provided to `headerComponentParams`, otherwise will be `undefined`. See [Header Templates](https://ag-grid.com/javascript-data-grid/column-headers/#header-templates) */",
      "eGridHeader": "/** The header the grid provides.\n     * The custom header component is a child of the grid provided header.\n     * The grid's header component is what contains the grid managed functionality such as resizing, keyboard navigation etc.\n     * This is provided should you want to make changes to this cell,\n     * eg add ARIA tags, or add keyboard event listener (as focus goes here when navigating to the header).\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IHeader": {
    "meta": {},
    "type": {
      "refresh(params: IHeaderParams)": "boolean"
    },
    "docs": {
      "refresh(params: IHeaderParams)": "/** Get the header to refresh. Gets called whenever Column Defs are updated. */"
    }
  },
  "IHeaderComp": {
    "meta": {},
    "type": {
      "refresh(params: IHeaderParams)": "boolean",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IHeaderParams)": "AgPromise<void> | void"
    },
    "docs": {
      "refresh(params: IHeaderParams)": "/** Get the header to refresh. Gets called whenever Column Defs are updated. */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IHeaderParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "ColumnSizeAndRatios": {
    "meta": {},
    "type": {
      "columnsToResize": "AgColumn[]",
      "resizeStartWidth": "number",
      "resizeRatios": "number[]",
      "groupAfterColumns?": "AgColumn[]",
      "groupAfterStartWidth?": "number",
      "groupAfterRatios?": "number[]"
    }
  },
  "IHeaderGroupCellComp": {
    "meta": {},
    "type": {
      "setResizableDisplayed(displayed: boolean)": "void",
      "setWidth(width: string)": "void",
      "setAriaExpanded(expanded: 'true' | 'false' | undefined)": "void",
      "setUserCompDetails(compDetails: UserCompDetails)": "void",
      "getUserCompInstance()": "IHeaderGroupComp | undefined",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "IHeaderGroupParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "columnGroup": "ColumnGroup",
      "displayName": "string",
      "setExpanded": "(expanded: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "columnGroup": "/** The column group the header is for. */",
      "displayName": "/** The text label to render.\n     * If the column is using a headerValueGetter, the displayName will take this into account.\n     */",
      "setExpanded": "/** Opens / closes the column group */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IHeaderGroup": {
    "meta": {},
    "type": {}
  },
  "IHeaderGroupComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IHeaderGroupParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IHeaderGroupParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "IHeaderFilterCellComp": {
    "meta": {},
    "type": {
      "addOrRemoveBodyCssClass(cssClassName: string, on: boolean)": "void",
      "setButtonWrapperDisplayed(displayed: boolean)": "void",
      "setCompDetails(compDetails?: UserCompDetails | null)": "void",
      "getFloatingFilterComp()": "AgPromise<IFloatingFilter> | null",
      "setWidth(width: string)": "void",
      "setMenuIcon(icon: HTMLElement)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "DropListener": {
    "meta": {},
    "type": {
      "getIconName()": "DragAndDropIcon | null",
      "onDragEnter(params: DraggingEvent)": "void",
      "onDragLeave(params: DraggingEvent)": "void",
      "onDragging(params: DraggingEvent)": "void",
      "onDragStop(params: DraggingEvent)": "void"
    }
  },
  "HeaderNavigationDirection": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "UP",
      "DOWN",
      "LEFT",
      "RIGHT"
    ],
    "docs": [
      null,
      null,
      null,
      null
    ]
  },
  "HeaderPosition": {
    "meta": {},
    "type": {
      "headerRowIndex": "number",
      "column": "Column | ColumnGroup"
    },
    "docs": {
      "headerRowIndex": "/** A number from 0 to n, where n is the last header row the grid is rendering */",
      "column": "/** The grid column or column group */"
    }
  },
  "HeaderFuturePosition": {
    "meta": {},
    "type": {
      "headerRowIndexWithoutSpan?": "number",
      "headerRowIndex": "number",
      "column": "Column | ColumnGroup"
    },
    "docs": {
      "headerRowIndex": "/** A number from 0 to n, where n is the last header row the grid is rendering */",
      "column": "/** The grid column or column group */"
    }
  },
  "HorizontalResizeParams": {
    "meta": {},
    "type": {
      "eResizeBar": "HTMLElement",
      "dragStartPixels?": "number",
      "onResizeStart": "(shiftKey: boolean) => void",
      "onResizing": "(delta: number) => void",
      "onResizeEnd": "(delta: number) => void"
    }
  },
  "IGridHeaderComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setHeightAndMinHeight(height: string)": "void"
    }
  },
  "HeaderRowType": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "COLUMN_GROUP = 'group'",
      "COLUMN = 'column'",
      "FLOATING_FILTER = 'filter'"
    ],
    "docs": [
      null,
      null,
      null
    ]
  },
  "IHeaderRowComp": {
    "meta": {},
    "type": {
      "setTop(top: string)": "void",
      "setHeight(height: string)": "void",
      "setHeaderCtrls(ctrls: AbstractHeaderCellCtrl[], forceOrder: boolean, afterScroll: boolean)": "void",
      "setWidth(width: string)": "void"
    }
  },
  "HeaderRowCtrlInstanceId": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "BrandedType<number, 'HeaderRowCtrlInstanceId'>"
  },
  "IHeaderRowContainerComp": {
    "meta": {},
    "type": {
      "setCenterWidth(width: string)": "void",
      "setViewportScrollLeft(left: number)": "void",
      "setPinnedContainerWidth(width: string)": "void",
      "setDisplayed(displayed: boolean)": "void",
      "setCtrls(ctrls: HeaderRowCtrl[])": "void"
    }
  },
  "ILogger": {
    "meta": {},
    "type": {
      "log(message: string)": "void"
    }
  },
  "AdvancedFilterModel": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "JoinAdvancedFilterModel | ColumnAdvancedFilterModel"
  },
  "JoinAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a series of filter conditions joined together. */"
    },
    "type": {
      "filterType": "'join'",
      "type": "'AND' | 'OR'",
      "conditions": "AdvancedFilterModel[]"
    },
    "docs": {
      "type": "/** How the conditions are joined together */",
      "conditions": "/** The filter conditions that are joined by the `type` */"
    }
  },
  "ColumnAdvancedFilterModel": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "TextAdvancedFilterModel | NumberAdvancedFilterModel | BooleanAdvancedFilterModel | DateAdvancedFilterModel | DateStringAdvancedFilterModel | ObjectAdvancedFilterModel"
  },
  "TextAdvancedFilterModelType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'equals' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'blank' | 'notBlank'"
  },
  "ScalarAdvancedFilterModelType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'equals' | 'notEqual' | 'lessThan' | 'lessThanOrEqual' | 'greaterThan' | 'greaterThanOrEqual' | 'blank' | 'notBlank'"
  },
  "BooleanAdvancedFilterModelType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'true' | 'false'"
  },
  "TextAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a single filter condition for a text column */"
    },
    "type": {
      "filterType": "'text'",
      "colId": "string",
      "type": "TextAdvancedFilterModelType",
      "filter?": "string"
    },
    "docs": {
      "colId": "/** The ID of the column being filtered. */",
      "type": "/** The filter option that is being applied. */",
      "filter?": "/** The value to filter on. This is the same value as displayed in the input. */"
    }
  },
  "NumberAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a single filter condition for a number column */"
    },
    "type": {
      "filterType": "'number'",
      "colId": "string",
      "type": "ScalarAdvancedFilterModelType",
      "filter?": "number"
    },
    "docs": {
      "colId": "/** The ID of the column being filtered. */",
      "type": "/** The filter option that is being applied. */",
      "filter?": "/** The value to filter on. */"
    }
  },
  "DateAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a single filter condition for a date column */"
    },
    "type": {
      "filterType": "'date'",
      "colId": "string",
      "type": "ScalarAdvancedFilterModelType",
      "filter?": "string"
    },
    "docs": {
      "colId": "/** The ID of the column being filtered. */",
      "type": "/** The filter option that is being applied. */",
      "filter?": "/** The value to filter on. This is in format `YYYY-MM-DD`. */"
    }
  },
  "DateStringAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a single filter condition for a date string column */"
    },
    "type": {
      "filterType": "'dateString'",
      "colId": "string",
      "type": "ScalarAdvancedFilterModelType",
      "filter?": "string"
    },
    "docs": {
      "colId": "/** The ID of the column being filtered. */",
      "type": "/** The filter option that is being applied. */",
      "filter?": "/** The value to filter on. This is in format `YYYY-MM-DD`. */"
    }
  },
  "BooleanAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a single filter condition for a boolean column */"
    },
    "type": {
      "filterType": "'boolean'",
      "colId": "string",
      "type": "BooleanAdvancedFilterModelType"
    },
    "docs": {
      "colId": "/** The ID of the column being filtered. */",
      "type": "/** The filter option that is being applied. */"
    }
  },
  "ObjectAdvancedFilterModel": {
    "meta": {
      "doc": "/** Represents a single filter condition for an object column */"
    },
    "type": {
      "filterType": "'object'",
      "colId": "string",
      "type": "TextAdvancedFilterModelType",
      "filter?": "string"
    },
    "docs": {
      "colId": "/** The ID of the column being filtered. */",
      "type": "/** The filter option that is being applied. */",
      "filter?": "/** The value to filter on. This is the same value as displayed in the input. */"
    }
  },
  "LabelAlignment": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'left' | 'right' | 'top'"
  },
  "AgLabelParams": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "AgPickerFieldParams": {
    "meta": {},
    "type": {
      "pickerType": "string",
      "pickerGap?": "number",
      "variableWidth?": "boolean",
      "minPickerWidth?": "number | string",
      "maxPickerWidth?": "number | string",
      "maxPickerHeight?": "number | string",
      "pickerAriaLabelKey": "string",
      "pickerAriaLabelValue": "string",
      "template?": "string",
      "agComponents?": "ComponentSelector[]",
      "className?": "string",
      "pickerIcon?": "string",
      "ariaRole?": "string",
      "modalPicker?": "boolean",
      "inputWidth?": "number | 'flex'",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    },
    "docs": {
      "variableWidth?": "/** If true, will set min-width and max-width (if present), and will set width to wrapper element width.\n     * If false, will set min-width, max-width and width to maxPickerWidth or wrapper element width.\n     */"
    }
  },
  "AgFieldParams": {
    "meta": {},
    "type": {
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "AgInputFieldParams": {
    "meta": {},
    "type": {
      "inputName?": "string",
      "inputWidth?": "number | 'flex'",
      "template?": "string",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "AgCheckboxParams": {
    "meta": {},
    "type": {
      "readOnly?": "boolean",
      "passive?": "boolean",
      "inputName?": "string",
      "inputWidth?": "number | 'flex'",
      "template?": "string",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "SizeColumnsToFitGridColumnLimits": {
    "meta": {
      "doc": "/** Limit a column width when auto-sizing to fit grid width. */"
    },
    "type": {
      "colId": "string",
      "minWidth?": "number",
      "maxWidth?": "number"
    },
    "docs": {
      "minWidth?": "/** Minimum width for this column (does not override the column minimum width) */",
      "maxWidth?": "/** Maximum width for this column (does not override the column maximum width) */"
    }
  },
  "SizeColumnsToFitGridStrategy": {
    "meta": {
      "doc": "/** Auto-size columns to fit the grid width. */"
    },
    "type": {
      "type": "'fitGridWidth'",
      "defaultMinWidth?": "number",
      "defaultMaxWidth?": "number",
      "columnLimits?": "SizeColumnsToFitGridColumnLimits[]"
    },
    "docs": {
      "defaultMinWidth?": "/** Default minimum width for every column (does not override the column minimum width). */",
      "defaultMaxWidth?": "/** Default maximum width for every column (does not override the column maximum width). */",
      "columnLimits?": "/** Provide to limit specific column widths when sizing. */"
    }
  },
  "SizeColumnsToFitProvidedWidthStrategy": {
    "meta": {
      "doc": "/** Auto-size columns to fit a provided width. */"
    },
    "type": {
      "type": "'fitProvidedWidth'",
      "width": "number"
    }
  },
  "SizeColumnsToContentStrategy": {
    "meta": {
      "doc": "/** Auto-size columns to fit their cell contents.\n * Only works for Client-Side Row Model and Server-Side Row Model.\n */"
    },
    "type": {
      "type": "'fitCellContents'",
      "skipHeader?": "boolean",
      "colIds?": "string[]"
    },
    "docs": {
      "skipHeader?": "/** If true, the header won't be included when calculating the column widths. */",
      "colIds?": "/** If not provided will auto-size all columns. Otherwise will size the specified columns. */"
    }
  },
  "BrandSymbol": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "B"
      ]
    },
    "type": "{ [__brand]: B; }"
  },
  "BrandedType": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T",
        "B"
      ]
    },
    "type": "T & BrandSymbol<B>"
  },
  "BaseDate": {
    "meta": {},
    "type": {
      "setDisabled?(disabled: boolean)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void"
    },
    "docs": {
      "setDisabled?(disabled: boolean)": "/** Optional: Sets the disabled state of this component */",
      "setInputPlaceholder?(placeholder: string)": "/** Optional: Sets the current input placeholder */",
      "setInputAriaLabel?(placeholder: string)": "/** Optional: Sets the current input aria label */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after\n     * the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters),\n     * this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing,\n     * such as putting focus on a particular DOM element.\n     */"
    }
  },
  "IDate": {
    "meta": {},
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "onParamsUpdated?(params: IDateParams)": "void",
      "refresh?(params: IDateParams)": "void",
      "setDisabled?(disabled: boolean)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void"
    },
    "docs": {
      "getDate()": "/** Returns the current date represented by this component */",
      "setDate(date: Date | null)": "/** Sets the date represented by this component */",
      "onParamsUpdated?(params: IDateParams)": "/** @deprecated v31.1 - Use `refresh` instead. */",
      "refresh?(params: IDateParams)": "/** When used in a floating filter, a hook to perform any necessary operations\n     * when the column definition is updated.\n     */",
      "setDisabled?(disabled: boolean)": "/** Optional: Sets the disabled state of this component */",
      "setInputPlaceholder?(placeholder: string)": "/** Optional: Sets the current input placeholder */",
      "setInputAriaLabel?(placeholder: string)": "/** Optional: Sets the current input aria label */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after\n     * the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters),\n     * this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing,\n     * such as putting focus on a particular DOM element.\n     */"
    }
  },
  "BaseDateParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "filterParams": "DateFilterParams",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IDateParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "onDateChanged": "() => void",
      "filterParams": "DateFilterParams",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "onDateChanged": "/** Method for component to tell AG Grid that the date has changed. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IDateComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IDateParams)": "AgPromise<void> | void",
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "onParamsUpdated?(params: IDateParams)": "void",
      "refresh?(params: IDateParams)": "void",
      "setDisabled?(disabled: boolean)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IDateParams)": "/** The init(params) method is called on the component once. */",
      "getDate()": "/** Returns the current date represented by this component */",
      "setDate(date: Date | null)": "/** Sets the date represented by this component */",
      "onParamsUpdated?(params: IDateParams)": "/** @deprecated v31.1 - Use `refresh` instead. */",
      "refresh?(params: IDateParams)": "/** When used in a floating filter, a hook to perform any necessary operations\n     * when the column definition is updated.\n     */",
      "setDisabled?(disabled: boolean)": "/** Optional: Sets the disabled state of this component */",
      "setInputPlaceholder?(placeholder: string)": "/** Optional: Sets the current input placeholder */",
      "setInputAriaLabel?(placeholder: string)": "/** Optional: Sets the current input aria label */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after\n     * the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters),\n     * this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing,\n     * such as putting focus on a particular DOM element.\n     */"
    }
  },
  "ExportFileNameGetterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ExportFileNameGetter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params?: ExportFileNameGetterParams) => string"
  },
  "BaseExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "rowPositions?": "RowPosition[]",
      "fileName?": "string | ExportFileNameGetter",
      "exportedRows?": "'all' | 'filteredAndSorted'",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string"
    },
    "docs": {
      "allColumns?": "/** If `true`, all columns will be exported in the order they appear in the columnDefs.\n     * When `false` only the columns currently being displayed will be exported.\n     * @default false\n     */",
      "columnKeys?": "/** Provide a list (an array) of column keys or Column objects if you want to export specific columns.\n     */",
      "rowPositions?": "/** Row node positions. */",
      "fileName?": "/** String to use as the file name or a function that returns a string.\n     */",
      "exportedRows?": "/** Determines whether rows are exported before being filtered and sorted.\n     * @default 'filteredAndSorted'\n     */",
      "onlySelected?": "/** Export only selected rows.\n     * @default false\n     */",
      "onlySelectedAllPages?": "/** Only export selected rows including other pages (only makes sense when using pagination).\n     * @default false\n     */",
      "skipColumnGroupHeaders?": "/** Set to `true` to exclude header column groups.\n     * @default false\n     */",
      "skipColumnHeaders?": "/** Set to `true` if you don't want to export column headers.\n     * @default false\n     */",
      "skipRowGroups?": "/** Set to `true` to skip row group headers if grouping rows. Only relevant when grouping rows.\n     * @default false\n     */",
      "skipPinnedTop?": "/** Set to `true` to suppress exporting rows pinned to the top of the grid.\n     * @default false\n     */",
      "skipPinnedBottom?": "/** Set to `true` to suppress exporting rows pinned to the bottom of the grid.\n     * @default false\n     */",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "/** A callback function that will be invoked once per row in the grid. Return true to omit the row from the export.\n     */",
      "processCellCallback?(params: ProcessCellForExportParams)": "/** A callback function invoked once per cell in the grid. Return a string value to be displayed in the export. For example this is useful for formatting date values.\n     */",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "/** A callback function invoked once per column. Return a string to be displayed in the column header.\n     */",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "/** A callback function invoked once per column group. Return a `string` to be displayed in the column group header.\n     * Note that column groups are exported by default, this option will not work with `skipColumnGroupHeaders=true`.\n     */",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "/** A callback function invoked once per row group. Return a `string` to be displayed in the group cell.\n     */"
    }
  },
  "ExportParams": {
    "meta": {
      "typeParams": [
        "T"
      ]
    },
    "type": {
      "prependContent?": "T",
      "appendContent?": "T",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => T | undefined",
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "rowPositions?": "RowPosition[]",
      "fileName?": "string | ExportFileNameGetter",
      "exportedRows?": "'all' | 'filteredAndSorted'",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string"
    },
    "docs": {
      "prependContent?": "/** Content to put at the top of the exported sheet.\n     */",
      "appendContent?": "/** Content to put at the bottom of the exported sheet.\n     */",
      "getCustomContentBelowRow?": "/** A callback function to return content to be inserted below a row in the export. */",
      "allColumns?": "/** If `true`, all columns will be exported in the order they appear in the columnDefs.\n     * When `false` only the columns currently being displayed will be exported.\n     * @default false\n     */",
      "columnKeys?": "/** Provide a list (an array) of column keys or Column objects if you want to export specific columns.\n     */",
      "rowPositions?": "/** Row node positions. */",
      "fileName?": "/** String to use as the file name or a function that returns a string.\n     */",
      "exportedRows?": "/** Determines whether rows are exported before being filtered and sorted.\n     * @default 'filteredAndSorted'\n     */",
      "onlySelected?": "/** Export only selected rows.\n     * @default false\n     */",
      "onlySelectedAllPages?": "/** Only export selected rows including other pages (only makes sense when using pagination).\n     * @default false\n     */",
      "skipColumnGroupHeaders?": "/** Set to `true` to exclude header column groups.\n     * @default false\n     */",
      "skipColumnHeaders?": "/** Set to `true` if you don't want to export column headers.\n     * @default false\n     */",
      "skipRowGroups?": "/** Set to `true` to skip row group headers if grouping rows. Only relevant when grouping rows.\n     * @default false\n     */",
      "skipPinnedTop?": "/** Set to `true` to suppress exporting rows pinned to the top of the grid.\n     * @default false\n     */",
      "skipPinnedBottom?": "/** Set to `true` to suppress exporting rows pinned to the bottom of the grid.\n     * @default false\n     */",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "/** A callback function that will be invoked once per row in the grid. Return true to omit the row from the export.\n     */",
      "processCellCallback?(params: ProcessCellForExportParams)": "/** A callback function invoked once per cell in the grid. Return a string value to be displayed in the export. For example this is useful for formatting date values.\n     */",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "/** A callback function invoked once per column. Return a string to be displayed in the column header.\n     */",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "/** A callback function invoked once per column group. Return a `string` to be displayed in the column group header.\n     * Note that column groups are exported by default, this option will not work with `skipColumnGroupHeaders=true`.\n     */",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "/** A callback function invoked once per row group. Return a `string` to be displayed in the group cell.\n     */"
    }
  },
  "PackageFileParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "T & { data: string[]; }"
  },
  "CsvCell": {
    "meta": {},
    "type": {
      "data": "CsvCellData",
      "mergeAcross?": "number"
    },
    "docs": {
      "data": "/** The data that will be added to the cell. */",
      "mergeAcross?": "/** The number of cells to span across (1 means span 2 columns).\n     * @default 0\n     */"
    }
  },
  "CsvCellData": {
    "meta": {},
    "type": {
      "value": "string | null"
    },
    "docs": {
      "value": "/** The value of the cell. */"
    }
  },
  "CsvCustomContent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "CsvCell[][] | string"
  },
  "CsvExportParams": {
    "meta": {},
    "type": {
      "columnSeparator?": "string",
      "suppressQuotes?": "boolean",
      "prependContent?": "CsvCustomContent",
      "appendContent?": "CsvCustomContent",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => CsvCustomContent | undefined",
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "rowPositions?": "RowPosition[]",
      "fileName?": "string | ExportFileNameGetter",
      "exportedRows?": "'all' | 'filteredAndSorted'",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string"
    },
    "docs": {
      "columnSeparator?": "/** Delimiter to insert between cell values.\n     * @default ,\n     */",
      "suppressQuotes?": "/** By default cell values are encoded according to CSV format rules: values are wrapped in double quotes, and any double quotes within the values are escaped, so my value becomes \\\"my\\\"\\\"value\\\". Pass `true` to insert the value into the CSV file without escaping.\n     * In this case it is your responsibility to ensure that no cells contain the columnSeparator character.\n     * @default false\n     */",
      "prependContent?": "/** Content to put at the top of the exported sheet.\n     */",
      "appendContent?": "/** Content to put at the bottom of the exported sheet.\n     */",
      "getCustomContentBelowRow?": "/** A callback function to return content to be inserted below a row in the export. */",
      "allColumns?": "/** If `true`, all columns will be exported in the order they appear in the columnDefs.\n     * When `false` only the columns currently being displayed will be exported.\n     * @default false\n     */",
      "columnKeys?": "/** Provide a list (an array) of column keys or Column objects if you want to export specific columns.\n     */",
      "rowPositions?": "/** Row node positions. */",
      "fileName?": "/** String to use as the file name or a function that returns a string.\n     */",
      "exportedRows?": "/** Determines whether rows are exported before being filtered and sorted.\n     * @default 'filteredAndSorted'\n     */",
      "onlySelected?": "/** Export only selected rows.\n     * @default false\n     */",
      "onlySelectedAllPages?": "/** Only export selected rows including other pages (only makes sense when using pagination).\n     * @default false\n     */",
      "skipColumnGroupHeaders?": "/** Set to `true` to exclude header column groups.\n     * @default false\n     */",
      "skipColumnHeaders?": "/** Set to `true` if you don't want to export column headers.\n     * @default false\n     */",
      "skipRowGroups?": "/** Set to `true` to skip row group headers if grouping rows. Only relevant when grouping rows.\n     * @default false\n     */",
      "skipPinnedTop?": "/** Set to `true` to suppress exporting rows pinned to the top of the grid.\n     * @default false\n     */",
      "skipPinnedBottom?": "/** Set to `true` to suppress exporting rows pinned to the bottom of the grid.\n     * @default false\n     */",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "/** A callback function that will be invoked once per row in the grid. Return true to omit the row from the export.\n     */",
      "processCellCallback?(params: ProcessCellForExportParams)": "/** A callback function invoked once per cell in the grid. Return a string value to be displayed in the export. For example this is useful for formatting date values.\n     */",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "/** A callback function invoked once per column. Return a string to be displayed in the column header.\n     */",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "/** A callback function invoked once per column group. Return a `string` to be displayed in the column group header.\n     * Note that column groups are exported by default, this option will not work with `skipColumnGroupHeaders=true`.\n     */",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "/** A callback function invoked once per row group. Return a `string` to be displayed in the group cell.\n     */"
    }
  },
  "ShouldRowBeSkippedParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "node": "/** Row node. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ProcessCellForExportParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "any",
      "accumulatedRowIndex?": "number",
      "node?": "IRowNode<TData> | null",
      "column": "Column",
      "type": "string",
      "parseValue": "(value: string) => any",
      "formatValue": "(value: any) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ProcessHeaderForExportParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ProcessGroupHeaderForExportParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "columnGroup": "ColumnGroup",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ProcessRowGroupForExportParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "column?": "Column",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "FilterState": {
    "meta": {},
    "type": {
      "filterModel?": "FilterModel",
      "advancedFilterModel?": "AdvancedFilterModel"
    }
  },
  "RangeSelectionCellState": {
    "meta": {},
    "type": {
      "id?": "string",
      "type?": "CellRangeType",
      "startRow?": "RowPosition",
      "endRow?": "RowPosition",
      "colIds": "string[]",
      "startColId": "string"
    },
    "docs": {
      "startRow?": "/** The start row of the range */",
      "endRow?": "/** The end row of the range */",
      "colIds": "/** The columns in the range */",
      "startColId": "/** The start column for the range */"
    }
  },
  "RangeSelectionState": {
    "meta": {},
    "type": {
      "cellRanges": "RangeSelectionCellState[]"
    }
  },
  "ScrollState": {
    "meta": {},
    "type": {
      "top": "number",
      "left": "number"
    }
  },
  "FiltersToolPanelState": {
    "meta": {},
    "type": {
      "expandedGroupIds": "string[]",
      "expandedColIds": "string[]"
    }
  },
  "ColumnToolPanelState": {
    "meta": {},
    "type": {
      "expandedGroupIds": "string[]"
    }
  },
  "SideBarState": {
    "meta": {},
    "type": {
      "visible": "boolean",
      "position": "'left' | 'right'",
      "openToolPanel": "string | null",
      "toolPanels": "{ [id: string]: any; }"
    },
    "docs": {
      "visible": "/** Is side bar visible */",
      "openToolPanel": "/** Open tool panel, or null if closed */",
      "toolPanels": "/** State for each tool panel */"
    }
  },
  "FocusedCellState": {
    "meta": {},
    "type": {
      "colId": "string",
      "rowIndex": "number",
      "rowPinned": "RowPinnedType"
    },
    "docs": {
      "rowIndex": "/** A positive number from 0 to n, where n is the last row the grid is rendering\n     * or -1 if you want to navigate to the grid header */",
      "rowPinned": "/** Either 'top', 'bottom' or null/undefined (for not pinned) */"
    }
  },
  "PaginationState": {
    "meta": {},
    "type": {
      "page?": "number",
      "pageSize?": "number"
    },
    "docs": {
      "page?": "/** Current page */",
      "pageSize?": "/** Current page size. Only use when the pageSizeSelector dropdown is visible */"
    }
  },
  "SortState": {
    "meta": {},
    "type": {
      "sortModel": "SortModelItem[]"
    },
    "docs": {
      "sortModel": "/** Sorted columns and directions in order */"
    }
  },
  "RowGroupState": {
    "meta": {},
    "type": {
      "groupColIds": "string[]"
    },
    "docs": {
      "groupColIds": "/** Grouped columns in order */"
    }
  },
  "AggregationColumnState": {
    "meta": {},
    "type": {
      "colId": "string",
      "aggFunc": "string"
    },
    "docs": {
      "aggFunc": "/** Only named aggregation functions can be used in state */"
    }
  },
  "AggregationState": {
    "meta": {},
    "type": {
      "aggregationModel": "AggregationColumnState[]"
    }
  },
  "PivotState": {
    "meta": {},
    "type": {
      "pivotMode": "boolean",
      "pivotColIds": "string[]"
    }
  },
  "ColumnPinningState": {
    "meta": {},
    "type": {
      "leftColIds": "string[]",
      "rightColIds": "string[]"
    }
  },
  "ColumnVisibilityState": {
    "meta": {},
    "type": {
      "hiddenColIds": "string[]"
    }
  },
  "ColumnSizeState": {
    "meta": {},
    "type": {
      "colId": "string",
      "width?": "number",
      "flex?": "number"
    }
  },
  "ColumnSizingState": {
    "meta": {},
    "type": {
      "columnSizingModel": "ColumnSizeState[]"
    }
  },
  "ColumnOrderState": {
    "meta": {},
    "type": {
      "orderedColIds": "string[]"
    },
    "docs": {
      "orderedColIds": "/** All colIds in order */"
    }
  },
  "ColumnGroupState": {
    "meta": {},
    "type": {
      "openColumnGroupIds": "string[]"
    }
  },
  "RowGroupExpansionState": {
    "meta": {},
    "type": {
      "expandedRowGroupIds": "string[]"
    }
  },
  "GridState": {
    "meta": {},
    "type": {
      "aggregation?": "AggregationState",
      "columnGroup?": "ColumnGroupState",
      "columnOrder?": "ColumnOrderState",
      "columnPinning?": "ColumnPinningState",
      "columnSizing?": "ColumnSizingState",
      "columnVisibility?": "ColumnVisibilityState",
      "filter?": "FilterState",
      "focusedCell?": "FocusedCellState",
      "pagination?": "PaginationState",
      "pivot?": "PivotState",
      "rangeSelection?": "RangeSelectionState",
      "rowGroup?": "RowGroupState",
      "rowGroupExpansion?": "RowGroupExpansionState",
      "rowSelection?": "string[] | ServerSideRowSelectionState | ServerSideRowGroupSelectionState",
      "scroll?": "ScrollState",
      "sideBar?": "SideBarState",
      "sort?": "SortState"
    },
    "docs": {
      "aggregation?": "/** Includes aggregation functions */",
      "columnGroup?": "/** Includes opened groups */",
      "columnOrder?": "/** Includes column ordering */",
      "columnPinning?": "/** Includes left/right pinned columns */",
      "columnSizing?": "/** Includes column width/flex */",
      "columnVisibility?": "/** Includes hidden columns */",
      "filter?": "/** Includes Column Filters and Advanced Filter */",
      "focusedCell?": "/** Includes currently focused cell. Works for Client-Side Row Model only */",
      "pagination?": "/** Includes current page */",
      "pivot?": "/** Includes current pivot mode and pivot columns */",
      "rangeSelection?": "/** Includes currently selected cell ranges */",
      "rowGroup?": "/** Includes current row group columns */",
      "rowGroupExpansion?": "/** Includes currently expanded group rows */",
      "rowSelection?": "/** Includes currently selected rows.\n     * For Server-Side Row Model, will be `ServerSideRowSelectionState | ServerSideRowGroupSelectionState`,\n     * for other row models, will be an array of row IDs\n     */",
      "scroll?": "/** Includes current scroll position. Works for Client-Side Row Model only */",
      "sideBar?": "/** Includes current Side Bar positioning and opened tool panel */",
      "sort?": "/** Includes current sort columns and direction */"
    }
  },
  "FooterValueGetterFunc": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "params": "GroupCellRendererParams"
      },
      "returnType": "any"
    }
  },
  "TotalValueGetterFunc": {
    "meta": {
      "isCallSignature": true
    },
    "type": {
      "arguments": {
        "params": "GroupCellRendererParams"
      },
      "returnType": "any"
    }
  },
  "GroupCheckboxSelectionCallbackParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": "ColumnFunctionCallbackParams<TData> & GroupCellRendererParams<TData, TValue>"
  },
  "GroupCheckboxSelectionCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GroupCheckboxSelectionCallbackParams<TData, TValue>"
      },
      "returnType": "boolean"
    }
  },
  "IGroupCellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ],
      "doc": "/** Parameters used in `colDef.cellRendererParams` to configure a  Group Cell Renderer (`agGroupCellRenderer`).\n */"
    },
    "type": {
      "suppressPadding?": "boolean",
      "suppressDoubleClickExpand?": "boolean",
      "suppressEnterExpand?": "boolean",
      "footerValueGetter?": "string | FooterValueGetterFunc",
      "totalValueGetter?": "string | TotalValueGetterFunc",
      "suppressCount?": "boolean",
      "checkbox?": "boolean | GroupCheckboxSelectionCallback<TData, TValue>",
      "innerRenderer?": "any",
      "innerRendererParams?": "any",
      "innerRendererSelector?": "CellRendererSelectorFunc"
    },
    "docs": {
      "suppressPadding?": "/** Set to `true` to not include any padding (indentation) in the child rows. */",
      "suppressDoubleClickExpand?": "/** Set to `true` to suppress expand on double click. */",
      "suppressEnterExpand?": "/** Set to `true` to suppress expand on <kbd>↵ Enter</kbd> */",
      "footerValueGetter?": "/** The value getter for the footer text. Can be a function or expression. @deprecated v31.2 use `totalValueGetter` */",
      "totalValueGetter?": "/** The value getter for the total row text. Can be a function or expression. */",
      "suppressCount?": "/** If `true`, count is not displayed beside the name. */",
      "checkbox?": "/** Set to `true`, or a function that returns `true`, if a checkbox should be included.\n     */",
      "innerRenderer?": "/** The renderer to use for inside the cell (after grouping functions are added) */",
      "innerRendererParams?": "/** Additional params to customise to the `innerRenderer`. */",
      "innerRendererSelector?": "/** Callback to enable different innerRenderers to be used based of value of params. */"
    }
  },
  "IGroupCellRendererFullRowParams": {
    "meta": {},
    "type": {
      "pinned?": "'left' | 'right' | null",
      "fullWidth": "boolean",
      "rowDrag?": "boolean"
    },
    "docs": {
      "pinned?": "/** Only when in fullWidth, this gives whether the comp is pinned or not.\n     * If not doing fullWidth, then this is not provided, as pinned can be got from the column.\n     */",
      "fullWidth": "/** 'true' if comp is showing full width. */"
    }
  },
  "GroupCellRendererParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": "IGroupCellRendererParams & ICellRendererParams<TData, TValue> & IGroupCellRendererFullRowParams"
  },
  "IGroupCellRenderer": {
    "meta": {},
    "type": {
      "setInnerRenderer(compDetails: UserCompDetails | undefined, valueToDisplay: any)": "void",
      "setChildCount(count: string)": "void",
      "setCheckboxVisible(value: boolean)": "void",
      "setExpandedDisplayed(value: boolean)": "void",
      "setContractedDisplayed(value: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "IGroupCellRendererCtrl": {
    "meta": {},
    "type": {
      "init(comp: IGroupCellRenderer, eGui: HTMLElement, eCheckbox: HTMLElement, eExpanded: HTMLElement, eContracted: HTMLElement, compClass: any, params: GroupCellRendererParams)": "void",
      "destroy()": "void",
      "getCellAriaRole()": "string"
    }
  },
  "IAdvancedFilterBuilderParams": {
    "meta": {
      "doc": "/** Parameters passed to the Advanced Filter Builder\n */"
    },
    "type": {
      "minWidth?": "number",
      "showMoveButtons?": "boolean",
      "addSelectWidth?": "number",
      "pillSelectMinWidth?": "number",
      "pillSelectMaxWidth?": "number"
    },
    "docs": {
      "minWidth?": "/** Minimum width in pixels of the Advanced Filter Builder popup.\n     * @default 500\n     */",
      "showMoveButtons?": "/** Whether to show the move up and move down buttons in the Advanced Filter Builder.\n     * @default false\n     */",
      "addSelectWidth?": "/** Width in pixels of the Advanced Filter Builder add button select popup.\n     * @default 120\n     */",
      "pillSelectMinWidth?": "/** Min width in pixels of the Advanced Filter Builder pill select popup.\n     * @default 140\n     */",
      "pillSelectMaxWidth?": "/** Max width in pixels of the Advanced Filter Builder pill select popup.\n     * @default 200\n     */"
    }
  },
  "IAdvancedFilterCtrl": {
    "meta": {},
    "type": {
      "setupHeaderComp(eCompToInsertBefore: HTMLElement)": "void",
      "focusHeaderComp()": "boolean",
      "getHeaderHeight()": "number",
      "toggleFilterBuilder(source: 'api' | 'ui', force?: boolean)": "void"
    }
  },
  "IAdvancedFilterService": {
    "meta": {},
    "type": {
      "isEnabled()": "boolean",
      "isFilterPresent()": "boolean",
      "doesFilterPass(node: IRowNode)": "boolean",
      "getModel()": "AdvancedFilterModel | null",
      "setModel(model: AdvancedFilterModel | null)": "void",
      "isHeaderActive()": "boolean",
      "getCtrl()": "IAdvancedFilterCtrl",
      "updateValidity()": "boolean"
    }
  },
  "ContainerType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'columnMenu' | 'contextMenu' | 'toolPanel' | 'floatingFilter' | 'columnFilter'"
  },
  "IAfterGuiAttachedParams": {
    "meta": {},
    "type": {
      "container?": "ContainerType",
      "hidePopup?": "() => void",
      "suppressFocus?": "boolean"
    },
    "docs": {
      "container?": "/** Where this component is attached to. */",
      "hidePopup?": "/** Call this to hide the popup.\n     * i.e useful if your component has an action button and you want to hide the popup after it is pressed.\n     */",
      "suppressFocus?": "/** Set to `true` to not have the component focus its default item. */"
    }
  },
  "AgChartThemeOverrides": {
    "meta": {},
    "type": {}
  },
  "AgChartThemePalette": {
    "meta": {},
    "type": {}
  },
  "AgChartThemeDefinition": {
    "meta": {},
    "type": {}
  },
  "AgChartTheme": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "string | AgChartThemeDefinition"
  },
  "IAggFuncService": {
    "meta": {},
    "type": {
      "addAggFuncs(aggFuncs: { [key: string]: IAggFunc; })": "void",
      "clear()": "void",
      "getDefaultAggFunc(column: AgColumn)": "string | null",
      "getFuncNames(column: AgColumn)": "string[]",
      "getDefaultFuncLabel(fctName: string)": "string"
    }
  },
  "IAggregationStage": {
    "meta": {},
    "type": {
      "aggregateValues(values: any[], aggFuncOrString: string | IAggFunc)": "any"
    }
  },
  "TypeOrNull": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "T | null"
  },
  "ApiRef": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ api?: TypeOrNull<GridApi>; } | null"
  },
  "AlignedGrid": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "TypeOrNull<GridApi> | ApiRef | { current: ApiRef; }"
  },
  "IAutoColService": {
    "meta": {},
    "type": {
      "createAutoCols(rowGroupCols: AgColumn[])": "AgColumn[]",
      "updateAutoCols(autoGroupCols: AgColumn[], source: ColumnEventType)": "void"
    }
  },
  "GetContextMenuItemsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "defaultItems": "string[] | undefined",
      "column": "Column | null",
      "node": "IRowNode<TData> | null",
      "value": "any",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "defaultItems": "/** Names of the items that would be provided by default. */",
      "column": "/** The column, if a cell was clicked, otherwise null. */",
      "node": "/** The row node, if a cell was clicked, otherwise null. */",
      "value": "/** The value, if a cell was clicked, otherwise null.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetMainMenuItemsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column",
      "defaultItems": "string[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** The column that was clicked */",
      "defaultItems": "/** List of the items that would be displayed by default */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetChartMenuItemsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "defaultItems": "string[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "defaultItems": "/** List of the items that would be displayed by default */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ProcessUnpinnedColumnsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "columns": "Column[]",
      "viewportWidth": "number",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "PostProcessPopupParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column?": "Column | null",
      "rowNode?": "IRowNode<TData> | null",
      "ePopup": "HTMLElement",
      "type": "string",
      "eventSource?": "HTMLElement | null",
      "mouseEvent?": "MouseEvent | Touch | null",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column?": "/** If popup is for a column, this gives the Column */",
      "rowNode?": "/** If popup is for a row, this gives the RowNode */",
      "ePopup": "/** The popup we are showing */",
      "type": "/** The different types are:\n     *  'contextMenu', 'columnMenu', 'aggFuncSelect', 'popupCellEditor' */",
      "eventSource?": "/** If the popup is as a result of a button click (eg menu button),\n     *  this is the component that the user clicked */",
      "mouseEvent?": "/** If the popup is as a result of a click or touch,\n     *  this is the event - eg user showing context menu */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SendToClipboardParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ProcessDataFromClipboardParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "string[][]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "data": "/** 2D array of all cells from the clipboard */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetChartToolbarItemsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "defaultItems?": "ChartToolbarMenuItemOptions[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "FocusGridInnerElementParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "fromBottom": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "fromBottom": "/** This will be true if the focus is coming from and element below the grid in the DOM structure. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "NavigateToNextHeaderParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "key": "string",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "headerRowCount": "number",
      "event": "KeyboardEvent",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "key": "/** The key for the arrow key pressed,\n     *  left = 'ArrowLeft', up = 'ArrowUp', right = 'ArrowRight', down = 'ArrowDown' */",
      "previousHeaderPosition": "/** The header that currently has focus */",
      "nextHeaderPosition": "/** The header the grid would normally pick as the next header for this navigation */",
      "headerRowCount": "/** The number of header rows present in the grid */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "TabToNextHeaderParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "backwards": "boolean",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "headerRowCount": "number",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "backwards": "/** True if the Shift key is also down */",
      "previousHeaderPosition": "/** The header that currently has focus */",
      "nextHeaderPosition": "/** The header the grid would normally pick as the next header for this navigation */",
      "headerRowCount": "/** The number of header rows present in the grid */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "TabToNextCellParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "backwards": "boolean",
      "editing": "boolean",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition | null",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "backwards": "/** True if the Shift key is also down */",
      "editing": "/** True if the current cell is editing\n     * (you may want to skip cells that are not editable, as the grid will enter the next cell in editing mode also if tabbing) */",
      "previousCellPosition": "/** The cell that currently has focus */",
      "nextCellPosition": "/** The cell the grid would normally pick as the next cell for navigation.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "NavigateToNextCellParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "key": "string",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition | null",
      "event": "KeyboardEvent | null",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "key": "/** The keycode for the arrow key pressed:\n     *  left = 'ArrowLeft', up = 'ArrowUp', right = 'ArrowRight', down = 'ArrowDown' */",
      "previousCellPosition": "/** The cell that currently has focus */",
      "nextCellPosition": "/** The cell the grid would normally pick as the next cell for navigation */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "PaginationNumberFormatterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "number",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IsGroupOpenByDefaultParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "rowNode": "IRowNode<TData>",
      "rowGroupColumn": "Column",
      "level": "number",
      "field": "string",
      "key": "string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "rowNode": "/** The row node being considered. */",
      "rowGroupColumn": "/** The Column for which this row is grouping. */",
      "level": "/** Same as `rowNode.level` - what level the group is at, e.g. 0 for top level, 1 for second etc */",
      "field": "/** Same as `rowNode.field` - the field we are grouping on, e.g. 'country' */",
      "key": "/** Same as `rowNode.key`, the value of this group, e.g. 'Ireland' */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetServerSideGroupLevelParamsParams": {
    "meta": {},
    "type": {
      "level": "number",
      "parentRowNode?": "IRowNode",
      "rowGroupColumns": "Column[]",
      "pivotColumns": "Column[]",
      "pivotMode": "boolean",
      "api": "GridApi<any>",
      "context": "any"
    },
    "docs": {
      "level": "/** The level of the store. Top level is 0. */",
      "parentRowNode?": "/** The Row Node for the group that got expanded, or undefined if top level (ie no parent) */",
      "rowGroupColumns": "/** Active Row Group Columns, if any. */",
      "pivotColumns": "/** Active Pivot Columns, if any. */",
      "pivotMode": "/** true if pivot mode is active. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IsServerSideGroupOpenByDefaultParams": {
    "meta": {},
    "type": {
      "data": "any",
      "rowNode": "IRowNode",
      "api": "GridApi<any>",
      "context": "any"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IsApplyServerSideTransactionParams": {
    "meta": {},
    "type": {
      "transaction": "ServerSideTransaction",
      "parentNode": "IRowNode",
      "groupLevelInfo": "any",
      "api": "GridApi<any>",
      "context": "any"
    },
    "docs": {
      "transaction": "/** The transaction getting applied. */",
      "parentNode": "/** The parent RowNode, if transaction is applied to a group. */",
      "groupLevelInfo": "/** Store info, if any, as passed via the success() callback when loading data. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetRowIdParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData",
      "level": "number",
      "parentKeys?": "string[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "data": "/** The data item provided to the grid for the row in question */",
      "level": "/** If grouping, the level, ie how many levels from the top. Used by ServerSide Row Model only */",
      "parentKeys?": "/** If grouping, provides the keys of the parent groups. Used by ServerSide Row Model only */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "RenderedRowEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'virtualRowRemoved'"
  },
  "ProcessRowParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "eRow": "HTMLElement",
      "ePinnedLeftRow?": "HTMLElement",
      "ePinnedRightRow?": "HTMLElement",
      "rowIndex": "number",
      "node": "IRowNode<TData>",
      "addRenderedRowListener": "(eventType: RenderedRowEvent, listener: (...args: any[]) => any) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "FillOperationParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "event": "MouseEvent",
      "values": "any[]",
      "rowNode": "IRowNode<TData>",
      "column": "Column",
      "initialValues": "any[]",
      "initialNonAggregatedValues": "any[]",
      "initialFormattedValues": "any[]",
      "currentIndex": "number",
      "currentCellValue": "any",
      "direction": "'up' | 'down' | 'left' | 'right'",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "event": "/** The mouse event for the fill operation. */",
      "values": "/** The values that have been processed by the fill operation. */",
      "rowNode": "/** The RowNode of the current cell being changed. */",
      "column": "/** The Column of the current cell being changed. */",
      "initialValues": "/** The values that were present before processing started. */",
      "initialNonAggregatedValues": "/** The values that were present before processing, without the aggregation function. */",
      "initialFormattedValues": "/** The values that were present before processing, after being formatted by their value formatter */",
      "currentIndex": "/** The index of the current processed value. */",
      "currentCellValue": "/** The value of the cell being currently processed by the Fill Operation. */",
      "direction": "/** The direction of the Fill Operation. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "RowHeightParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "data": "/** The data associated with this row from rowData. Data is `undefined` for row groups. */",
      "node": "/** The RowNode of the row in question. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IsExternalFilterPresentParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "InitialGroupOrderComparatorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "nodeA": "IRowNode<TData>",
      "nodeB": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetGroupRowAggParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "nodes": "IRowNode<TData>[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "PostSortRowsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "nodes": "IRowNode<TData>[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IsFullWidthRowParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "rowNode": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetLocaleTextParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "key": "string",
      "defaultValue": "string",
      "variableValues?": "string[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetGroupAggFilteringParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetGroupIncludeFooterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetGroupIncludeTotalRowParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IMenuActionParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column | null",
      "node": "IRowNode<TData> | null",
      "value": "any",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** The column, if a cell was clicked, otherwise null. */",
      "node": "/** The row node, if a cell was clicked, otherwise null. */",
      "value": "/** The value, if a cell was clicked, otherwise null.  */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "BaseCellEditor": {
    "meta": {},
    "type": {
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */"
    }
  },
  "ICellEditor": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "getValue()": "TValue | null | undefined",
      "refresh?(params: ICellEditorParams<any, TValue>)": "void",
      "afterGuiAttached?()": "void",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "'over' | 'under' | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "getValue()": "/** Return the final value - called by the grid once after editing is complete\n     */",
      "refresh?(params: ICellEditorParams<any, TValue>)": "/** Optional: Gets called with the latest cell editor params every time they update\n     */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * This method is called each time the edit component is activated.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "isPopup?()": "/** Optional: Gets called once after initialised. If you return true, the editor will\n     * appear in a popup, so is not constrained to the boundaries of the cell.\n     * This is great if you want to, for example, provide you own custom dropdown list\n     * for selection. Default is false (ie if you don't provide the method).\n     */",
      "getPopupPosition?()": "/** Optional: Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n     * should cover the cell, or \"under\" if it should be positioned below leaving the\n     * cell value visible. If this method is not present, the default is \"over\".\n     */",
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */"
    }
  },
  "ICellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ICellEditorComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "getValue()": "TValue | null | undefined",
      "refresh?(params: ICellEditorParams<any, TValue>)": "void",
      "afterGuiAttached?()": "void",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "'over' | 'under' | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getValue()": "/** Return the final value - called by the grid once after editing is complete\n     */",
      "refresh?(params: ICellEditorParams<any, TValue>)": "/** Optional: Gets called with the latest cell editor params every time they update\n     */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * This method is called each time the edit component is activated.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "isPopup?()": "/** Optional: Gets called once after initialised. If you return true, the editor will\n     * appear in a popup, so is not constrained to the boundaries of the cell.\n     * This is great if you want to, for example, provide you own custom dropdown list\n     * for selection. Default is false (ie if you don't provide the method).\n     */",
      "getPopupPosition?()": "/** Optional: Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n     * should cover the cell, or \"under\" if it should be positioned below leaving the\n     * cell value visible. If this method is not present, the default is \"over\".\n     */",
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: T)": "/** The init(params) method is called on the component once. */"
    }
  },
  "ICellEditorRendererParams": {
    "meta": {
      "typeParams": [
        "TValue = any",
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "TValue[] | TValue | null",
      "valueFormatted": "string",
      "getValue": "() => TValue[] | TValue | null | undefined",
      "setValue": "(value: TValue[] | TValue | null) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** The value to be rendered by the renderer */",
      "valueFormatted": "/** The value to be renderer by the renderer formatted by the editor */",
      "getValue": "/** Gets the current value of the editor */",
      "setValue": "/** Sets the value of the editor */",
      "setTooltip": "/** Used to set a tooltip to the renderer */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ICellEditorRendererComp": {
    "meta": {
      "typeParams": [
        "TValue"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: ICellEditorRendererParams<TValue>)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: ICellEditorRendererParams<TValue>)": "/** The init(params) method is called on the component once. */"
    }
  },
  "ChartGroupsDef": {
    "meta": {},
    "type": {
      "columnGroup?": "('column' | 'stackedColumn' | 'normalizedColumn')[]",
      "barGroup?": "('bar' | 'stackedBar' | 'normalizedBar')[]",
      "pieGroup?": "('pie' | 'donut' | 'doughnut')[]",
      "lineGroup?": "'line'[]",
      "scatterGroup?": "('scatter' | 'bubble')[]",
      "areaGroup?": "('area' | 'stackedArea' | 'normalizedArea')[]",
      "combinationGroup?": "('columnLineCombo' | 'areaColumnCombo' | 'customCombo')[]",
      "polarGroup?": "('radarLine' | 'radarArea' | 'nightingale' | 'radialColumn' | 'radialBar')[]",
      "statisticalGroup?": "('boxPlot' | 'histogram' | 'rangeBar' | 'rangeArea')[]",
      "hierarchicalGroup?": "('treemap' | 'sunburst')[]",
      "specializedGroup?": "('heatmap' | 'waterfall')[]"
    }
  },
  "ChartToolPanelName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'settings' | 'data' | 'format'"
  },
  "ChartSettingsPanel": {
    "meta": {
      "doc": "/** Configuration for the `Chart` panel */"
    },
    "type": {
      "chartGroupsDef?": "ChartGroupsDef"
    },
    "docs": {
      "chartGroupsDef?": "/** Chart groups customisations for which charts are displayed in the chart panel */"
    }
  },
  "ChartFormatPanelGroup": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'chart' | 'titles' | 'legend' | 'axis' | 'horizontalAxis' | 'verticalAxis' | 'series' | 'navigator'"
  },
  "ChartDataPanelGroup": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'categories' | 'series' | 'seriesChartType' | 'chartSpecific'"
  },
  "ChartPanelGroupDef": {
    "meta": {
      "typeParams": [
        "GroupType"
      ]
    },
    "type": {
      "type": "GroupType",
      "isOpen?": "boolean"
    },
    "docs": {
      "type": "/** The panel group type */",
      "isOpen?": "/** Whether the panel group is open by default. If not specified, it is closed */"
    }
  },
  "ChartFormatPanel": {
    "meta": {
      "doc": "/** Configuration for the `Customize` panel */"
    },
    "type": {
      "groups?": "ChartPanelGroupDef<ChartFormatPanelGroup>[]"
    },
    "docs": {
      "groups?": "/** The customize panel group configurations, their order and whether they are shown. If not specified shows all groups */"
    }
  },
  "ChartDataPanel": {
    "meta": {
      "doc": "/** Configuration for the `Set Up` panel */"
    },
    "type": {
      "groups?": "ChartPanelGroupDef<ChartDataPanelGroup>[]"
    },
    "docs": {
      "groups?": "/** The set up panel group configurations, their order and whether they are shown. If not specified shows all groups */"
    }
  },
  "ChartToolPanelsDef": {
    "meta": {},
    "type": {
      "settingsPanel?": "ChartSettingsPanel",
      "formatPanel?": "ChartFormatPanel",
      "dataPanel?": "ChartDataPanel",
      "panels?": "ChartToolPanelName[]",
      "defaultToolPanel?": "ChartToolPanelName"
    },
    "docs": {
      "settingsPanel?": "/** Customisations for the chart panel and chart menu items in the Context Menu. */",
      "formatPanel?": "/** Customisations for the customize panel */",
      "dataPanel?": "/** Customisations for the set up panel */",
      "panels?": "/** The ordered list of panels to show in the chart tool panels. If none specified, all panels are shown */",
      "defaultToolPanel?": "/** The panel to open by default when the chart loads. If none specified, the tool panel is hidden by default and the first panel is open when triggered. */"
    }
  },
  "CrossFilterChartType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'column' | 'bar' | 'line' | 'scatter' | 'bubble' | 'pie' | 'donut' | 'doughnut' | 'area'"
  },
  "ChartToolPanelMenuOptions": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'chartSettings' | 'chartData' | 'chartFormat'"
  },
  "ChartToolbarMenuItemOptions": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'chartLink' | 'chartUnlink' | 'chartDownload' | 'chartMenu'"
  },
  "SeriesChartType": {
    "meta": {},
    "type": {
      "colId": "string",
      "chartType": "ChartType",
      "secondaryAxis?": "boolean"
    }
  },
  "ChartType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "keyof typeof ChartMappings.CHART_TYPE_TO_SERIES_TYPE | (typeof ChartMappings.COMBO_CHART_TYPES)[number]"
  },
  "SeriesGroupType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(typeof ChartMappings.SERIES_GROUP_TYPES)[number]"
  },
  "GetChartImageDataUrlParams": {
    "meta": {},
    "type": {
      "chartId": "string",
      "fileFormat?": "string"
    },
    "docs": {
      "chartId": "/** The id of the created chart. */",
      "fileFormat?": "/** A string indicating the image format.\n     * The default format type is `image/png`.\n     * Options: `image/png`, `image/jpeg`\n     */"
    }
  },
  "ChartDownloadParams": {
    "meta": {},
    "type": {
      "chartId": "string",
      "fileName?": "string",
      "fileFormat?": "string",
      "dimensions?": "{ width: number; height: number; }"
    },
    "docs": {
      "chartId": "/** The id of the created chart. */",
      "fileName?": "/** Name of downloaded image file. The chart title will be used by default */",
      "fileFormat?": "/** A string indicating the image format.\n     * The default format type is `image/png`.\n     * Options: `image/png`, `image/jpeg`\n     */",
      "dimensions?": "/** Dimensions of downloaded chart image in pixels. The current chart dimensions will be used if not specified.\n     */"
    }
  },
  "CloseChartToolPanelParams": {
    "meta": {},
    "type": {
      "chartId": "string"
    },
    "docs": {
      "chartId": "/** The id of the created chart. */"
    }
  },
  "ChartModelType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'range' | 'pivot'"
  },
  "OpenChartToolPanelParams": {
    "meta": {},
    "type": {
      "chartId": "string",
      "panel?": "ChartToolPanelName"
    },
    "docs": {
      "chartId": "/** The id of the created chart. */",
      "panel?": "/** Name of the Chart Tool Panel. The default 'Settings' Tool Panel will be used if not specified.*/"
    }
  },
  "ChartModel": {
    "meta": {},
    "type": {
      "version?": "string",
      "modelType": "ChartModelType",
      "chartId": "string",
      "chartType": "ChartType",
      "cellRange": "CellRangeParams",
      "chartThemeName?": "string",
      "chartOptions": "AgChartThemeOverrides",
      "chartPalette?": "AgChartThemePalette",
      "suppressChartRanges?": "boolean",
      "switchCategorySeries?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "unlinkChart?": "boolean",
      "seriesChartTypes?": "SeriesChartType[]",
      "seriesGroupType?": "SeriesGroupType"
    }
  },
  "IChartService": {
    "meta": {},
    "type": {
      "isEnterprise()": "boolean",
      "getChartModels()": "ChartModel[]",
      "getChartRef(chartId: string)": "ChartRef | undefined",
      "createRangeChart(params: CreateRangeChartParams, fromApi?: boolean)": "ChartRef | undefined",
      "createCrossFilterChart(params: CreateCrossFilterChartParams, fromApi?: boolean)": "ChartRef | undefined",
      "createChartFromCurrentRange(chartType: ChartType, fromApi?: boolean)": "ChartRef | undefined",
      "createPivotChart(params: CreatePivotChartParams, fromApi?: boolean)": "ChartRef | undefined",
      "restoreChart(model: ChartModel, chartContainer?: HTMLElement)": "ChartRef | undefined",
      "getChartImageDataURL(params: GetChartImageDataUrlParams)": "string | undefined",
      "downloadChart(params: ChartDownloadParams)": "void",
      "openChartToolPanel(params: OpenChartToolPanelParams)": "void",
      "closeChartToolPanel(chartId: string)": "void",
      "updateChart(params: UpdateChartParams)": "void"
    }
  },
  "BaseCreateChartParams": {
    "meta": {},
    "type": {
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "ChartParamsCellRange": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Partial<Omit<CellRangeParams, 'rowStartPinned' | 'rowEndPinned'>>"
  },
  "CreateRangeChartParams": {
    "meta": {},
    "type": {
      "cellRange": "ChartParamsCellRange",
      "suppressChartRanges?": "boolean",
      "switchCategorySeries?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "seriesChartTypes?": "SeriesChartType[]",
      "seriesGroupType?": "SeriesGroupType",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "cellRange": "/** The range of cells to be charted. If no rows / rowIndexes are specified all rows will be included. */",
      "suppressChartRanges?": "/** Suppress highlighting the selected range in the grid. */",
      "switchCategorySeries?": "/** Switch Category / Series. */",
      "aggFunc?": "/** The aggregation function that should be applied to all series data. */",
      "seriesChartTypes?": "/** The series chart type configurations used in combination charts. */",
      "seriesGroupType?": "/** Group type for chart types that support grouped series. */",
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "CreateCrossFilterChartParams": {
    "meta": {},
    "type": {
      "chartType": "CrossFilterChartType",
      "cellRange": "ChartParamsCellRange",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "chartType": "/** The type of cross-filter chart to create. */",
      "cellRange": "/** The range of cells to be charted. If no rows / rowIndexes are specified all rows will be included. */",
      "suppressChartRanges?": "/** Suppress highlighting the selected range in the grid. */",
      "aggFunc?": "/** The aggregation function that should be applied to all series data. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "CreatePivotChartParams": {
    "meta": {},
    "type": {
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "UpdateChartParams": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "UpdateRangeChartParams | UpdatePivotChartParams | UpdateCrossFilterChartParams"
  },
  "BaseUpdateChartParams": {
    "meta": {},
    "type": {
      "chartId": "string",
      "chartType?": "ChartType",
      "chartThemeName?": "string",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "chartId": "/** The id of the chart to update. */",
      "chartType?": "/** The type of chart to update. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "UpdateRangeChartParams": {
    "meta": {},
    "type": {
      "type": "'rangeChartUpdate'",
      "cellRange?": "ChartParamsCellRange",
      "suppressChartRanges?": "boolean",
      "switchCategorySeries?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "seriesChartTypes?": "SeriesChartType[]",
      "seriesGroupType?": "SeriesGroupType",
      "chartId": "string",
      "chartType?": "ChartType",
      "chartThemeName?": "string",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "cellRange?": "/** The id of the chart to update. */\n/** The range of cells to be charted. If no rows / rowIndexes are specified all rows will be included. */",
      "suppressChartRanges?": "/** Suppress highlighting the selected range in the grid. */",
      "switchCategorySeries?": "/** Switch Category / Series. */",
      "aggFunc?": "/** The aggregation function that should be applied to all series data. */",
      "seriesChartTypes?": "/** The series chart type configurations used in combination charts. */",
      "seriesGroupType?": "/** Group type for chart types that support grouped series. */",
      "chartId": "/** The id of the chart to update. */",
      "chartType?": "/** The type of chart to update. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "UpdatePivotChartParams": {
    "meta": {},
    "type": {
      "type": "'pivotChartUpdate'",
      "chartId": "string",
      "chartType?": "ChartType",
      "chartThemeName?": "string",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "chartId": "/** The id of the chart to update. */",
      "chartType?": "/** The type of chart to update. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "UpdateCrossFilterChartParams": {
    "meta": {},
    "type": {
      "type": "'crossFilterChartUpdate'",
      "cellRange?": "ChartParamsCellRange",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartId": "string",
      "chartType?": "ChartType",
      "chartThemeName?": "string",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "cellRange?": "/** The range of cells to be charted. If no rows / rowIndexes are specified all rows will be included. */",
      "suppressChartRanges?": "/** Suppress highlighting the selected range in the grid. */",
      "aggFunc?": "/** The aggregation function that should be applied to all series data. */",
      "chartId": "/** The id of the chart to update. */",
      "chartType?": "/** The type of chart to update. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "ClientSideRowModelStep": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "`${ClientSideRowModelSteps}`"
  },
  "ClientSideRowModelSteps": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "EVERYTHING = 'group'",
      "FILTER = 'filter'",
      "SORT = 'sort'",
      "MAP = 'map'",
      "AGGREGATE = 'aggregate'",
      "FILTER_AGGREGATES = 'filter_aggregates'",
      "PIVOT = 'pivot'",
      "NOTHING = 'nothing'"
    ],
    "docs": [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    ]
  },
  "IClientSideRowModel": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "onRowGroupOpened()": "void",
      "updateRowData(rowDataTran: RowDataTransaction<TData>, rowNodeOrder?: { [id: string]: number; } | null)": "RowNodeTransaction<TData> | null",
      "setRowData(rowData: any[])": "void",
      "refreshModel(paramsOrStep: RefreshModelParams | ClientSideRowModelStep | undefined)": "void",
      "expandOrCollapseAll(expand: boolean)": "void",
      "forEachLeafNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilter(callback: (node: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "forEachPivotNode(callback: (node: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "resetRowHeights()": "void",
      "onRowHeightChanged()": "void",
      "onRowHeightChangedDebounced()": "void",
      "batchUpdateRowData(rowDataTransaction: RowDataTransaction<TData>, callback?: (res: RowNodeTransaction<TData>) => void)": "void",
      "flushAsyncTransactions()": "void",
      "getRootNode()": "RowNode",
      "doAggregate(changedPath?: ChangedPath)": "void",
      "getTopLevelNodes()": "RowNode[] | null",
      "ensureRowsAtPixel(rowNode: RowNode[], pixel: number, increment: number)": "boolean",
      "highlightRowAtPixel(rowNode: RowNode | null, pixel?: number)": "void",
      "getHighlightPosition(pixel: number, rowNode?: RowNode)": "RowHighlightPosition",
      "getLastHighlightedRowNode()": "RowNode | null",
      "isRowDataLoaded()": "boolean",
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "getType()": "RowModelType",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** Returns the number of rows */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n     * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n     * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n     * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n     *  then no rows should be returned  */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n     * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n     * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n     * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n     * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.\n     */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n     * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "RefreshModelParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "step": "ClientSideRowModelSteps",
      "keepRenderedRows?": "boolean",
      "animate?": "boolean",
      "keepEditingRows?": "boolean",
      "rowNodeTransactions?": "RowNodeTransaction<TData>[]",
      "rowNodeOrder?": "{ [id: string]: number; }",
      "newData?": "boolean",
      "afterColumnsChanged?": "boolean",
      "keepUndoRedoStack?": "boolean"
    }
  },
  "IClipboardCopyParams": {
    "meta": {},
    "type": {
      "includeHeaders?": "boolean",
      "includeGroupHeaders?": "boolean"
    }
  },
  "IClipboardCopyRowsParams": {
    "meta": {},
    "type": {
      "columnKeys?": "(string | Column)[]",
      "includeHeaders?": "boolean",
      "includeGroupHeaders?": "boolean"
    }
  },
  "IClipboardService": {
    "meta": {},
    "type": {
      "pasteFromClipboard()": "void",
      "copyToClipboard(params?: IClipboardCopyParams)": "void",
      "cutToClipboard(params?: IClipboardCopyParams, source?: 'api' | 'ui' | 'contextMenu')": "void",
      "copySelectedRowsToClipboard(params?: IClipboardCopyRowsParams)": "void",
      "copySelectedRangeToClipboard(params?: IClipboardCopyParams)": "void",
      "copyRangeDown()": "void"
    }
  },
  "HeaderColumnId": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "BrandedType<string, 'HeaderColumnId'>"
  },
  "IHeaderColumn": {
    "meta": {
      "typeParams": [
        "TValue",
        "TEventType extends string"
      ]
    },
    "type": {
      "getUniqueId()": "HeaderColumnId",
      "getActualWidth()": "number",
      "getMinWidth()": "number",
      "getLeft()": "number | null",
      "getDefinition()": "AbstractColDef<any, TValue> | null",
      "getColumnGroupShow()": "ColumnGroupShowType | undefined",
      "getParent()": "ColumnGroup | null",
      "isResizable()": "boolean",
      "isEmptyGroup()": "boolean",
      "isMoving()": "boolean",
      "getPinned()": "ColumnPinnedType",
      "addEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void"
    },
    "docs": {
      "getUniqueId()": "/** Returns the unique ID for the column.\n     *\n     */",
      "getActualWidth()": "/** Returns the current width of the column. If the column is resized, the actual width is the new size. */",
      "getMinWidth()": "/** Returns the minWidth of the column or the default min width. */",
      "getLeft()": "/** Returns the left position of the column. */",
      "getDefinition()": "/** Returns the underlying definition. */",
      "getColumnGroupShow()": "/** Returns whether this column should be shown when the group is open / closed or undefined if its always shown. */",
      "getParent()": "/** Returns the parent column group, if column grouping is active. */",
      "isResizable()": "/** Returns `true` if this group is resizable. */",
      "isEmptyGroup()": "/** Returns `true` if this is an empty group. */",
      "isMoving()": "/** Returns `true` while the column is being moved. */",
      "getPinned()": "/** Returns the pinned state of the column. */"
    }
  },
  "IProvidedColumn": {
    "meta": {},
    "type": {
      "isVisible()": "boolean",
      "getInstanceId()": "ColumnInstanceId",
      "getColumnGroupShow()": "ColumnGroupShowType | undefined",
      "getId()": "string"
    },
    "docs": {
      "isVisible()": "/** Returns `true` if the column is visible. */",
      "getInstanceId()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "getColumnGroupShow()": "/** Returns whether this column should be shown when the group is open / closed or undefined if its always shown. */",
      "getId()": "/** Returns the unique ID for the column. */"
    }
  },
  "ColumnPinnedType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'left' | 'right' | boolean | null | undefined"
  },
  "ColumnEventName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'movingChanged' | 'leftChanged' | 'widthChanged' | 'lastLeftPinnedChanged' | 'firstRightPinnedChanged' | 'visibleChanged' | 'filterChanged' | 'filterActiveChanged' | 'sortChanged' | 'colDefChanged' | 'menuVisibleChanged' | 'columnRowGroupChanged' | 'columnPivotChanged' | 'columnValueChanged' | 'columnStateUpdated'"
  },
  "ColumnInstanceId": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "BrandedType<number, 'ColumnInstanceId'>"
  },
  "Column": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "getUserProvidedColDef()": "ColDef<any, TValue> | null",
      "isRowGroupDisplayed(colId: string)": "boolean",
      "isPrimary()": "boolean",
      "isFilterAllowed()": "boolean",
      "isFieldContainsDots()": "boolean",
      "isTooltipEnabled()": "boolean",
      "isTooltipFieldContainsDots()": "boolean",
      "addEventListener(eventType: T, userListener: (params: ColumnEvent<T>) => void)": "void",
      "removeEventListener(eventType: T, userListener: (params: ColumnEvent<T>) => void)": "void",
      "isSuppressNavigable(rowNode: IRowNode)": "boolean",
      "isCellEditable(rowNode: IRowNode)": "boolean",
      "isSuppressFillHandle()": "boolean",
      "isAutoHeight()": "boolean",
      "isAutoHeaderHeight()": "boolean",
      "isRowDrag(rowNode: IRowNode)": "boolean",
      "isDndSource(rowNode: IRowNode)": "boolean",
      "isCellCheckboxSelection(rowNode: IRowNode)": "boolean",
      "isSuppressPaste(rowNode: IRowNode)": "boolean",
      "isMenuVisible()": "boolean",
      "getSort()": "SortDirection | undefined",
      "isSortable()": "boolean",
      "isSortAscending()": "boolean",
      "isSortDescending()": "boolean",
      "isSortNone()": "boolean",
      "isSorting()": "boolean",
      "getSortIndex()": "number | null | undefined",
      "getAggFunc()": "string | IAggFunc | null | undefined",
      "getRight()": "number",
      "isFilterActive()": "boolean",
      "isHovered()": "boolean",
      "isFirstRightPinned()": "boolean",
      "isLastLeftPinned()": "boolean",
      "isPinned()": "boolean",
      "isPinnedLeft()": "boolean",
      "isPinnedRight()": "boolean",
      "isSpanHeaderHeight()": "boolean",
      "getColumnGroupPaddingInfo()": "{ numberOfParents: number; isSpanningTotal: boolean; }",
      "getColDef()": "ColDef<any, TValue>",
      "getColId()": "string",
      "getAutoHeaderHeight()": "number | null",
      "getColSpan(rowNode: IRowNode)": "number",
      "getRowSpan(rowNode: IRowNode)": "number",
      "isGreaterThanMax(width: number)": "boolean",
      "getMaxWidth()": "number",
      "getFlex()": "number",
      "isRowGroupActive()": "boolean",
      "isPivotActive()": "boolean",
      "isAnyFunctionActive()": "boolean",
      "isAnyFunctionAllowed()": "boolean",
      "isValueActive()": "boolean",
      "isAllowPivot()": "boolean",
      "isAllowValue()": "boolean",
      "isAllowRowGroup()": "boolean",
      "isColumn": "true",
      "getUniqueId()": "HeaderColumnId",
      "getActualWidth()": "number",
      "getMinWidth()": "number",
      "getLeft()": "number | null",
      "getDefinition()": "AbstractColDef<any, TValue> | null",
      "getColumnGroupShow()": "ColumnGroupShowType | undefined",
      "getParent()": "ColumnGroup | null",
      "isResizable()": "boolean",
      "isEmptyGroup()": "boolean",
      "isMoving()": "boolean",
      "getPinned()": "ColumnPinnedType",
      "addEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void",
      "isVisible()": "boolean",
      "getInstanceId()": "ColumnInstanceId",
      "getId()": "string"
    },
    "docs": {
      "getUserProvidedColDef()": "/** Returns the column definition provided by the application.\n     * This may not be correct, as items can be superseded by default column options.\n     * However it's useful for comparison, eg to know which application column definition matches that column.\n     */",
      "isRowGroupDisplayed(colId: string)": "/** Returns `true` if this column group is being used to display a row group value. */",
      "isPrimary()": "/** Returns `true` if column is a primary column, `false` if secondary. Secondary columns are used for pivoting. */",
      "isFilterAllowed()": "/** Returns `true` if column filtering is allowed. */",
      "isFieldContainsDots()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "isTooltipEnabled()": "/** Returns `true` if a tooltip is enabled for this column. */",
      "isTooltipFieldContainsDots()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "addEventListener(eventType: T, userListener: (params: ColumnEvent<T>) => void)": "/** Add an event listener to the column. */",
      "removeEventListener(eventType: T, userListener: (params: ColumnEvent<T>) => void)": "/** Remove event listener from the column. */",
      "isSuppressNavigable(rowNode: IRowNode)": "/** Returns `true` if navigation is suppressed for the given column and rowNode. */",
      "isCellEditable(rowNode: IRowNode)": "/** Returns `true` if the cell for this column is editable for the given `rowNode`, otherwise `false`.\n     */",
      "isSuppressFillHandle()": "/** Returns `true` if the fill handle is suppressed. */",
      "isAutoHeight()": "/** Returns `true` if the column has autoHeight enabled. */",
      "isAutoHeaderHeight()": "/** Returns `true` if the column header has autoHeight enabled. */",
      "isRowDrag(rowNode: IRowNode)": "/** Returns `true` if this column and row node can be dragged. */",
      "isDndSource(rowNode: IRowNode)": "/** Returns `true` if this column and row node allows dragging for native drag and drop. */",
      "isCellCheckboxSelection(rowNode: IRowNode)": "/** Returns `true` if this column and row node has checkbox selection. */",
      "isSuppressPaste(rowNode: IRowNode)": "/** Returns `true` if paste is suppress for this column and row node. */",
      "isMenuVisible()": "/** Returns `true` if a menu is visible for this column. */",
      "getSort()": "/** If sorting is active, returns the sort direction e.g. `'asc'` or `'desc'`. */",
      "isSortable()": "/** Returns `true` if sorting is enabled for this column via the `sortable` property. */",
      "isSortAscending()": "/** @deprecated v32 use col.getSort() === 'asc */",
      "isSortDescending()": "/** @deprecated v32 use col.getSort() === 'desc */",
      "isSortNone()": "/** @deprecated v32 use col.getSort() === undefined */",
      "isSorting()": "/** @deprecated v32 use col.getSort() !== undefined */",
      "getSortIndex()": "/** Returns the sort index for this column. */",
      "getAggFunc()": "/** If aggregation is set for the column, returns the aggregation function. */",
      "getRight()": "/** @deprecated v32 Use col.getLeft() + col.getActualWidth() instead. */",
      "isFilterActive()": "/** Returns `true` if filter is active on the column. */",
      "isHovered()": "/** Returns `true` when this `Column` is hovered, otherwise `false` */",
      "isFirstRightPinned()": "/** Returns `true` if this column is the first right pinned column. */",
      "isLastLeftPinned()": "/** Returns `true` if this column is the last left pinned column. */",
      "isPinned()": "/** Returns `true` if this column is pinned either left of right. */",
      "isPinnedLeft()": "/** Returns `true` if this column is pinned left. */",
      "isPinnedRight()": "/** Returns `true` if this column is pinned right. */",
      "isSpanHeaderHeight()": "/** Returns `true` if this column spans the header height. */",
      "getColumnGroupPaddingInfo()": "/** Returns column group padding info. */",
      "getColDef()": "/** Returns the column definition for this column.\n     * The column definition will be the result of merging the application provided column definition with any provided defaults\n     * (e.g. `defaultColDef` grid option, or column types.\n     *\n     * Equivalent: `getDefinition` */",
      "getColId()": "/** Returns the unique ID for the column.\n     *\n     * Equivalent: `getId`, `getUniqueId` */",
      "getAutoHeaderHeight()": "/** Returns the auto header height. */",
      "getColSpan(rowNode: IRowNode)": "/** Returns the column span for this column and row node. */",
      "getRowSpan(rowNode: IRowNode)": "/** Returns the row span for this column and row node. */",
      "isGreaterThanMax(width: number)": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "getMaxWidth()": "/** Returns the max width for the column. */",
      "getFlex()": "/** Returns the `flex` value of the column or 0 if not set.  */",
      "isRowGroupActive()": "/** Returns `true` if row group is currently active for this column. */",
      "isPivotActive()": "/** Returns `true` if pivot is currently active for this column. */",
      "isAnyFunctionActive()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "isAnyFunctionAllowed()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "isValueActive()": "/** Returns `true` if value (aggregation) is currently active for this column. */",
      "isAllowPivot()": "/** Returns `true` if pivoting is allowed for this column */",
      "isAllowValue()": "/** Returns `true` if this column can be used as a value column. */",
      "isAllowRowGroup()": "/** Returns `true` if this column can be used as a row group column. */",
      "isColumn": "/** isColumn is always `true`. Used to distinguish between columns and column groups.  */",
      "getUniqueId()": "/** Returns the unique ID for the column.\n     *\n     */",
      "getActualWidth()": "/** Returns the current width of the column. If the column is resized, the actual width is the new size. */",
      "getMinWidth()": "/** Returns the minWidth of the column or the default min width. */",
      "getLeft()": "/** Returns the left position of the column. */",
      "getDefinition()": "/** Returns the underlying definition. */",
      "getColumnGroupShow()": "/** Returns whether this column should be shown when the group is open / closed or undefined if its always shown. */",
      "getParent()": "/** Returns the parent column group, if column grouping is active. */",
      "isResizable()": "/** Returns `true` if this group is resizable. */",
      "isEmptyGroup()": "/** Returns `true` if this is an empty group. */",
      "isMoving()": "/** Returns `true` while the column is being moved. */",
      "getPinned()": "/** Returns the pinned state of the column. */",
      "isVisible()": "/** Returns `true` if the column is visible. */",
      "getInstanceId()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "getId()": "/** Returns the unique ID for the column. */"
    }
  },
  "ColumnGroupShowType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'open' | 'closed'"
  },
  "AgColumnGroupEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'leftChanged' | 'displayedChildrenChanged'"
  },
  "ColumnGroup": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "getGroupId()": "string",
      "getPartId()": "number",
      "isResizable()": "boolean",
      "getDisplayedChildren()": "(Column | ColumnGroup)[] | null",
      "getLeafColumns()": "Column[]",
      "getDisplayedLeafColumns()": "Column[]",
      "getColGroupDef()": "ColGroupDef | null",
      "isPadding()": "boolean",
      "getPaddingLevel()": "number",
      "isExpandable()": "boolean",
      "isExpanded()": "boolean",
      "getChildren()": "(Column | ColumnGroup)[] | null",
      "getProvidedColumnGroup()": "ProvidedColumnGroup",
      "isColumn": "false",
      "getUniqueId()": "HeaderColumnId",
      "getActualWidth()": "number",
      "getMinWidth()": "number",
      "getLeft()": "number | null",
      "getDefinition()": "AbstractColDef<any, TValue> | null",
      "getColumnGroupShow()": "ColumnGroupShowType | undefined",
      "getParent()": "ColumnGroup | null",
      "isEmptyGroup()": "boolean",
      "isMoving()": "boolean",
      "getPinned()": "ColumnPinnedType",
      "addEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void"
    },
    "docs": {
      "getGroupId()": "/** Returns the group column id. */",
      "getPartId()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "isResizable()": "/** Returns `true` if this group is resizable. */",
      "getDisplayedChildren()": "/** Returns the displayed children of this group. */",
      "getLeafColumns()": "/** Returns the leaf columns of this group. */",
      "getDisplayedLeafColumns()": "/** Returns the displayed leaf columns of this group. */",
      "getColGroupDef()": "/** Returns the column group definition for this column.\n     * The column group definition will be the result of merging the application provided column group definition with any provided defaults\n     * (e.g. `defaultColGroupDef` grid option.\n     */",
      "isPadding()": "/** Returns `true` if this column group is a padding group that is used to correctly align column groups / children. */",
      "getPaddingLevel()": "/** Returns the padding level of this padding group. */",
      "isExpandable()": "/** Returns `true` if this column group is expandable. */",
      "isExpanded()": "/** Returns `true` if this column group is expanded. */",
      "getChildren()": "/** Returns the children of this group if they exist or `null` */",
      "getProvidedColumnGroup()": "/** Returns the provided column group */",
      "isColumn": "/** isColumn is always `false`. Used to distinguish between columns and column groups.  */",
      "getUniqueId()": "/** Returns the unique ID for the column.\n     *\n     */",
      "getActualWidth()": "/** Returns the current width of the column. If the column is resized, the actual width is the new size. */",
      "getMinWidth()": "/** Returns the minWidth of the column or the default min width. */",
      "getLeft()": "/** Returns the left position of the column. */",
      "getDefinition()": "/** Returns the underlying definition. */",
      "getColumnGroupShow()": "/** Returns whether this column should be shown when the group is open / closed or undefined if its always shown. */",
      "getParent()": "/** Returns the parent column group, if column grouping is active. */",
      "isEmptyGroup()": "/** Returns `true` if this is an empty group. */",
      "isMoving()": "/** Returns `true` while the column is being moved. */",
      "getPinned()": "/** Returns the pinned state of the column. */"
    }
  },
  "ProvidedColumnGroup": {
    "meta": {},
    "type": {
      "getOriginalParent()": "ProvidedColumnGroup | null",
      "getLevel()": "number",
      "isPadding()": "boolean",
      "isExpandable()": "boolean",
      "isExpanded()": "boolean",
      "getGroupId()": "string",
      "getChildren()": "(Column | ProvidedColumnGroup)[]",
      "getColGroupDef()": "ColGroupDef | null",
      "getLeafColumns()": "Column[]",
      "isColumn": "false",
      "isVisible()": "boolean",
      "getInstanceId()": "ColumnInstanceId",
      "getColumnGroupShow()": "ColumnGroupShowType | undefined",
      "getId()": "string",
      "addEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void"
    },
    "docs": {
      "getOriginalParent()": "/** Used for marryChildren, helps with comparing when duplicate groups have been created to manage split groups.\n     *\n     * Parent may contain a duplicate but not identical group when the group is split.\n     */",
      "getLevel()": "/** Returns the level of this group. */",
      "isPadding()": "/** Returns `true` if this column group is a padding group that is used to correctly align column groups / children. */",
      "isExpandable()": "/** Returns `true` if this column group is expandable. */",
      "isExpanded()": "/** Returns `true` if this column group is expanded. */",
      "getGroupId()": "/** Returns the group column id. */",
      "getChildren()": "/** Returns the children of this group. */",
      "getColGroupDef()": "/** Returns the column group definition for this column.\n     * The column group definition will be the result of merging the application provided column group definition with any provided defaults\n     * (e.g. `defaultColGroupDef` grid option.\n     */",
      "getLeafColumns()": "/** Returns the leaf columns of this group. */",
      "isColumn": "/** isColumn is always `false`. Used to distinguish between columns and column groups.  */",
      "isVisible()": "/** Returns `true` if the column is visible. */",
      "getInstanceId()": "/** @deprecated v32 Internal method no longer to be exposed on Column interface. */",
      "getColumnGroupShow()": "/** Returns whether this column should be shown when the group is open / closed or undefined if its always shown. */",
      "getId()": "/** Returns the unique ID for the column. */"
    }
  },
  "ShowColumnChooserParams": {
    "meta": {},
    "type": {
      "column?": "AgColumn | null",
      "chooserParams?": "ColumnChooserParams",
      "eventSource?": "HTMLElement"
    }
  },
  "IColumnChooserFactory": {
    "meta": {},
    "type": {
      "showColumnChooser(params: ShowColumnChooserParams)": "void",
      "hideActiveColumnChooser()": "void"
    }
  },
  "IColumnToolPanel": {
    "meta": {},
    "type": {
      "expandColumnGroups(groupIds?: string[])": "void",
      "collapseColumnGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void",
      "setPivotModeSectionVisible(visible: boolean)": "void",
      "setRowGroupsSectionVisible(visible: boolean)": "void",
      "setValuesSectionVisible(visible: boolean)": "void",
      "setPivotSectionVisible(visible: boolean)": "void",
      "getState()": "ColumnToolPanelState",
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "boolean | void",
      "getState?()": "TState | undefined"
    },
    "docs": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "/** Called when `api.refreshToolPanel()` is called (with the current params).\n     * Also called when the `sideBar` grid option is updated (with the updated params).\n     * When `sideBar` is updated, if this method returns `true`,\n     * then the grid will take no further action.\n     * Otherwise, the tool panel will be destroyed and recreated.\n     */",
      "getState?()": "/** If saving and restoring state, this should return the current state */"
    }
  },
  "ColumnVO": {
    "meta": {},
    "type": {
      "id": "string",
      "displayName": "string",
      "field?": "string",
      "aggFunc?": "string"
    }
  },
  "WithoutGridCommon": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "Omit<T, keyof AgGridCommon<any, any>>"
  },
  "AgGridCommon": {
    "meta": {
      "typeParams": [
        "TData",
        "TContext"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IComponent": {
    "meta": {
      "typeParams": [
        "T"
      ],
      "doc": "/** This is for User Components only, do not implement this for internal components. */"
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: T)": "/** The init(params) method is called on the component once. */"
    }
  },
  "IContextMenuFactory": {
    "meta": {},
    "type": {
      "onContextMenu(mouseEvent: MouseEvent | null, touchEvent: TouchEvent | null, rowNode: RowNode | null, column: AgColumn | null, value: any, anchorToElement: HTMLElement)": "void",
      "hideActiveMenu()": "void"
    }
  },
  "ICsvCreator": {
    "meta": {},
    "type": {
      "getDataAsCsv(params?: CsvExportParams, skipDefaultParams?: boolean)": "string",
      "exportDataAsCsv(params?: CsvExportParams)": "void"
    }
  },
  "IDatasource": {
    "meta": {
      "doc": "/** Datasource used by both PaginationController and InfiniteRowModel */"
    },
    "type": {
      "rowCount?": "number",
      "getRows(params: IGetRowsParams)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "rowCount?": "/** If you know up front how many rows are in the dataset, set it here. Otherwise leave blank. */",
      "getRows(params: IGetRowsParams)": "/** Callback the grid calls that you implement to fetch rows from the server. */",
      "destroy?()": "/** Optional destroy method, if your datasource has state it needs to clean up. */"
    }
  },
  "IGetRowsParams": {
    "meta": {
      "doc": "/** Params for the above IDatasource.getRows() */"
    },
    "type": {
      "startRow": "number",
      "endRow": "number",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "void",
      "failCallback()": "void",
      "sortModel": "SortModelItem[]",
      "filterModel": "any",
      "context": "any"
    },
    "docs": {
      "startRow": "/** The first row index to get. */",
      "endRow": "/** The first row index to NOT get. */",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "/** Callback to call for the result when successful. */",
      "failCallback()": "/** Callback to call when the request fails. */",
      "sortModel": "/** If doing server side sorting, contains the sort model */",
      "filterModel": "/** If doing server side filtering, contains the filter model */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IDetailGridApiService": {
    "meta": {},
    "type": {
      "addDetailGridInfo(id: string, gridInfo: DetailGridInfo)": "void",
      "removeDetailGridInfo(id: string)": "void",
      "getDetailGridInfo(id: string)": "DetailGridInfo | undefined",
      "forEachDetailGridInfo(callback: (gridInfo: DetailGridInfo, index: number) => void)": "void"
    }
  },
  "EventTypeMap": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T extends string = any"
      ]
    },
    "type": "{[K in T]: AgEvent<K>}"
  },
  "BuildEventTypeMap": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TEventTypes extends string",
        "T extends {\n    [K in TEventTypes]: AgEvent<K>;\n}"
      ]
    },
    "type": "T"
  },
  "IEventListener": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TEventType extends string"
      ]
    },
    "type": "(params: AgEvent<TEventType>) => void"
  },
  "IGlobalEventListener": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TEventType extends string"
      ]
    },
    "type": "(eventType: TEventType, event: AgEvent<TEventType>) => void"
  },
  "IEventEmitter": {
    "meta": {
      "typeParams": [
        "TEventType extends string"
      ]
    },
    "type": {
      "addEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: TEventType, listener: IEventListener<TEventType>, async?: boolean, options?: AddEventListenerOptions)": "void"
    }
  },
  "ExcelStyle": {
    "meta": {},
    "type": {
      "id": "string",
      "alignment?": "ExcelAlignment",
      "borders?": "ExcelBorders",
      "dataType?": "ExcelDataType",
      "font?": "ExcelFont",
      "interior?": "ExcelInterior",
      "numberFormat?": "ExcelNumberFormat",
      "protection?": "ExcelProtection",
      "name?": "string"
    },
    "docs": {
      "id": "/** The id of the Excel Style, this should match a CSS cell class. */",
      "alignment?": "/** Use this property to customise cell alignment properties. */",
      "borders?": "/** Use this property to customise cell borders. */",
      "dataType?": "/** Use this property to specify the type of data being exported. */",
      "font?": "/** Use this property to customise the font used in the cell. */",
      "interior?": "/** Use this property to customise the cell background. */",
      "numberFormat?": "/** Use this property to customise the cell value as a formatted number. */",
      "protection?": "/** Use this property to setup cell protection. */",
      "name?": "/** @deprecated Legacy property\n     */"
    }
  },
  "ExcelAlignment": {
    "meta": {},
    "type": {
      "horizontal?": "'Automatic' | 'Left' | 'Center' | 'Right' | 'Fill' | 'Justify' | 'CenterAcrossSelection' | 'Distributed' | 'JustifyDistributed'",
      "indent?": "number",
      "readingOrder?": "'RightToLeft' | 'LeftToRight' | 'Context'",
      "rotate?": "number",
      "shrinkToFit?": "boolean",
      "vertical?": "'Automatic' | 'Top' | 'Bottom' | 'Center' | 'Justify' | 'Distributed' | 'JustifyDistributed'",
      "wrapText?": "boolean",
      "verticalText?": "boolean"
    },
    "docs": {
      "horizontal?": "/** Use this property to change the cell horizontal alignment.\n     * @default 'Automatic'\n     */",
      "indent?": "/** Use this property to change the level of indentation in the cell.\n     * @default 0\n     */",
      "readingOrder?": "/** Use this property to change the cell reading order.\n     * @default 'LeftToRight'\n     */",
      "rotate?": "/** The number of degrees between 0 and 359 to rotate the text.\n     * @default 0\n     */",
      "shrinkToFit?": "/** If set to `true`, the font size of the cell will automatically change to force the text to fit within the cell.\n     * @default false\n     */",
      "vertical?": "/** Use this property to change the cell vertical alignment.\n     * @default 'Automatic'\n     */",
      "wrapText?": "/** If set to `true`, multiline text will be displayed as multiline by Excel.\n     * @default false\n     */",
      "verticalText?": "/** @deprecated Legacy property\n     */"
    }
  },
  "ExcelBorders": {
    "meta": {},
    "type": {
      "borderBottom?": "ExcelBorder",
      "borderLeft?": "ExcelBorder",
      "borderRight?": "ExcelBorder",
      "borderTop?": "ExcelBorder"
    },
    "docs": {
      "borderBottom?": "/** Use to set the cell's bottom border. */",
      "borderLeft?": "/** Use to set the cell's left border. */",
      "borderRight?": "/** Use to set the cell's right border. */",
      "borderTop?": "/** Use to set the cell's top border. */"
    }
  },
  "ExcelBorder": {
    "meta": {},
    "type": {
      "color?": "string",
      "lineStyle?": "'None' | 'Continuous' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot' | 'SlantDashDot' | 'Double'",
      "weight?": "0 | 1 | 2 | 3"
    },
    "docs": {
      "color?": "/** The color or the border.\n     * @default 'black'\n     */",
      "lineStyle?": "/** The style of the border.\n     * @default 'None'\n     */",
      "weight?": "/** The thickness of the border from 0 (thin) to 3 (thick).\n     * @default 0\n     */"
    }
  },
  "ExcelFont": {
    "meta": {},
    "type": {
      "bold?": "boolean",
      "color?": "string",
      "family?": "string",
      "fontName?": "string",
      "italic?": "boolean",
      "outline?": "boolean",
      "shadow?": "boolean",
      "size?": "number",
      "strikeThrough?": "boolean",
      "underline?": "'Single' | 'Double'",
      "verticalAlign?": "'Superscript' | 'Subscript'",
      "charSet?": "number"
    },
    "docs": {
      "bold?": "/** Set to `true` to set the cell text to bold.\n     * @default false\n     */",
      "color?": "/** The color of the cell font.\n     * @default '#000000'\n     */",
      "family?": "/** The family of the font to used in the cell.\n     * Options: `Automatic`,`Roman`,`Swiss`,`Modern`,`Script`,`Decorative`,\n     * @default 'Automatic'\n     */",
      "fontName?": "/** The name of the font to be used in the cell.\n     * @default 'Calibri'\n     */",
      "italic?": "/** Set to `true` to display the cell font as italic.\n     * @default false\n     */",
      "outline?": "/** Set to `true` to add a text outline.\n     * @default false\n     */",
      "shadow?": "/** Set to `true` to add text shadow.\n     * @default false\n     */",
      "size?": "/** Set this property to used a different font size other than the default.\n     */",
      "strikeThrough?": "/** Set to `true` to add a strikeThrough line.\n     * @default false\n     */",
      "underline?": "/** Use this property to underline the cell text.\n     */",
      "verticalAlign?": "/** Use this property to change the default font alignment. Note: This is different than setting cell vertical alignment. */",
      "charSet?": "/** @deprecated Legacy property\n     */"
    }
  },
  "ExcelInterior": {
    "meta": {},
    "type": {
      "pattern": "'None' | 'Solid' | 'Gray75' | 'Gray50' | 'Gray25' | 'Gray125' | 'Gray0625' | 'HorzStripe' | 'VertStripe' | 'ReverseDiagStripe' | 'DiagStripe' | 'DiagCross' | 'ThickDiagCross' | 'ThinHorzStripe' | 'ThinVertStripe' | 'ThinReverseDiagStripe' | 'ThinDiagStripe' | 'ThinHorzCross' | 'ThinDiagCross'",
      "color?": "string",
      "patternColor?": "string"
    },
    "docs": {
      "pattern": "/** Use this property to set background color patterns. */",
      "color?": "/** The colour to be used as a secondary colour combined with patterns. */",
      "patternColor?": "/** The pattern color. */"
    }
  },
  "ExcelNumberFormat": {
    "meta": {},
    "type": {
      "format": "string"
    },
    "docs": {
      "format": "/** Use this property to provide a pattern to format a number. (eg. 10000 could become $10,000.00). */"
    }
  },
  "ExcelProtection": {
    "meta": {},
    "type": {
      "protected": "boolean",
      "hideFormula": "boolean"
    },
    "docs": {
      "protected": "/** Set to `false` to disable cell protection (locking)\n     * @default true\n     */",
      "hideFormula": "/** Set to `true` to hide formulas within protected cells.\n     * @default false\n     */"
    }
  },
  "ExcelWorksheet": {
    "meta": {},
    "type": {
      "name": "string",
      "table": "ExcelTable"
    }
  },
  "ExcelTable": {
    "meta": {},
    "type": {
      "columns": "ExcelColumn[]",
      "rows": "ExcelRow[]"
    }
  },
  "ExcelColumn": {
    "meta": {},
    "type": {
      "min?": "number",
      "max?": "number",
      "outlineLevel?": "number",
      "width?": "number",
      "s?": "number",
      "hidden?": "boolean",
      "bestFit?": "boolean",
      "displayName?": "string",
      "filterAllowed?": "boolean"
    }
  },
  "ExcelRow": {
    "meta": {},
    "type": {
      "collapsed?": "boolean",
      "hidden?": "boolean",
      "height?": "number",
      "outlineLevel?": "number",
      "cells": "ExcelCell[]"
    },
    "docs": {
      "collapsed?": "/** Collapsed state. */",
      "hidden?": "/** Hidden state. */",
      "height?": "/** The height of the row. */",
      "outlineLevel?": "/** The indentation level if the current row is part of a row group. */",
      "cells": "/** An array of ExcelCells. */"
    }
  },
  "ExcelCell": {
    "meta": {},
    "type": {
      "data?": "ExcelData",
      "ref?": "string",
      "collapsibleRanges?": "number[][]",
      "styleId?": "string | string[]",
      "mergeAcross?": "number"
    },
    "docs": {
      "data?": "/** The data that will be added to the cell. */",
      "ref?": "/** Cell reference. */",
      "collapsibleRanges?": "/** Collapsible ranges. */",
      "styleId?": "/** The ExcelStyle id to be associated with the cell. */",
      "mergeAcross?": "/** The number of cells to span across (1 means span 2 columns).\n     * @default 0\n     */"
    }
  },
  "ExcelImagePosition": {
    "meta": {},
    "type": {
      "row?": "number",
      "rowSpan?": "number",
      "column?": "number",
      "colSpan?": "number",
      "offsetX?": "number",
      "offsetY?": "number"
    },
    "docs": {
      "row?": "/** The row containing this image. This property is set automatically, don't change it unless you know what you are doing. */",
      "rowSpan?": "/** The amount of rows this image will cover.\n     * @default 1\n     *  */",
      "column?": "/** The column containing this image. This property is set automatically, don't change it unless you know what you are doing. */",
      "colSpan?": "/** The amount of columns this image will cover.\n     * @default 1\n     */",
      "offsetX?": "/** The amount in pixels the image should be offset horizontally.\n     * @default 0\n     */",
      "offsetY?": "/** The amount in pixels the image should be offset vertically.\n     * @default 0\n     */"
    }
  },
  "BaseImage": {
    "meta": {},
    "type": {
      "id": "string",
      "base64": "string",
      "imageType": "'jpg' | 'png' | 'gif'",
      "altText?": "string"
    },
    "docs": {
      "id": "/** The image `id`. This field is required so the same image doesn't get imported multiple times.\n     */",
      "base64": "/** A base64 string that represents the image being imported.\n     */",
      "imageType": "/** The type of image being exported. */",
      "altText?": "/** Alt Text for the image. */"
    }
  },
  "ExcelHeaderFooterImage": {
    "meta": {},
    "type": {
      "recolor?": "'Grayscale' | 'Black & White' | 'Washout'",
      "width": "number",
      "height": "number",
      "brightness": "number",
      "contrast": "number",
      "id": "string",
      "base64": "string",
      "imageType": "'jpg' | 'png' | 'gif'",
      "altText?": "string"
    },
    "docs": {
      "recolor?": "/** Set this property to select a preset that changes the appearance of the image. */",
      "width": "/** The width of the image in pixels. */",
      "height": "/** The height of the image in pixels. */",
      "brightness": "/** The brightness of the image between 0 and 100 (if `recolor` is used, this value will only be applied for `Grayscale`). Default 50 */",
      "contrast": "/** The contrast of the image between 0 and 100. (If `recolor` is used, this value will only be applied for `Grayscale`.). Default 50 */",
      "id": "/** The image `id`. This field is required so the same image doesn't get imported multiple times.\n     */",
      "base64": "/** A base64 string that represents the image being imported.\n     */",
      "imageType": "/** The type of image being exported. */",
      "altText?": "/** Alt Text for the image. */"
    }
  },
  "ExcelImage": {
    "meta": {},
    "type": {
      "fitCell?": "boolean",
      "transparency?": "number",
      "rotation?": "number",
      "recolor?": "'Grayscale' | 'Sepia' | 'Washout'",
      "width?": "number",
      "height?": "number",
      "position?": "ExcelImagePosition",
      "id": "string",
      "base64": "string",
      "imageType": "'jpg' | 'png' | 'gif'",
      "altText?": "string"
    },
    "docs": {
      "fitCell?": "/** If set to `true`, the image will cover the whole cell that is being imported to.\n     * This property does not apply to images in the Header/Footer\n     * @default false\n     */",
      "transparency?": "/** Set a value between 0 - 100 that will indicate the percentage of transparency of the image.\n     * @default 0\n     */",
      "rotation?": "/** Set a value between 0 - 359 that will indicate the number of degrees to rotate the image clockwise.\n     * @default 0\n     */",
      "recolor?": "/** Set this property to select a preset that changes the appearance of the image. */",
      "width?": "/** The width of the image in pixels. If this value is not selected, `fitCell` will be automatically set to true. */",
      "height?": "/** The height of the image in pixels. If this value is not selected, `fitCell` will be automatically set to true. */",
      "position?": "/** Position of the image. */",
      "id": "/** The image `id`. This field is required so the same image doesn't get imported multiple times.\n     */",
      "base64": "/** A base64 string that represents the image being imported.\n     */",
      "imageType": "/** The type of image being exported. */",
      "altText?": "/** Alt Text for the image. */"
    }
  },
  "ExcelDataType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'String' | 'Formula' | 'Number' | 'Boolean' | 'DateTime' | 'Error'"
  },
  "ExcelOOXMLDataType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'str' | 's' | 'f' | 'inlineStr' | 'n' | 'b' | 'd' | 'e' | 'empty'"
  },
  "ExcelData": {
    "meta": {},
    "type": {
      "type": "ExcelDataType | ExcelOOXMLDataType",
      "value": "string | null"
    },
    "docs": {
      "type": "/** The type of data being in the cell. */",
      "value": "/** The value of the cell. */"
    }
  },
  "ExcelRelationship": {
    "meta": {},
    "type": {
      "Id": "string",
      "Type": "string",
      "Target": "string"
    }
  },
  "ExcelContentType": {
    "meta": {},
    "type": {
      "name": "'Default' | 'Override'",
      "ContentType": "string",
      "Extension?": "string",
      "PartName?": "string"
    }
  },
  "ExcelOOXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(config?: any, idx?: number, currentSheet?: number)": "XmlElement",
      "convertType?(type: string)": "string"
    }
  },
  "ExcelFactoryMode": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "SINGLE_SHEET",
      "MULTI_SHEET"
    ],
    "docs": [
      null,
      null
    ]
  },
  "ExcelSheetNameGetterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ExcelSheetNameGetter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params?: ExcelSheetNameGetterParams) => string"
  },
  "ColumnWidthCallbackParams": {
    "meta": {},
    "type": {
      "column": "Column | null",
      "index": "number"
    }
  },
  "RowHeightCallbackParams": {
    "meta": {},
    "type": {
      "rowIndex": "number"
    }
  },
  "ExcelExportParams": {
    "meta": {},
    "type": {
      "author?": "string",
      "autoConvertFormulas?": "boolean",
      "columnWidth?": "number | ((params: ColumnWidthCallbackParams) => number)",
      "fontSize?": "number",
      "headerRowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "rowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "sheetName?": "string | ExcelSheetNameGetter",
      "margins?": "ExcelSheetMargin",
      "pageSetup?": "ExcelSheetPageSetup",
      "exportAsExcelTable?": "boolean | ExcelTableConfig",
      "headerFooterConfig?": "ExcelHeaderFooterConfig",
      "suppressRowOutline?": "boolean",
      "suppressColumnOutline?": "boolean",
      "rowGroupExpandState?": "'expanded' | 'collapsed' | 'match'",
      "mimeType?": "string",
      "addImageToCell?": "(rowIndex: number, column: Column, value: string) => { image: ExcelImage; value?: string; } | undefined",
      "prependContent?": "ExcelRow[]",
      "appendContent?": "ExcelRow[]",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => ExcelRow[] | undefined",
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "rowPositions?": "RowPosition[]",
      "fileName?": "string | ExportFileNameGetter",
      "exportedRows?": "'all' | 'filteredAndSorted'",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string"
    },
    "docs": {
      "author?": "/** The author of the exported file.\n     * @default \"AG Grid\"\n     * */",
      "autoConvertFormulas?": "/** If set to `true`, this will try to convert any cell that starts with `=` to a formula, instead of setting the cell value as regular string that starts with `=`.\n     * @default false\n     */",
      "columnWidth?": "/** Defines the default column width. If no value is present, each column will have value currently set in the application with a min value of 75px. This property can also be supplied a callback function that returns a number.\n     */",
      "fontSize?": "/** The default value for the font size of the Excel document.\n     * @default 11\n     */",
      "headerRowHeight?": "/** The height in pixels of header rows. Defaults to Excel default value. This property can also be supplied a callback function that returns a number.\n     */",
      "rowHeight?": "/** The height in pixels of all rows. Defaults to Excel default value. This property can also be supplied a callback function that returns a number.\n     */",
      "sheetName?": "/** The name of the sheet in Excel where the grid will be exported. Either a string or a function that returns a\n     * string can be used. If a function is used, it will be called once before the export starts.\n     * There is a max limit of 31 characters per sheet name.\n     * @default 'ag-grid'\n     */",
      "margins?": "/** The Excel document page margins. Relevant for printing. */",
      "pageSetup?": "/** Allows you to setup the page orientation and size. */",
      "exportAsExcelTable?": "/** Used to add an Excel table to the spreadsheet.\n     * Set to `true` to use default export table config, or provide a config object.\n     *\n     * @default false\n     **/",
      "headerFooterConfig?": "/** The configuration for header and footers. */",
      "suppressRowOutline?": "/** If `true`, the outline (controls to expand and collapse) for Row Groups will not be added automatically to the Excel Document.\n     * @default false.\n     */",
      "suppressColumnOutline?": "/** If `true`, the outline (controls to expand and collapse) for Group Columns will not be added automatically to the Excel Document.\n     * @default false.\n     */",
      "rowGroupExpandState?": "/** The expand/collapse state of each row group in the Excel Document.\n     *  - expanded: All row groups will be expanded by default.\n     *  - collapsed: All row groups will be collapsed by default.\n     *  - match: The row groups will match their current state in the Grid.\n     * @default 'expanded'\n     */",
      "mimeType?": "/** The mimeType of the Excel file.\n     * @default 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n     */",
      "addImageToCell?": "/** Use to export an image for the gridCell in question. */",
      "prependContent?": "/** Content to put at the top of the exported sheet.\n     */",
      "appendContent?": "/** Content to put at the bottom of the exported sheet.\n     */",
      "getCustomContentBelowRow?": "/** A callback function to return content to be inserted below a row in the export. */",
      "allColumns?": "/** If `true`, all columns will be exported in the order they appear in the columnDefs.\n     * When `false` only the columns currently being displayed will be exported.\n     * @default false\n     */",
      "columnKeys?": "/** Provide a list (an array) of column keys or Column objects if you want to export specific columns.\n     */",
      "rowPositions?": "/** Row node positions. */",
      "fileName?": "/** String to use as the file name or a function that returns a string.\n     */",
      "exportedRows?": "/** Determines whether rows are exported before being filtered and sorted.\n     * @default 'filteredAndSorted'\n     */",
      "onlySelected?": "/** Export only selected rows.\n     * @default false\n     */",
      "onlySelectedAllPages?": "/** Only export selected rows including other pages (only makes sense when using pagination).\n     * @default false\n     */",
      "skipColumnGroupHeaders?": "/** Set to `true` to exclude header column groups.\n     * @default false\n     */",
      "skipColumnHeaders?": "/** Set to `true` if you don't want to export column headers.\n     * @default false\n     */",
      "skipRowGroups?": "/** Set to `true` to skip row group headers if grouping rows. Only relevant when grouping rows.\n     * @default false\n     */",
      "skipPinnedTop?": "/** Set to `true` to suppress exporting rows pinned to the top of the grid.\n     * @default false\n     */",
      "skipPinnedBottom?": "/** Set to `true` to suppress exporting rows pinned to the bottom of the grid.\n     * @default false\n     */",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "/** A callback function that will be invoked once per row in the grid. Return true to omit the row from the export.\n     */",
      "processCellCallback?(params: ProcessCellForExportParams)": "/** A callback function invoked once per cell in the grid. Return a string value to be displayed in the export. For example this is useful for formatting date values.\n     */",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "/** A callback function invoked once per column. Return a string to be displayed in the column header.\n     */",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "/** A callback function invoked once per column group. Return a `string` to be displayed in the column group header.\n     * Note that column groups are exported by default, this option will not work with `skipColumnGroupHeaders=true`.\n     */",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "/** A callback function invoked once per row group. Return a `string` to be displayed in the group cell.\n     */"
    }
  },
  "ExcelExportMultipleSheetParams": {
    "meta": {},
    "type": {
      "author?": "string",
      "data": "string[]",
      "fileName?": "string | ExportFileNameGetter",
      "fontSize?": "number",
      "mimeType?": "string"
    },
    "docs": {
      "author?": "/** The author of the exported file.\n     * @default 'AG Grid'\n     */",
      "data": "/** Array of strings containing the raw data for Excel workbook sheets.\n     * This property is only used when exporting to multiple sheets using `api.exportMultipleSheetsAsExcel()` and the data for each sheet is obtained by calling `api.getSheetDataForExcel()`.\n     */",
      "fileName?": "/** String to use as the file name or a function that returns a string.\n     * @default 'export.xlsx'\n     */",
      "fontSize?": "/** The default value for the font size of the Excel document.\n     * @default 11\n     */",
      "mimeType?": "/** The mimeType of the Excel file.\n     * @default 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n     */"
    }
  },
  "ExcelHeaderFooterConfig": {
    "meta": {},
    "type": {
      "all?": "ExcelHeaderFooter",
      "first?": "ExcelHeaderFooter",
      "even?": "ExcelHeaderFooter"
    },
    "docs": {
      "all?": "/** The configuration for header and footer on every page. */",
      "first?": "/** The configuration for header and footer on the first page only. */",
      "even?": "/** The configuration for header and footer on even numbered pages only. */"
    }
  },
  "ExcelHeader": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ header: ExcelHeaderFooterContent[]; }"
  },
  "ExcelFooter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ footer: ExcelHeaderFooterContent[]; }"
  },
  "ExcelHeaderFooter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "ExcelFooter | ExcelHeader | (ExcelFooter & ExcelHeader)"
  },
  "ExcelHeaderFooterContent": {
    "meta": {},
    "type": {
      "value": "string",
      "image?": "ExcelHeaderFooterImage",
      "position?": "'Left' | 'Center' | 'Right'",
      "font?": "ExcelFont"
    },
    "docs": {
      "value": "/** The value of the text to be included in the header. */",
      "image?": "/** When value is `&[Picture]`, this should be used as the referenced image.\n     */",
      "position?": "/** Configures where the text should be added: `Left`, `Center` or `Right`.\n     * @default 'Left'\n     */",
      "font?": "/** The font style of the header/footer value. */"
    }
  },
  "IExcelCreator": {
    "meta": {},
    "type": {
      "getDataAsExcel(params?: ExcelExportParams)": "Blob | string | undefined",
      "getSheetDataForExcel(params?: ExcelExportParams)": "string",
      "getMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "Blob | undefined",
      "exportDataAsExcel(params?: ExcelExportParams)": "void",
      "exportMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "void",
      "setFactoryMode(factoryMode: ExcelFactoryMode)": "void",
      "getFactoryMode()": "ExcelFactoryMode"
    },
    "docs": {
      "setFactoryMode(factoryMode: ExcelFactoryMode)": "/** private methods */"
    }
  },
  "ExcelSheetMargin": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number",
      "header?": "number",
      "footer?": "number"
    },
    "docs": {
      "top?": "/** The sheet top margin.\n     * @default 0.75\n     */",
      "right?": "/** The sheet right margin.\n     * @default 0.7\n     */",
      "bottom?": "/** The sheet bottom margin.\n     * @default 0.75\n     */",
      "left?": "/** The sheet left margin.\n     * @default 0.7\n     */",
      "header?": "/** The sheet header margin.\n     * @default 0.3\n     */",
      "footer?": "/** The sheet footer margin.\n     * @default 0.3\n     */"
    }
  },
  "ExcelSheetPageSetup": {
    "meta": {},
    "type": {
      "orientation?": "'Portrait' | 'Landscape'",
      "pageSize?": "'Letter' | 'Letter Small' | 'Tabloid' | 'Ledger' | 'Legal' | 'Statement' | 'Executive' | 'A3' | 'A4' | 'A4 Small' | 'A5' | 'A6' | 'B4' | 'B5' | 'Folio' | 'Envelope' | 'Envelope DL' | 'Envelope C5' | 'Envelope B5' | 'Envelope C3' | 'Envelope C4' | 'Envelope C6' | 'Envelope Monarch' | 'Japanese Postcard' | 'Japanese Double Postcard'"
    },
    "docs": {
      "orientation?": "/** Use this property to change the print orientation.\n     * @default 'Portrait'\n     */",
      "pageSize?": "/** Use this property to set the sheet size.\n     * @default 'Letter'\n     */"
    }
  },
  "ExcelTableConfig": {
    "meta": {},
    "type": {
      "name?": "string",
      "showFilterButton?": "boolean | 'match'",
      "showRowStripes?": "boolean",
      "showColumnStripes?": "boolean",
      "highlightFirstColumn?": "boolean",
      "highlightLastColumn?": "boolean"
    },
    "docs": {
      "name?": "/** This property is used to set the table name. It should be an alphanumeric string with no special characters.\n     * @default 'AG-GRID-TABLE'\n     */",
      "showFilterButton?": "/** Set this property to `false` to disable the filter button at the exported Excel table header.\n     * Set it to `true` to show the filter button on all columns.\n     * Set it to `match` to show the filter button only if the column has a filter allowed.\n     *\n     * @default match\n     */",
      "showRowStripes?": "/** Set this property to `false` to hide the row stripes.\n     *\n     * @default true\n     */",
      "showColumnStripes?": "/** Set this property to `true` to show column stripes.\n     *\n     * @default false\n     */",
      "highlightFirstColumn?": "/** Set this property to `true` to show the first column in bold/highlighted style.\n     *\n     * @default false\n     */",
      "highlightLastColumn?": "/** Set this property to `true` to show the last column in bold/highlighted style.\n     *\n     * @default false\n     */"
    }
  },
  "IExpansionService": {
    "meta": {},
    "type": {
      "expandRows(rowIds: string[])": "void",
      "getExpandedRows()": "string[]",
      "expandAll(value: boolean)": "void",
      "setRowNodeExpanded(rowNode: IRowNode, expanded: boolean, expandParents?: boolean, forceSync?: boolean)": "void",
      "onGroupExpandedOrCollapsed()": "void"
    }
  },
  "IFilterType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "string | { new (): IFilterComp; } | boolean"
  },
  "IFloatingFilterType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "string | { new (): IFloatingFilterComp; }"
  },
  "IFilterDef": {
    "meta": {},
    "type": {
      "filter?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "any",
      "floatingFilterComponentParams?": "any"
    },
    "docs": {
      "filter?": "/** Filter component to use for this column.\n     * - Set to `true` to use the default filter.\n     * - Set to the name of a provided filter: `agNumberColumnFilter`, `agTextColumnFilter`, `agDateColumnFilter`, `agMultiColumnFilter`, `agSetColumnFilter`.\n     * - Set to a `IFilterComp`.\n     */",
      "filterParams?": "/** Params to be passed to the filter component specified in `filter`. */",
      "floatingFilterComponent?": "/** The custom component to be used for rendering the floating filter.\n     * If none is specified the default AG Grid is used.\n     */",
      "floatingFilterComponentParams?": "/** Params to be passed to `floatingFilterComponent`. */"
    }
  },
  "BaseFilter": {
    "meta": {},
    "type": {
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "IFilter": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "ProvidedFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string"
    }
  },
  "IFilterComp": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IFilterParams<TData>)": "AgPromise<void> | void",
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IFilterParams<TData>)": "/** The init(params) method is called on the component once. */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "IDoesFilterPassParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData"
    },
    "docs": {
      "node": "/** The row node in question. */",
      "data": "/** The data part of the row node in question. */"
    }
  },
  "IFilterOptionDef": {
    "meta": {},
    "type": {
      "displayKey": "string",
      "displayName": "string",
      "predicate?": "(filterValues: any[], cellValue: any) => boolean",
      "numberOfInputs?": "0 | 1 | 2"
    },
    "docs": {
      "displayKey": "/** A unique key that does not clash with the built-in filter keys. */",
      "displayName": "/** Display name for the filter. Can be replaced by a locale-specific value using a `localeTextFunc`. */",
      "predicate?": "/** Custom filter logic that returns a boolean based on the `filterValues` and `cellValue`. */",
      "numberOfInputs?": "/** Number of inputs to display for this option. Defaults to `1` if unspecified. */"
    }
  },
  "BaseFilterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "column": "Column",
      "colDef": "ColDef<TData>",
      "rowModel": "IRowModel",
      "getValue": "<TValue = any>(node: IRowNode<TData>, column?: string | ColDef<TData, TValue> | Column<TValue>) => TValue | null | undefined",
      "doesRowPassOtherFilter": "(rowNode: IRowNode<TData>) => boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n     * If the filter needs to know which rows are\n     * a) in the table,\n     * b) currently visible (i.e. not already filtered),\n     * c) which groups,\n     * d) what order - all of this can be read from the rowModel.\n     */",
      "getValue": "/** Get the cell value for the given row node and column, which can be the column ID, definition, or `Column` object.\n     * If no column is provided, the column this filter is on will be used.\n     */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n     * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n     * The set filter uses this to remove from the list,\n     * items that are no longer available due to the state of other filters (like Excel type filtering).\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IFilterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Parameters provided by the grid to the `init` method of an `IFilterComp`\n */"
    },
    "type": {
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "ValueGetterFunc<TData>",
      "column": "Column",
      "colDef": "ColDef<TData>",
      "rowModel": "IRowModel",
      "getValue": "<TValue = any>(node: IRowNode<TData>, column?: string | ColDef<TData, TValue> | Column<TValue>) => TValue | null | undefined",
      "doesRowPassOtherFilter": "(rowNode: IRowNode<TData>) => boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n     * grid will then respond by filtering the grid data. The callback\n     * takes one optional parameter which, if included, will get merged\n     * to the FilterChangedEvent object (useful for passing additional\n     * information to anyone listening to this event, however such extra\n     * attributes are not used by the grid).\n     */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n     * The grid will respond with emitting a FilterModifiedEvent.\n     * Apart from emitting the event, the grid takes no further action.\n     */",
      "valueGetter": "/** @deprecated v31 Use `getValue` instead\n     */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n     * If the filter needs to know which rows are\n     * a) in the table,\n     * b) currently visible (i.e. not already filtered),\n     * c) which groups,\n     * d) what order - all of this can be read from the rowModel.\n     */",
      "getValue": "/** Get the cell value for the given row node and column, which can be the column ID, definition, or `Column` object.\n     * If no column is provided, the column this filter is on will be used.\n     */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n     * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n     * The set filter uses this to remove from the list,\n     * items that are no longer available due to the state of other filters (like Excel type filtering).\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "FilterModel": {
    "meta": {
      "doc": "/** FilterModel represents the filter state for all columns in the grid keyed by the column id.\n * If using inbuilt AG Grid filters then the type of the column filter model could be one of:\n *      `TextFilterModel`, `NumberFilterModel`, `DateFilterModel`, `SetFilterModel`, `IMultiFilterModel`, `AdvancedFilterModel`\n */"
    },
    "type": {
      "[colId: string]": "any"
    }
  },
  "IFiltersToolPanel": {
    "meta": {},
    "type": {
      "setFilterLayout(colDefs: ColDef[])": "void",
      "expandFilterGroups(groupIds?: string[])": "void",
      "collapseFilterGroups(groupIds?: string[])": "void",
      "expandFilters(colIds?: string[])": "void",
      "collapseFilters(colIds?: string[])": "void",
      "syncLayoutWithGrid()": "void",
      "getState()": "FiltersToolPanelState",
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "boolean | void",
      "getState?()": "TState | undefined"
    },
    "docs": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "/** Called when `api.refreshToolPanel()` is called (with the current params).\n     * Also called when the `sideBar` grid option is updated (with the updated params).\n     * When `sideBar` is updated, if this method returns `true`,\n     * then the grid will take no further action.\n     * Otherwise, the tool panel will be destroyed and recreated.\n     */",
      "getState?()": "/** If saving and restoring state, this should return the current state */"
    }
  },
  "FocusableContainer": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "setAllowFocus?(allowFocus: boolean)": "void"
    }
  },
  "FrameworkOverridesIncomingSource": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'resize-observer' | 'ensureVisible' | 'popupPositioning'"
  },
  "IFrameworkOverrides": {
    "meta": {},
    "type": {
      "setInterval(action: any, interval?: any)": "AgPromise<number>",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "void",
      "wrapIncoming": "<T>(callback: () => T, source?: FrameworkOverridesIncomingSource) => T",
      "wrapOutgoing": "<T>(callback: () => T) => T",
      "shouldWrapOutgoing?": "boolean",
      "frameworkComponent(name: string, components?: any)": "any",
      "isFrameworkComponent(comp: any)": "boolean",
      "renderingEngine": "'vanilla' | 'react'",
      "getDocLink(path?: string)": "string",
      "getLockOnRefresh?()": "void",
      "releaseLockOnRefresh?()": "void",
      "getLockOnRefreshError?()": "string"
    },
    "docs": {
      "wrapIncoming": "/** This method is to cater for Angular's change detection.\n     * Angular uses Zones, we want to run internal AG Grid outside of Zone JS so that we do not kick off\n     * Angular change detection. Any event listener or setTimeout() or setInterval() run by our code\n     * would trigger change detection in Angular.\n     *\n     * Before events are returned to the user, those functions are wrapped in Angular's zone\n     * again so that the user's code triggers change detection as normal. See wrapOutgoing() below.\n     */",
      "wrapOutgoing": "/** This method is to cater for Angular's change detection.\n     * This is currently used for events that the user provides either via the component or via registration with the grid api.\n     * This method should not be implemented for the other frameworks to avoid unnecessary overhead.\n     */",
      "shouldWrapOutgoing?": "/** The shouldWrapOutgoing property is used to determine if events should be run outside of Angular or not.\n     * If an event handler is registered outside of Angular then we should not wrap the event handler\n     * with runInsideAngular() as the user may not have wanted this.\n     * This is also used to not wrap internal event listeners that are registered with RowNodes and Columns.\n     */",
      "renderingEngine": "/** Which rendering engine is used for the grid components. Can be either 'vanilla' or 'react'.\n     */",
      "getDocLink(path?: string)": "/** Returns the framework specific url for linking to a documentation page.\n     * @param path Optional path to append to the base url. i.e 'aligned-grids' Does not need the leading `/`\n     */",
      "getLockOnRefresh?()": "/** Used by `RowRenderer` when getting lock. Allows React 17- async refreshes to work. */",
      "releaseLockOnRefresh?()": "/** Used by `RowRenderer` when releasing lock. Allows React 17- async refreshes to work. */",
      "getLockOnRefreshError?()": "/** Used by `RowRenderer` when a refresh happens whilst another refresh is ongoing. */"
    }
  },
  "IImmutableService": {
    "meta": {},
    "type": {
      "setRowData(data: any[])": "void",
      "isActive()": "boolean"
    }
  },
  "IInfiniteRowModel": {
    "meta": {},
    "type": {
      "setDatasource(datasource: IDatasource | undefined)": "void",
      "refreshCache()": "void",
      "purgeCache()": "void",
      "setRowCount(rowCount: number, maxRowFound?: boolean)": "void",
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "getType()": "RowModelType",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** Returns the number of rows */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n     * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n     * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n     * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n     *  then no rows should be returned  */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n     * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n     * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n     * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n     * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.\n     */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n     * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IMenuFactory": {
    "meta": {},
    "type": {
      "showMenuAfterButtonClick(column: AgColumn | undefined, eventSource: HTMLElement, containerType: ContainerType, filtersOnly?: boolean)": "void",
      "showMenuAfterMouseEvent(column: AgColumn | undefined, mouseEvent: MouseEvent | Touch, containerType: ContainerType, filtersOnly?: boolean)": "void",
      "showMenuAfterContextMenuEvent(column: AgColumn | undefined, mouseEvent?: MouseEvent | null, touchEvent?: TouchEvent | null)": "void",
      "isMenuEnabled(column: AgColumn)": "boolean",
      "hideActiveMenu()": "void"
    }
  },
  "ModuleValidationValidResult": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ isValid: true; }"
  },
  "ModuleValidationInvalidResult": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ isValid: false; message: string; }"
  },
  "ModuleValidationResult": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "ModuleValidationValidResult | ModuleValidationInvalidResult"
  },
  "Module": {
    "meta": {},
    "type": {
      "version": "string",
      "validate?": "() => ModuleValidationResult",
      "moduleName": "string",
      "beans?": "SingletonBean[]",
      "controllers?": "ControllerMeta[]",
      "userComponents?": "ComponentMeta[]",
      "rowModel?": "RowModelType",
      "dependantModules?": "Module[]",
      "apiFunctions?": "{[T in ApiFunctionName]?: ApiFunction<T>}"
    },
    "docs": {
      "validate?": "/** Validation run when registering the module\n     *\n     * @return Whether the module is valid or not. If not, a message explaining why it is not valid\n     */"
    }
  },
  "IMultiFilter": {
    "meta": {
      "doc": "/** Interface contract for the public aspects of the ProvidedFilter implementation(s). */"
    },
    "type": {
      "getChildFilterInstance(index: number)": "IFilter | undefined",
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "boolean",
      "getModelFromUi()": "any",
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "getChildFilterInstance(index: number)": "/** @returns the child filter instance at the given index. */",
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "/** Applies the model shown in the UI (so that `getModel()` will now return what was in the UI\n     * when `applyModel()` was called).\n     * @param source The source of the method call. Default 'api'.\n     */",
      "getModelFromUi()": "/** Returns the filter model from the UI. If changes have been made to the UI but not yet\n     * applied, this model will reflect those changes.\n     */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "IMultiFilterDef": {
    "meta": {},
    "type": {
      "display?": "'inline' | 'accordion' | 'subMenu'",
      "title?": "string",
      "filter?": "IFilterType",
      "filterParams?": "any",
      "floatingFilterComponent?": "IFloatingFilterType",
      "floatingFilterComponentParams?": "any"
    },
    "docs": {
      "display?": "/** Configures how the filter is shown in the Multi Filter.\n     * @default 'inline'\n     */",
      "title?": "/** The title to be used when a filter is displayed inside a sub-menu or accordion. */",
      "filter?": "/** Child filter component to use inside the Multi Filter. */",
      "filterParams?": "/** Custom parameters to be passed to the child filter component. */",
      "floatingFilterComponent?": "/** Floating filter component to use for the child filter. */",
      "floatingFilterComponentParams?": "/** Custom parameters to be passed to the floating filter component. */"
    }
  },
  "MultiFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "IMultiFilterParams & IFilterParams<TData>"
  },
  "IMultiFilterParams": {
    "meta": {
      "doc": "/** Parameters used in `colDef.filterParams` to configure a Multi Filter (`agMultiColumnFilter`).\n */"
    },
    "type": {
      "filters?": "IMultiFilterDef[]",
      "readOnly?": "boolean"
    },
    "docs": {
      "filters?": "/** An array of filter definition objects. */",
      "readOnly?": "/** If true, all UI inputs managed by this filter are for display only, and the filter can only\n     * be affected by API calls. Does NOT affect child filters, they need to be individually\n     * configured with `readOnly` where applicable.\n     * @default false\n     */"
    }
  },
  "IMultiFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'multi'",
      "filterModels": "any[] | null"
    },
    "docs": {
      "filterType?": "/** Multi filter type.  */",
      "filterModels": "/** Child filter models in the same order as the filters are specified in `filterParams`.\n     */"
    }
  },
  "IMultiFilterComp": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "getModel()": "ProvidedFilterModel | null",
      "setModel(model: IMultiFilterModel | null)": "void | AgPromise<void>",
      "getChildFilterInstance(index: number)": "IFilterComp | undefined"
    },
    "docs": {
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`. */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is not active. */",
      "setModel(model: IMultiFilterModel | null)": "/** Sets the state of the child filters using the supplied models. Providing `null` will\n     * de-activate all child filters.\n     *\n     * **Note:** if you are providing values asynchronously to a child Set Filter,\n     * you need to wait for these changes to be applied before performing any further actions by\n     * waiting on the returned grid promise, e.g.\n     * `filter.setModel([null, { values: ['a', 'b'] }]).then(function() { gridApi.onFilterChanged(); });`\n     */",
      "getChildFilterInstance(index: number)": "/** Returns the child filter instance at the specified index or `undefined` for an invalid index.  */"
    }
  },
  "IPivotColDefService": {
    "meta": {},
    "type": {
      "createColDefsFromFields": "(fields: string[]) => (ColDef | ColGroupDef)[]"
    }
  },
  "IPopupComponent": {
    "meta": {
      "typeParams": [
        "T"
      ]
    },
    "type": {
      "isPopup?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "isPopup?()": "/** Gets called once after initialised. If you return true, the component will appear in a popup, and it will be\n     *  constrained to the boundaries of the popupParent. This is great if you want to, for example, provide you own\n     * custom dropdown list for selection. Default is false (ie if you don't provide the method). */",
      "focusIn?()": "/** Called when focus is within the component */",
      "focusOut?()": "/** Called when focus is leaving the component */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: T)": "/** The init(params) method is called on the component once. */"
    }
  },
  "IRangeService": {
    "meta": {},
    "type": {
      "isEmpty()": "boolean",
      "removeAllCellRanges(silent?: boolean)": "void",
      "getCellRangeCount(cell: CellPosition)": "number",
      "isCellInAnyRange(cell: CellPosition)": "boolean",
      "isCellInSpecificRange(cell: CellPosition, range: CellRange)": "boolean",
      "isBottomRightCell(cellRange: CellRange, cell: CellPosition)": "boolean",
      "isContiguousRange(cellRange: CellRange)": "boolean",
      "isMoreThanOneCell()": "boolean",
      "areAllRangesAbleToMerge()": "boolean",
      "onDragStart(mouseEvent: MouseEvent)": "void",
      "onDragStop()": "void",
      "onDragging(mouseEvent: MouseEvent)": "void",
      "getCellRanges()": "CellRange[]",
      "setRangeToCell(cell: CellPosition, appendRange?: boolean)": "void",
      "intersectLastRange(fromMouseClick?: boolean)": "void",
      "setCellRange(params: CellRangeParams)": "void",
      "addCellRange(params: CellRangeParams)": "void",
      "extendLatestRangeInDirection(event: KeyboardEvent)": "CellPosition | undefined",
      "extendLatestRangeToCell(cell: CellPosition)": "void",
      "updateRangeEnd(cellRange: CellRange, cellPosition: CellPosition, silent?: boolean)": "void",
      "getRangeStartRow(cellRange: PartialCellRange)": "RowPosition",
      "getRangeEndRow(cellRange: PartialCellRange)": "RowPosition",
      "createCellRangeFromCellRangeParams(params: CellRangeParams)": "CellRange | undefined",
      "createPartialCellRangeFromRangeParams(params: CellRangeParams, allowEmptyColumns: boolean)": "PartialCellRange | undefined",
      "setCellRanges(cellRanges: CellRange[])": "void",
      "clearCellRangeCellValues(params: ClearCellRangeParams)": "void"
    }
  },
  "ISelectionHandle": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "getType()": "SelectionHandleType",
      "refresh(cellCtrl: CellCtrl)": "void",
      "beanName?": "BeanName",
      "wireBeans?(beans: BeanCollection)": "void",
      "postConstruct?()": "void",
      "destroy?()": "void"
    },
    "docs": {
      "beanName?": "/** AG Grid internal - do not use */",
      "wireBeans?(beans: BeanCollection)": "/** AG Grid internal - do not call */",
      "postConstruct?()": "/** AG Grid internal - do not call */",
      "destroy?()": "/** AG Grid internal - do not call */"
    }
  },
  "ISelectionHandleFactory": {
    "meta": {},
    "type": {
      "createSelectionHandle(type: SelectionHandleType)": "ISelectionHandle"
    }
  },
  "SelectionHandleType": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "FILL",
      "RANGE"
    ],
    "docs": [
      null,
      null
    ]
  },
  "CellRangeType": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "VALUE",
      "DIMENSION"
    ],
    "docs": [
      null,
      null
    ]
  },
  "CellRange": {
    "meta": {},
    "type": {
      "id?": "string",
      "type?": "CellRangeType",
      "startRow?": "RowPosition",
      "endRow?": "RowPosition",
      "columns": "Column[]",
      "startColumn": "Column"
    },
    "docs": {
      "startRow?": "/** The start row of the range */",
      "endRow?": "/** The end row of the range */",
      "columns": "/** The columns in the range */",
      "startColumn": "/** The start column for the range */"
    }
  },
  "PartialCellRange": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Omit<CellRange, 'startColumn'> & Partial<Pick<CellRange, 'startColumn'>>"
  },
  "CellRangeParams": {
    "meta": {},
    "type": {
      "rowStartIndex": "number | null",
      "rowStartPinned?": "RowPinnedType",
      "rowEndIndex": "number | null",
      "rowEndPinned?": "RowPinnedType",
      "columnStart?": "string | Column",
      "columnEnd?": "string | Column",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "rowStartIndex": "/** Start row index */",
      "rowStartPinned?": "/** Pinned state of start row. Either 'top', 'bottom' or null */",
      "rowEndIndex": "/** End row index */",
      "rowEndPinned?": "/** Pinned state of end row. Either 'top', 'bottom' or null */",
      "columnStart?": "/** Starting column for range */",
      "columnEnd?": "/** End column for range */",
      "columns?": "/** Specify Columns to include instead of using `columnStart` and `columnEnd` */"
    }
  },
  "ClearCellRangeParams": {
    "meta": {},
    "type": {
      "cellRanges?": "CellRange[]",
      "cellEventSource?": "string",
      "dispatchWrapperEvents?": "boolean",
      "wrapperEventSource?": "'deleteKey'"
    },
    "docs": {
      "cellEventSource?": "/** Source passed to `cellValueChanged` event */",
      "dispatchWrapperEvents?": "/** `true` to dispatch `rangeDeleteStart` and `rangeDeleteEnd` events */",
      "wrapperEventSource?": "/** Source passed to `rangeDeleteStart` and `rangeDeleteEnd` events */"
    }
  },
  "IRichCellEditorRendererParams": {
    "meta": {
      "typeParams": [
        "TValue"
      ]
    },
    "type": {
      "value": "TValue[] | TValue | null",
      "valueFormatted": "string",
      "getValue": "() => TValue[] | TValue | null | undefined",
      "setValue": "(value: TValue[] | TValue | null) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** The value to be rendered by the renderer */",
      "valueFormatted": "/** The value to be renderer by the renderer formatted by the editor */",
      "getValue": "/** Gets the current value of the editor */",
      "setValue": "/** Sets the value of the editor */",
      "setTooltip": "/** Used to set a tooltip to the renderer */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "RichSelectParams": {
    "meta": {
      "typeParams": [
        "TValue = any"
      ]
    },
    "type": {
      "value?": "TValue[] | TValue",
      "valueList?": "TValue[]",
      "allowTyping?": "boolean",
      "cellRenderer?": "any",
      "cellRowHeight?": "number",
      "searchDebounceDelay?": "number",
      "filterList?": "boolean",
      "searchType?": "'match' | 'matchAny' | 'fuzzy'",
      "highlightMatch?": "boolean",
      "multiSelect?": "boolean",
      "suppressDeselectAll?": "boolean",
      "suppressMultiSelectPillRenderer?": "boolean",
      "placeholder?": "string",
      "initialInputValue?": "string",
      "valueFormatter?": "(value: TValue[] | TValue) => any",
      "searchStringCreator?": "(values: TValue[]) => string[]",
      "pickerType": "string",
      "pickerGap?": "number",
      "variableWidth?": "boolean",
      "minPickerWidth?": "number | string",
      "maxPickerWidth?": "number | string",
      "maxPickerHeight?": "number | string",
      "pickerAriaLabelKey": "string",
      "pickerAriaLabelValue": "string",
      "template?": "string",
      "agComponents?": "ComponentSelector[]",
      "className?": "string",
      "pickerIcon?": "string",
      "ariaRole?": "string",
      "modalPicker?": "boolean",
      "inputWidth?": "number | 'flex'",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    },
    "docs": {
      "variableWidth?": "/** If true, will set min-width and max-width (if present), and will set width to wrapper element width.\n     * If false, will set min-width, max-width and width to maxPickerWidth or wrapper element width.\n     */"
    }
  },
  "RichCellEditorValuesCallback": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ICellEditorParams<TData, TValue>"
      },
      "returnType": "TValue[] | Promise<TValue[]>"
    }
  },
  "IRichCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ]
    },
    "type": {
      "values": "TValue[] | RichCellEditorValuesCallback<TData, TValue>",
      "cellHeight?": "number",
      "cellRenderer?": "any",
      "allowTyping?": "boolean",
      "filterList?": "boolean",
      "searchType?": "'match' | 'matchAny' | 'fuzzy'",
      "highlightMatch?": "boolean",
      "multiSelect?": "boolean",
      "suppressDeselectAll?": "boolean",
      "suppressMultiSelectPillRenderer?": "boolean",
      "searchDebounceDelay?": "number",
      "valuePlaceholder?": "string",
      "valueListGap?": "number",
      "valueListMaxHeight?": "number | string",
      "valueListMaxWidth?": "number | string",
      "formatValue?": "(value: TValue | null | undefined) => string"
    },
    "docs": {
      "values": "/** The list of values to be selected from. */",
      "cellHeight?": "/** The row height, in pixels, of each value. */",
      "cellRenderer?": "/** The cell renderer to use to render each value. Cell renderers are useful for rendering rich HTML values, or when processing complex data. */",
      "allowTyping?": "/** Set to `true` to be able to type values in the display area.\n     * @default false\n     */",
      "filterList?": "/** If `true` it will filter the list of values as you type (only relevant when `allowTyping=true`).\n     * @default false\n     */",
      "searchType?": "/** The type of search algorithm that is used when searching for values.\n     *  - `match` - Matches if the value starts with the text typed.\n     *  - `matchAny` - Matches if the value contains the text typed.\n     *  - `fuzzy` - Matches the closest value to text typed.\n     * Note: When a cellRenderer is specified, this option will not work.\n     * @default 'fuzzy'\n     */",
      "highlightMatch?": "/** If `true`, each item on the list of values will highlight the part of the text that matches the input.\n     * Note: It only makes sense to use this option when `filterList` is `true` and `searchType` is **not** `fuzzy`.\n     * @default false\n     */",
      "multiSelect?": "/** If `true` this component will allow multiple items from the list of values to be selected.\n     * Note: This feature does not work with `allowTyping=true`.\n     */",
      "suppressDeselectAll?": "/** If `true` the option to remove all selected options will not be displayed.\n     * Note: This feature only works when `multiSelect=true`.\n     */",
      "suppressMultiSelectPillRenderer?": "/** When `multiSelect=true` the editor will automatically show the selected items as \"pills\". Set this property to `true` suppress this behaviour.\n     */",
      "searchDebounceDelay?": "/** The value in `ms` for the search algorithm debounce delay (only relevant when `allowTyping=false`).\n     * @default 300\n     */",
      "valuePlaceholder?": "/** A string value to be used when no value has been selected. */",
      "valueListGap?": "/** The space in pixels between the value display and the list of items.\n     * @default 4\n     */",
      "valueListMaxHeight?": "/** The maximum height of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string.\n     * @default 'calc(var(--ag-row-height) * 6.5)'\n     */",
      "valueListMaxWidth?": "/** The maximum width of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string. Default: Width of the cell being edited.\n     */",
      "formatValue?": "/** A callback function that allows you to change the displayed value for simple data. */"
    }
  },
  "RichCellEditorParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "values": "TValue[] | RichCellEditorValuesCallback<TData, TValue>",
      "cellHeight?": "number",
      "cellRenderer?": "any",
      "allowTyping?": "boolean",
      "filterList?": "boolean",
      "searchType?": "'match' | 'matchAny' | 'fuzzy'",
      "highlightMatch?": "boolean",
      "multiSelect?": "boolean",
      "suppressDeselectAll?": "boolean",
      "suppressMultiSelectPillRenderer?": "boolean",
      "searchDebounceDelay?": "number",
      "valuePlaceholder?": "string",
      "valueListGap?": "number",
      "valueListMaxHeight?": "number | string",
      "valueListMaxWidth?": "number | string",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "value": "TValue | null | undefined",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "values": "/** The list of values to be selected from. */",
      "cellHeight?": "/** The row height, in pixels, of each value. */",
      "cellRenderer?": "/** The cell renderer to use to render each value. Cell renderers are useful for rendering rich HTML values, or when processing complex data. */",
      "allowTyping?": "/** Set to `true` to be able to type values in the display area.\n     * @default false\n     */",
      "filterList?": "/** If `true` it will filter the list of values as you type (only relevant when `allowTyping=true`).\n     * @default false\n     */",
      "searchType?": "/** The type of search algorithm that is used when searching for values.\n     *  - `match` - Matches if the value starts with the text typed.\n     *  - `matchAny` - Matches if the value contains the text typed.\n     *  - `fuzzy` - Matches the closest value to text typed.\n     * Note: When a cellRenderer is specified, this option will not work.\n     * @default 'fuzzy'\n     */",
      "highlightMatch?": "/** If `true`, each item on the list of values will highlight the part of the text that matches the input.\n     * Note: It only makes sense to use this option when `filterList` is `true` and `searchType` is **not** `fuzzy`.\n     * @default false\n     */",
      "multiSelect?": "/** If `true` this component will allow multiple items from the list of values to be selected.\n     * Note: This feature does not work with `allowTyping=true`.\n     */",
      "suppressDeselectAll?": "/** If `true` the option to remove all selected options will not be displayed.\n     * Note: This feature only works when `multiSelect=true`.\n     */",
      "suppressMultiSelectPillRenderer?": "/** When `multiSelect=true` the editor will automatically show the selected items as \"pills\". Set this property to `true` suppress this behaviour.\n     */",
      "searchDebounceDelay?": "/** The value in `ms` for the search algorithm debounce delay (only relevant when `allowTyping=false`).\n     * @default 300\n     */",
      "valuePlaceholder?": "/** A string value to be used when no value has been selected. */",
      "valueListGap?": "/** The space in pixels between the value display and the list of items.\n     * @default 4\n     */",
      "valueListMaxHeight?": "/** The maximum height of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string.\n     * @default 'calc(var(--ag-row-height) * 6.5)'\n     */",
      "valueListMaxWidth?": "/** The maximum width of the list of items. If the value is a `number` it will be\n     * treated as pixels, otherwise it should be a valid CSS size string. Default: Width of the cell being edited.\n     */",
      "formatValue?": "/** A callback function that allows you to change the displayed value for simple data. */",
      "value": "/** Current value of the cell */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "RowBounds": {
    "meta": {},
    "type": {
      "rowTop": "number",
      "rowHeight": "number",
      "rowIndex?": "number"
    }
  },
  "RowModelType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'infinite' | 'viewport' | 'clientSide' | 'serverSide'"
  },
  "IRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "getType()": "RowModelType",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** Returns the number of rows */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n     * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n     * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n     * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n     *  then no rows should be returned  */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n     * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n     * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n     * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n     * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.\n     */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n     * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "RowNodeEventType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'rowSelected' | 'selectableChanged' | 'displayedChanged' | 'dataChanged' | 'cellChanged' | 'masterChanged' | 'heightChanged' | 'topChanged' | 'groupChanged' | 'allChildrenCountChanged' | 'firstChildChanged' | 'lastChildChanged' | 'childIndexChanged' | 'rowIndexChanged' | 'expandedChanged' | 'hasChildrenChanged' | 'uiLevelChanged' | 'rowHighlightChanged' | 'mouseEnter' | 'mouseLeave' | 'draggingChanged'"
  },
  "RowNodeEventTypeMap": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "BuildEventTypeMap<RowNodeEventType, { rowSelected: RowSelectedEvent<TData>; selectableChanged: SelectableChangedEvent<TData>; displayedChanged: DisplayedChangedEvent<TData>; dataChanged: DataChangedEvent<TData>; cellChanged: CellChangedEvent<TData>; masterChanged: MasterChangedEvent<TData>; heightChanged: HeightChangedEvent<TData>; topChanged: TopChangedEvent<TData>; groupChanged: GroupChangedEvent<TData>; allChildrenCountChanged: AllChildrenCountChangedEvent<TData>; firstChildChanged: FirstChildChangedEvent<TData>; lastChildChanged: LastChildChangedEvent<TData>; childIndexChanged: ChildIndexChangedEvent<TData>; rowIndexChanged: RowIndexChangedEvent<TData>; expandedChanged: ExpandedChangedEvent<TData>; hasChildrenChanged: HasChildrenChangedEvent<TData>; uiLevelChanged: UiLevelChangedEvent<TData>; rowHighlightChanged: RowHighlightChangedEvent<TData>; mouseEnter: MouseEnterEvent<TData>; mouseLeave: MouseLeaveEvent<TData>; draggingChanged: DraggingChangedEvent<TData>; }>"
  },
  "AgRowNodeEventListener": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TEventType extends keyof RowNodeEventTypeMap<TData>",
        "TData = any"
      ]
    },
    "type": "(params: RowNodeEventTypeMap<TData>[TEventType]) => void"
  },
  "SetSelectedParams": {
    "meta": {},
    "type": {
      "newValue": "boolean",
      "clearSelection?": "boolean",
      "suppressFinishActions?": "boolean",
      "rangeSelect?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "source": "SelectionEventSourceType"
    }
  },
  "RowNodeEvent": {
    "meta": {
      "typeParams": [
        "T extends RowNodeEventType",
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "MouseEnterEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "MouseLeaveEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "HeightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "RowIndexChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "TopChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "ExpandedChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "FirstChildChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "LastChildChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "ChildIndexChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "AllChildrenCountChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "UiLevelChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "DataChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "oldData": "TData | undefined",
      "newData": "TData | undefined",
      "update": "boolean",
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "CellChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "column": "Column",
      "newValue": "TData | undefined",
      "oldValue": "TData | undefined",
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "SelectableChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "DisplayedChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "MasterChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "GroupChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "HasChildrenChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "RowHighlightChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "DraggingChangedEvent": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "RowHighlightPosition": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Above",
      "Below"
    ],
    "docs": [
      null,
      null
    ]
  },
  "RowPinnedType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'top' | 'bottom' | null | undefined"
  },
  "VerticalScrollPosition": {
    "meta": {},
    "type": {
      "top": "number",
      "bottom": "number"
    }
  },
  "BaseRowNode": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "id": "string | undefined",
      "data": "TData | undefined",
      "displayed": "boolean",
      "rowPinned": "RowPinnedType",
      "selectable": "boolean",
      "rowHeight": "number | null | undefined",
      "rowTop": "number | null",
      "group": "boolean | undefined",
      "firstChild": "boolean",
      "lastChild": "boolean",
      "childIndex": "number",
      "level": "number",
      "uiLevel": "number",
      "parent": "IRowNode<TData> | null",
      "stub": "boolean | undefined",
      "failedLoad": "boolean | undefined",
      "rowIndex": "number | null",
      "quickFilterAggregateText": "string | null",
      "master": "boolean",
      "detail": "boolean | undefined"
    },
    "docs": {
      "id": "/** Unique ID for the node. Either provided by the application, or generated by the grid if not. */",
      "data": "/** The data as provided by the application.\n     * Can be `undefined` when using row grouping or during grid initialisation.\n     */",
      "displayed": "/** This will be `true` if it has a rowIndex assigned, otherwise `false`.\n     */",
      "rowPinned": "/** Either `'top'` or `'bottom'` if row pinned, otherwise `undefined` or `null`. */",
      "selectable": "/** Is this row selectable. */",
      "rowHeight": "/** The height, in pixels, of this row. */",
      "rowTop": "/** The row top position in pixels. */",
      "group": "/** `true` if this node is a group node (i.e. it has children) */",
      "firstChild": "/** `true` if this is the first child in this group. Changes when data is sorted. */",
      "lastChild": "/** `true` if this is the last child in this group. Changes when data is sorted. */",
      "childIndex": "/** Index of this row with respect to its parent when grouping. Changes when data is sorted. */",
      "level": "/** How many levels this node is from the top when grouping. */",
      "uiLevel": "/** How many levels this node is from the top when grouping in the UI (only different to `parent` when `groupRemoveSingleChildren=true`).*/",
      "parent": "/** The parent node to this node, or empty if top level. */",
      "stub": "/** Used by server-side row model. `true` if this row node is a stub. A stub is a placeholder row with loading icon while waiting from row to be loaded. */",
      "failedLoad": "/** Used by server side row model, `true` if this row node failed a load. */",
      "rowIndex": "/** The current row index. If the row is filtered out or in a collapsed group, this value will be `null`. */",
      "quickFilterAggregateText": "/** If using quick filter, stores a string representation of the row for searching against. */",
      "master": "/** `true` if this row is a master row, part of master / detail (ie row can be expanded to show detail). */",
      "detail": "/** `true` if this row is a detail row, part of master / detail (ie child row of an expanded master row). */"
    }
  },
  "GroupRowNode": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "field": "string | null",
      "key": "string | null",
      "groupData": "{ [key: string]: any | null; } | null",
      "aggData": "any",
      "rowGroupColumn": "Column | null",
      "rowGroupIndex": "number | null",
      "expanded": "boolean",
      "leafGroup": "boolean | undefined",
      "allLeafChildren": "IRowNode<TData>[] | null",
      "allChildrenCount": "number | null",
      "childrenAfterGroup": "IRowNode<TData>[] | null",
      "childrenAfterSort": "IRowNode<TData>[] | null",
      "childrenAfterFilter": "IRowNode<TData>[] | null",
      "footer": "boolean | undefined",
      "sibling": "IRowNode<TData>"
    },
    "docs": {
      "field": "/** The field we are grouping on from our row data. */",
      "key": "/** The key value for this group. */",
      "groupData": "/** If using row grouping, contains the group values for this group. */",
      "aggData": "/** If using row grouping and aggregation, contains the aggregation data. */",
      "rowGroupColumn": "/** The row group column used for this group. */",
      "rowGroupIndex": "/** If doing in-memory (client-side) grouping, this is the index of the group column this cell is for.\n     * This will always be the same as the level, unless we are collapsing groups, i.e. `groupRemoveSingleChildren=true`.\n     */",
      "expanded": "/** `true` if group is expanded, otherwise `false`. */",
      "leafGroup": "/** `true` if this node is a group and the group is the bottom level in the tree. */",
      "allLeafChildren": "/** All lowest level nodes beneath this node, no groups. */",
      "allChildrenCount": "/** Number of children and grand children. */",
      "childrenAfterGroup": "/** Children of this group. If multi levels of grouping, shows only immediate children. */",
      "childrenAfterSort": "/** Sorted children of this group. */",
      "childrenAfterFilter": "/** Filtered children of this group. */",
      "footer": "/** `true` if row is a footer. Footers have `group = true` and `footer = true`. */",
      "sibling": "/** If using footers, reference to the footer node for this group. */"
    }
  },
  "IRowNode": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "setSelected(newValue: boolean, clearSelection?: boolean, source?: SelectionEventSourceType)": "void",
      "isSelected()": "boolean | undefined",
      "isRowPinned()": "boolean",
      "isExpandable()": "boolean",
      "setExpanded(expanded: boolean, sourceEvent?: MouseEvent | KeyboardEvent, forceSync?: boolean)": "void",
      "isFullWidthCell()": "boolean",
      "isHovered()": "boolean",
      "addEventListener(eventType: T, userListener: AgRowNodeEventListener<T>)": "void",
      "removeEventListener(eventType: T, userListener: AgRowNodeEventListener<T>)": "void",
      "resetQuickFilterAggregateText()": "void",
      "depthFirstSearch(callback: (rowNode: IRowNode<TData>) => void)": "void",
      "setRowHeight(rowHeight: number | undefined | null, estimated?: boolean)": "void",
      "setData(data: TData)": "void",
      "updateData(data: TData)": "void",
      "setDataValue(colKey: string | Column, newValue: any, eventSource?: string)": "boolean",
      "getRoute()": "string[] | undefined",
      "id": "string | undefined",
      "data": "TData | undefined",
      "displayed": "boolean",
      "rowPinned": "RowPinnedType",
      "selectable": "boolean",
      "rowHeight": "number | null | undefined",
      "rowTop": "number | null",
      "group": "boolean | undefined",
      "firstChild": "boolean",
      "lastChild": "boolean",
      "childIndex": "number",
      "level": "number",
      "uiLevel": "number",
      "parent": "IRowNode<TData> | null",
      "stub": "boolean | undefined",
      "failedLoad": "boolean | undefined",
      "rowIndex": "number | null",
      "quickFilterAggregateText": "string | null",
      "master": "boolean",
      "detail": "boolean | undefined",
      "field": "string | null",
      "key": "string | null",
      "groupData": "{ [key: string]: any | null; } | null",
      "aggData": "any",
      "rowGroupColumn": "Column | null",
      "rowGroupIndex": "number | null",
      "expanded": "boolean",
      "leafGroup": "boolean | undefined",
      "allLeafChildren": "IRowNode<TData>[] | null",
      "allChildrenCount": "number | null",
      "childrenAfterGroup": "IRowNode<TData>[] | null",
      "childrenAfterSort": "IRowNode<TData>[] | null",
      "childrenAfterFilter": "IRowNode<TData>[] | null",
      "footer": "boolean | undefined",
      "sibling": "IRowNode<TData>"
    },
    "docs": {
      "setSelected(newValue: boolean, clearSelection?: boolean, source?: SelectionEventSourceType)": "/** Select (or deselect) the node.\n     * @param newValue -`true` for selection, `false` for deselection.\n     * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact. Default: `false`\n     * @param source - Source property that will appear in the `selectionChanged` event. Default: `'api'`\n     */",
      "isSelected()": "/** Returns:\n     * - `true` if node is selected.\n     * - `false` if the node isn't selected.\n     * - `undefined` if it's partially selected (group where not all children are selected).\n     */",
      "isRowPinned()": "/** Returns:\n     * - `true` if node is either pinned to the `top` or `bottom`.\n     * - `false` if the node isn't pinned.\n     */",
      "isExpandable()": "/** Returns:\n     * - `true` if the node can be expanded, i.e it is a group or master row.\n     * - `false` if the node cannot be expanded.\n     */",
      "setExpanded(expanded: boolean, sourceEvent?: MouseEvent | KeyboardEvent, forceSync?: boolean)": "/** Set the expanded state of this rowNode.\n     * @param expanded - `true` to expand, `false` to collapse.\n     * @param sourceEvent - Optional event that will be passed to the `rowGroupOpened` event.\n     * @param forceSync - By default rows are expanded asynchronously for best performance. Set to `true` if you need to interact with the expanded row immediately after this function.\n     */",
      "isFullWidthCell()": "/** Returns:\n     * - `true` if the node is a full width cell.\n     * - `false` if the node is not a full width cell.\n     */",
      "isHovered()": "/** Returns:\n     * - `true` if the node is currently hovered.\n     * - `false` if the node is not hovered.\n     */",
      "addEventListener(eventType: T, userListener: AgRowNodeEventListener<T>)": "/** Add an event listener. */",
      "removeEventListener(eventType: T, userListener: AgRowNodeEventListener<T>)": "/** Remove event listener. */",
      "resetQuickFilterAggregateText()": "/** The first time `quickFilter` runs, the grid creates a one-off string representation of the row.\n     * This string is then used for the quick filter instead of hitting each column separately.\n     * When you edit, using grid editing, this string gets cleared down.\n     * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.\n     * Otherwise new values will not work with the `quickFilter`.\n     */",
      "depthFirstSearch(callback: (rowNode: IRowNode<TData>) => void)": "/** Perform a depth-first search of this node and its children. */",
      "setRowHeight(rowHeight: number | undefined | null, estimated?: boolean)": "/** Sets the row height.\n     * Call if you want to change the height initially assigned to the row.\n     * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows.\n     * @param rowHeight - new height of the row\n     * @param estimated - is this an estimated height. Default: `false`\n     */",
      "setData(data: TData)": "/** Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.\n     */",
      "updateData(data: TData)": "/** Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.\n     */",
      "setDataValue(colKey: string | Column, newValue: any, eventSource?: string)": "/** Replaces the value on the `rowNode` for the specified column. When complete,\n     * the grid will refresh the rendered cell on the required row only.\n     * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.\n     *\n     * @param colKey The column where the value should be updated\n     * @param newValue The new value\n     * @param eventSource The source of the event\n     * @returns `true` if the value was changed, otherwise `false`.\n     */",
      "getRoute()": "/** Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.\n     * If the Row Node is not a group, it returns `undefined`.\n     */",
      "id": "/** Unique ID for the node. Either provided by the application, or generated by the grid if not. */",
      "data": "/** The data as provided by the application.\n     * Can be `undefined` when using row grouping or during grid initialisation.\n     */",
      "displayed": "/** This will be `true` if it has a rowIndex assigned, otherwise `false`.\n     */",
      "rowPinned": "/** Either `'top'` or `'bottom'` if row pinned, otherwise `undefined` or `null`. */",
      "selectable": "/** Is this row selectable. */",
      "rowHeight": "/** The height, in pixels, of this row. */",
      "rowTop": "/** The row top position in pixels. */",
      "group": "/** `true` if this node is a group node (i.e. it has children) */",
      "firstChild": "/** `true` if this is the first child in this group. Changes when data is sorted. */",
      "lastChild": "/** `true` if this is the last child in this group. Changes when data is sorted. */",
      "childIndex": "/** Index of this row with respect to its parent when grouping. Changes when data is sorted. */",
      "level": "/** How many levels this node is from the top when grouping. */",
      "uiLevel": "/** How many levels this node is from the top when grouping in the UI (only different to `parent` when `groupRemoveSingleChildren=true`).*/",
      "parent": "/** The parent node to this node, or empty if top level. */",
      "stub": "/** Used by server-side row model. `true` if this row node is a stub. A stub is a placeholder row with loading icon while waiting from row to be loaded. */",
      "failedLoad": "/** Used by server side row model, `true` if this row node failed a load. */",
      "rowIndex": "/** The current row index. If the row is filtered out or in a collapsed group, this value will be `null`. */",
      "quickFilterAggregateText": "/** If using quick filter, stores a string representation of the row for searching against. */",
      "master": "/** `true` if this row is a master row, part of master / detail (ie row can be expanded to show detail). */",
      "detail": "/** `true` if this row is a detail row, part of master / detail (ie child row of an expanded master row). */",
      "field": "/** The field we are grouping on from our row data. */",
      "key": "/** The key value for this group. */",
      "groupData": "/** If using row grouping, contains the group values for this group. */",
      "aggData": "/** If using row grouping and aggregation, contains the aggregation data. */",
      "rowGroupColumn": "/** The row group column used for this group. */",
      "rowGroupIndex": "/** If doing in-memory (client-side) grouping, this is the index of the group column this cell is for.\n     * This will always be the same as the level, unless we are collapsing groups, i.e. `groupRemoveSingleChildren=true`.\n     */",
      "expanded": "/** `true` if group is expanded, otherwise `false`. */",
      "leafGroup": "/** `true` if this node is a group and the group is the bottom level in the tree. */",
      "allLeafChildren": "/** All lowest level nodes beneath this node, no groups. */",
      "allChildrenCount": "/** Number of children and grand children. */",
      "childrenAfterGroup": "/** Children of this group. If multi levels of grouping, shows only immediate children. */",
      "childrenAfterSort": "/** Sorted children of this group. */",
      "childrenAfterFilter": "/** Filtered children of this group. */",
      "footer": "/** `true` if row is a footer. Footers have `group = true` and `footer = true`. */",
      "sibling": "/** If using footers, reference to the footer node for this group. */"
    }
  },
  "StageExecuteParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "rowNode": "RowNode<TData>",
      "rowNodeTransaction?": "RowNodeTransaction<TData> | null",
      "rowNodeTransactions?": "RowNodeTransaction<TData>[] | null",
      "rowNodeOrder?": "{ [id: string]: number; }",
      "changedPath?": "ChangedPath",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IRowNodeStage": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "execute(params: StageExecuteParams<TData>)": "any"
    }
  },
  "ISelectionService": {
    "meta": {},
    "type": {
      "getSelectionState()": "string[] | ServerSideRowSelectionState | ServerSideRowGroupSelectionState | null",
      "setSelectionState(state: string[] | ServerSideRowSelectionState | ServerSideRowGroupSelectionState, source: SelectionEventSourceType)": "void",
      "getSelectedNodes()": "RowNode<any>[]",
      "getSelectedRows()": "any[]",
      "getSelectionCount()": "number",
      "setNodesSelected(params: ISetNodesSelectedParams)": "number",
      "filterFromSelection(predicate: (node: RowNode) => boolean)": "void",
      "updateGroupsFromChildrenSelections(source: SelectionEventSourceType, changedPath?: ChangedPath)": "boolean",
      "syncInRowNode(rowNode: RowNode, oldNode: RowNode | null)": "void",
      "reset(source: SelectionEventSourceType)": "void",
      "getBestCostNodeSelection()": "RowNode[] | undefined",
      "isEmpty()": "boolean",
      "getSelectAllState(justFiltered?: boolean, justCurrentPage?: boolean)": "boolean | null",
      "hasNodesToSelect(justFiltered?: boolean, justCurrentPage?: boolean)": "boolean",
      "selectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean; justCurrentPage?: boolean; })": "void",
      "deselectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean; justCurrentPage?: boolean; })": "void"
    },
    "docs": {
      "getSelectAllState(justFiltered?: boolean, justCurrentPage?: boolean)": "/** @param justFiltered whether to just include nodes which have passed the filter\n     * @param justCurrentPage whether to just include nodes on the current page\n     * @returns all nodes including unselectable nodes which are the target of this selection attempt\n     */"
    }
  },
  "INodeSelectionParams": {
    "meta": {},
    "type": {
      "newValue": "boolean",
      "clearSelection?": "boolean",
      "suppressFinishActions?": "boolean",
      "rangeSelect?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "source": "SelectionEventSourceType",
      "event?": "Event"
    }
  },
  "ISetNodesSelectedParams": {
    "meta": {},
    "type": {
      "nodes": "RowNode[]",
      "newValue": "boolean",
      "clearSelection?": "boolean",
      "suppressFinishActions?": "boolean",
      "rangeSelect?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "source": "SelectionEventSourceType",
      "event?": "Event"
    }
  },
  "IServerSideGetRowsRequest": {
    "meta": {},
    "type": {
      "startRow": "number | undefined",
      "endRow": "number | undefined",
      "rowGroupCols": "ColumnVO[]",
      "valueCols": "ColumnVO[]",
      "pivotCols": "ColumnVO[]",
      "pivotMode": "boolean",
      "groupKeys": "string[]",
      "filterModel": "FilterModel | AdvancedFilterModel | null",
      "sortModel": "SortModelItem[]"
    },
    "docs": {
      "startRow": "/** First row requested or undefined for all rows. */",
      "endRow": "/** Index after the last row required row or undefined for all rows. */",
      "rowGroupCols": "/** Columns that are currently row grouped.  */",
      "valueCols": "/** Columns that have aggregations on them.  */",
      "pivotCols": "/** Columns that have pivot on them.  */",
      "pivotMode": "/** Defines if pivot mode is on or off.  */",
      "groupKeys": "/** What groups the user is viewing.  */",
      "filterModel": "/** If filtering, what the filter model is.\n     * If Advanced Filter is enabled, will be of type `AdvancedFilterModel | null`.\n     * If Advanced Filter is disabled, will be of type `FilterModel`.\n     */",
      "sortModel": "/** If sorting, what the sort model is.  */"
    }
  },
  "IServerSideGetRowsParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "request": "IServerSideGetRowsRequest",
      "parentNode": "IRowNode",
      "success(params: LoadSuccessParams)": "void",
      "fail()": "void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "request": "/** Details for the request. A simple object that can be converted to JSON.\n     */",
      "parentNode": "/** The parent row node. The RootNode (level -1) if request is top level.\n     * This is NOT part fo the request as it cannot be serialised to JSON (a rowNode has methods).\n     */",
      "success(params: LoadSuccessParams)": "/** Success callback, pass the rows back to the grid that were requested.\n     */",
      "fail()": "/** Fail callback, tell the grid the call failed so it can adjust it's state.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IServerSideDatasource": {
    "meta": {},
    "type": {
      "getRows(params: IServerSideGetRowsParams)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "getRows(params: IServerSideGetRowsParams)": "/** Grid calls `getRows` when it requires more rows as specified in the params.\n     * Params object contains callbacks for responding to the request.\n     */",
      "destroy?()": "/** Optional method, if your datasource has state it needs to clean up. */"
    }
  },
  "IServerSideRowModel": {
    "meta": {},
    "type": {
      "refreshStore(params?: RefreshServerSideParams)": "void",
      "onRowHeightChanged()": "void",
      "onRowHeightChangedDebounced()": "void",
      "getStoreState()": "ServerSideGroupLevelState[]",
      "retryLoads()": "void",
      "expandAll(value: boolean)": "void",
      "setDatasource(datasource: IServerSideDatasource)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: IRowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "resetRootStore()": "void",
      "getBlockStates()": "void",
      "setRowCount(rowCount: number, isLastRowIndexKnown?: boolean)": "void",
      "applyRowData(rowDataParams: LoadSuccessParams, startRow: number, route: string[])": "void",
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "void",
      "getType()": "RowModelType",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** Returns the number of rows */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n     * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n     * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n     * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n     *  then no rows should be returned  */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void, includeFooterNodes?: boolean)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n     * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n     * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n     * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n     * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.\n     */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n     * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IServerSideTransactionManager": {
    "meta": {},
    "type": {
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult | undefined",
      "applyTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void)": "void",
      "flushAsyncTransactions()": "void"
    }
  },
  "RefreshServerSideParams": {
    "meta": {},
    "type": {
      "route?": "string[]",
      "purge?": "boolean"
    },
    "docs": {
      "route?": "/** List of group keys, pointing to the level to refresh.\n     * For example, to purge two levels down under 'Canada'and then '2002', pass in the string array ['Canada','2002'].\n     * If no route is passed, or an empty array, then the top level is refreshed.\n     */",
      "purge?": "/** If true, then all rows at the level getting refreshed are immediately destroyed and 'loading' rows will appear.\n     * If false, then all rows at the level getting refreshed are kept until rows are loaded (no 'loading' rows appear).\n     */"
    }
  },
  "IServerSideSelectionState": {
    "meta": {},
    "type": {
      "selectAll": "boolean",
      "toggledNodes": "string[]"
    },
    "docs": {
      "selectAll": "/** Whether the majority of rows are selected or not */",
      "toggledNodes": "/** All rows that have the opposite selection state to `selectAll` */"
    }
  },
  "IServerSideGroupSelectionState": {
    "meta": {},
    "type": {
      "toggledNodes?": "IServerSideGroupSelectionState[]",
      "nodeId?": "string",
      "selectAllChildren?": "boolean"
    }
  },
  "IServerSideStore": {
    "meta": {},
    "type": {
      "clearDisplayIndexes()": "void",
      "getDisplayIndexEnd()": "number | undefined",
      "isDisplayIndexInStore(displayIndex: number)": "boolean",
      "setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: { value: number; })": "void",
      "forEachStoreDeep(callback: (rowNode: IServerSideStore, index: number) => void, sequence?: NumberSequence)": "void",
      "forEachNodeDeep(callback: (rowNode: IRowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "forEachNodeDeepAfterFilterAndSort(callback: (rowNode: IRowNode, index: number) => void, sequence?: NumberSequence, includeFooterNodes?: boolean)": "void",
      "retryLoads()": "void",
      "getRowUsingDisplayIndex(displayRowIndex: number, dontCreateBlock?: boolean)": "IRowNode | undefined",
      "getRowBounds(index: number)": "RowBounds | null",
      "isPixelInRange(pixel: number)": "boolean",
      "getRowIndexAtPixel(pixel: number)": "number | null",
      "getChildStore(keys: string[])": "IServerSideStore | null",
      "refreshAfterSort(params: StoreRefreshAfterParams)": "void",
      "refreshAfterFilter(params: StoreRefreshAfterParams)": "void",
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult",
      "refreshStore(purge: boolean)": "void",
      "getRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "isLastRowIndexKnown()": "boolean",
      "getRowNodesInRange(firstInRange: IRowNode, lastInRange: IRowNode)": "IRowNode[]",
      "addStoreStates(result: ServerSideGroupLevelState[])": "void",
      "getStoreBounds()": "{ topPx: number; heightPx: number; }",
      "beanName?": "BeanName",
      "wireBeans?(beans: BeanCollection)": "void",
      "postConstruct?()": "void",
      "destroy?()": "void"
    },
    "docs": {
      "beanName?": "/** AG Grid internal - do not use */",
      "wireBeans?(beans: BeanCollection)": "/** AG Grid internal - do not call */",
      "postConstruct?()": "/** AG Grid internal - do not call */",
      "destroy?()": "/** AG Grid internal - do not call */"
    }
  },
  "StoreRefreshAfterParams": {
    "meta": {},
    "type": {
      "valueColChanged": "boolean",
      "secondaryColChanged": "boolean",
      "changedColumns": "string[]"
    }
  },
  "ServerSideGroupLevelState": {
    "meta": {},
    "type": {
      "suppressInfiniteScroll": "boolean",
      "route": "string[]",
      "rowCount": "number",
      "lastRowIndexKnown?": "boolean",
      "info?": "any",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    },
    "docs": {
      "suppressInfiniteScroll": "/** True if suppressing infinite scrolling and loading all the data at the current level */",
      "route": "/** The route that identifies this level. */",
      "rowCount": "/** How many rows the level has. This includes 'loading rows'. */",
      "lastRowIndexKnown?": "/** Infinite Scroll only.\n     * Whether the last row index is know.\n     * */",
      "info?": "/** Any extra info provided to the level, when data was loaded. */",
      "maxBlocksInCache?": "/**Infinite Scroll only.\n     * Max blocks allowed in the infinite cache.\n     */",
      "cacheBlockSize?": "/** Infinite Scroll only.\n     * The size (number of rows) of each infinite cache block.\n     */"
    }
  },
  "SetFilterModelValue": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(string | null)[]"
  },
  "SetFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'set'",
      "values": "SetFilterModelValue"
    }
  },
  "ISetFilter": {
    "meta": {
      "typeParams": [
        "V = string"
      ],
      "doc": "/** Interface contract for the public aspects of the SetFilter implementation.\n * @param V type of value in the Set Filter\n */"
    },
    "type": {
      "getModel()": "SetFilterModel | null",
      "setModel(model: SetFilterModel | null)": "AgPromise<void>",
      "getFilterKeys()": "SetFilterModelValue",
      "getFilterValues()": "(V | null)[]",
      "setFilterValues(values: (V | null)[])": "void",
      "refreshFilterValues()": "void",
      "resetFilterValues()": "void",
      "getMiniFilter()": "string | null",
      "setMiniFilter(newMiniFilter: string | null)": "void",
      "getModelFromUi()": "SetFilterModel | null",
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "boolean",
      "isFilterActive()": "boolean",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active.\n     */",
      "setModel(model: SetFilterModel | null)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     *\n     * **Note:** if you are [providing values asynchronously](/filter-set-filter-list/#asynchronous-values)\n     * to the Set Filter, you need to wait for these changes to be applied before performing any further\n     * actions by waiting on the returned grid promise, e.g.\n     * `filter.setModel({ values: ['a', 'b'] }).then(function() { gridApi.onFilterChanged(); });`\n     */",
      "getFilterKeys()": "/** Returns the full list of unique keys used by the Set Filter. */",
      "getFilterValues()": "/** Returns the full list of unique values used by the Set Filter. */",
      "setFilterValues(values: (V | null)[])": "/** Sets the values used in the Set Filter on the fly. */",
      "refreshFilterValues()": "/** Refreshes the values shown in the filter from the original source. For example, if a\n     * callback was provided, the callback will be executed again and the filter will refresh using\n     * the values returned.\n     */",
      "resetFilterValues()": "/** Resets the Set Filter to use values from the grid, rather than any values that have been\n     * provided directly.\n     */",
      "getMiniFilter()": "/** Returns the current mini-filter text. */",
      "setMiniFilter(newMiniFilter: string | null)": "/** Sets the text in the Mini Filter at the top of the filter (the 'quick search' in the popup). */",
      "getModelFromUi()": "/** Returns the current UI state (potentially un-applied). */",
      "applyModel(source?: 'api' | 'ui' | 'rowDataUpdated')": "/** Applies the model shown in the UI (so that `getModel()` will now return what was in the UI\n     * when `applyModel()` was called).\n     * @param source The source of the method call. Default 'api'.\n     */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "SetFilterValuesFuncParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "V = string"
      ],
      "doc": "/** @param TData type of data row\n * @param V type of value in the Set Filter\n */"
    },
    "type": {
      "success": "(values: (V | null)[]) => void",
      "colDef": "ColDef<TData>",
      "column": "Column",
      "api": "GridApi<TData>",
      "context": "any"
    },
    "docs": {
      "success": "/** The function to call with the values to load into the filter once they are ready. */",
      "colDef": "/** The column definition from which the set filter is invoked. */",
      "column": "/** Column from which the set filter is invoked. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SetFilterValuesFunc": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "V = string"
      ]
    },
    "type": "(params: SetFilterValuesFuncParams<TData, V>) => void"
  },
  "SetFilterValues": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "V = string"
      ]
    },
    "type": "SetFilterValuesFunc<TData, V> | (V | null)[]"
  },
  "SetFilterParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any",
        "V = string"
      ]
    },
    "type": "ISetFilterParams<TData, V> & IFilterParams<TData>"
  },
  "ISetFilterParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "V = string"
      ],
      "doc": "/** Parameters used in `colDef.filterParams` to configure a Set Filter (`agSetColumnFilter`).\n * @param TData type of data row\n * @param V type of value in the Set Filter\n */"
    },
    "type": {
      "values?": "SetFilterValues<TData, V>",
      "refreshValuesOnOpen?": "boolean",
      "cellHeight?": "number",
      "suppressSorting?": "boolean",
      "cellRenderer?": "any",
      "suppressMiniFilter?": "boolean",
      "applyMiniFilterWhileTyping?": "boolean",
      "suppressSelectAll?": "boolean",
      "defaultToNothingSelected?": "boolean",
      "comparator?": "(a: V | null, b: V | null) => number",
      "textFormatter?": "(from: string) => string",
      "valueFormatter?": "(params: ValueFormatterParams) => string",
      "keyCreator?": "(params: KeyCreatorParams<TData>) => string",
      "showTooltips?": "boolean",
      "caseSensitive?": "boolean",
      "excelMode?": "'mac' | 'windows'",
      "treeList?": "boolean",
      "treeListPathGetter?": "(value: V | null) => string[] | null",
      "treeListFormatter?": "(pathKey: string | null, level: number, parentPathKeys: (string | null)[]) => string",
      "buttons?": "('apply' | 'clear' | 'reset' | 'cancel')[]",
      "closeOnApply?": "boolean",
      "debounceMs?": "number",
      "readOnly?": "boolean"
    },
    "docs": {
      "values?": "/** The values to display in the Filter List. If this is not set, the filter will takes its\n     * values from what is loaded in the table.\n     */",
      "refreshValuesOnOpen?": "/** Refresh the values every time the Set filter is opened.\n     */",
      "cellHeight?": "/** The height of values in the Filter List in pixels. */",
      "suppressSorting?": "/** If `true`, the Set Filter values will not be sorted. Use this if you are providing your own\n     * values and don't want them sorted as you are providing in the order you want.\n     *\n     * @default false\n     */",
      "cellRenderer?": "/** Similar to the Cell Renderer for the grid. Setting it separately here allows for the value to\n     * be rendered differently in the filter.\n     */",
      "suppressMiniFilter?": "/** Set to `true` to hide the Mini Filter.\n     *\n     * @default false\n     */",
      "applyMiniFilterWhileTyping?": "/** Set to `true` to apply the Set Filter immediately when the user is typing in the Mini Filter.\n     *\n     * @default false\n     */",
      "suppressSelectAll?": "/** Set to `true` to remove the Select All checkbox.\n     * @default false\n     */",
      "defaultToNothingSelected?": "/** By default, when the Set Filter is opened all values are shown selected. Set this to `true`\n     * to instead show all values as de-selected by default.\n     *\n     * This does not work when `excelMode` is enabled.\n     */",
      "comparator?": "/** Comparator for sorting. If not provided, the Column Definition comparator is used. If Column\n     * Definition comparator is also not provided, the default (grid provided) comparator is used.\n     */",
      "textFormatter?": "/** If specified, this formats the text before applying the Mini Filter compare logic, useful for\n     * instance to substitute accented characters.\n     */",
      "valueFormatter?": "/** If specified, this formats the value before it is displayed in the Filter List.\n     * If a Key Creator is provided (see `keyCreator`), this must also be provided.\n     */",
      "keyCreator?": "/** Function to return a string key for a value. This is required when the filter values are complex objects,\n     * or when `treeList = true` and the column is a group column with Tree Data or Grouping enabled.\n     * If not provided, the Column Definition Key Creator is used.\n     */",
      "showTooltips?": "/** If `true`, hovering over a value in the Set Filter will show a tooltip containing the full,\n     * untruncated value.\n     *\n     * @default false\n     */",
      "caseSensitive?": "/** If `true`, enables case-sensitivity in the SetFilter Mini-Filter and Filter List.\n     * @default false\n     */",
      "excelMode?": "/** Changes the behaviour of the Set Filter to match that of Excel's AutoFilter.\n     */",
      "treeList?": "/** If `true`, the Set Filter List will be displayed in a tree format. If enabled, one of the following must be true:\n     *\n     * - A `treeListPathGetter` is provided to get the tree path for the column values.\n     * - The column values are of type `Date`, in which case the tree will be year -> month -> day.\n     * - Tree Data mode is enabled and the column is the group column. The Filter List will match the tree structure. A Key Creator must be supplied.\n     * - Grouping is enabled and the column is the group column. The Filter List will match the group structure. A Key Creator must be supplied.\n     */",
      "treeListPathGetter?": "/** Requires `treeList = true`. If provided, this gets the tree path to display in the Set Filter List based on the column values.\n     * Each row must map to a leaf value in the tree.\n     */",
      "treeListFormatter?": "/** Requires `treeList = true`. If specified, this formats the tree values before they are displayed in the Filter List.\n     * @param pathKey - The key for the current node in the tree.\n     * @param level - The level of the current node in the tree (starting at 0).\n     * @param parentPathKeys - The keys of the parent nodes up until the current node (exclusive).\n     * This will be an empty array if the node is at the root level.\n     */",
      "buttons?": "/** Specifies the buttons to be shown in the filter, in the order they should be displayed in.\n     * The options are:\n     *\n     *  - `'apply'`: If the Apply button is present, the filter is only applied after the user hits the Apply button.\n     *  - `'clear'`: The Clear button will clear the (form) details of the filter without removing any active filters on the column.\n     *  - `'reset'`: The Reset button will clear the details of the filter and any active filters on that column.\n     *  - `'cancel'`: The Cancel button will discard any changes that have been made to the filter in the UI, restoring the applied model.\n     */",
      "closeOnApply?": "/** If the Apply button is present, the filter popup will be closed immediately when the Apply\n     * or Reset button is clicked if this is set to `true`.\n     *\n     * @default false\n     */",
      "debounceMs?": "/** Overrides the default debounce time in milliseconds for the filter. Defaults are:\n     * - `TextFilter` and `NumberFilter`: 500ms. (These filters have text field inputs, so a short delay before the input is formatted and the filtering applied is usually appropriate).\n     * - `DateFilter` and `SetFilter`: 0ms\n     */",
      "readOnly?": "/** If set to `true`, disables controls in the filter to mutate its state. Normally this would\n     * be used in conjunction with the Filter API.\n     *\n     * @default false\n     */"
    }
  },
  "ISetFilterTreeListTooltipParams": {
    "meta": {
      "doc": "/** Tooltip params used with the Set Filter Tree List.\n */"
    },
    "type": {
      "level": "number",
      "location": "TooltipLocation",
      "value?": "TValue | null",
      "valueFormatted?": "string | null",
      "colDef?": "ColDef<TData, TValue> | ColGroupDef<TData> | null",
      "column?": "Column<TValue> | ColumnGroup",
      "rowIndex?": "number",
      "node?": "IRowNode<TData>",
      "data?": "TData",
      "hideTooltipCallback?": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "level": "/** Level of the tree (starting at 0). */",
      "location": "/** What part of the application is showing the tooltip, e.g. 'cell', 'header', 'menuItem' etc */",
      "value?": "/** The value to be rendered by the tooltip. */",
      "valueFormatted?": "/** The formatted value to be rendered by the tooltip. */",
      "colDef?": "/** Column / ColumnGroup definition. */",
      "column?": "/** Column / ColumnGroup */",
      "rowIndex?": "/** The index of the row containing the cell rendering the tooltip. */",
      "node?": "/** The row node. */",
      "data?": "/** Data for the row node in question. */",
      "hideTooltipCallback?": "/** A callback function that hides the tooltip */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IShowRowGroupColsService": {
    "meta": {},
    "type": {
      "refresh()": "void",
      "getShowRowGroupCols()": "AgColumn[]",
      "getShowRowGroupCol(id: string)": "AgColumn | undefined"
    }
  },
  "IColumnDropZonesService": {
    "meta": {},
    "type": {
      "getDropZoneSelector()": "ComponentSelector"
    }
  },
  "ISideBarService": {
    "meta": {},
    "type": {
      "getSideBarComp()": "ISideBar",
      "getSideBarSelector()": "ComponentSelector"
    }
  },
  "ISideBar": {
    "meta": {},
    "type": {
      "refresh()": "void",
      "setDisplayed(show: boolean)": "void",
      "setSideBarPosition(position?: 'left' | 'right')": "void",
      "isToolPanelShowing()": "boolean",
      "openToolPanel(key: string, source?: 'sideBarButtonClicked' | 'sideBarInitializing' | 'api')": "void",
      "getToolPanelInstance(key: string)": "IToolPanel | undefined",
      "close(source?: 'sideBarButtonClicked' | 'sideBarInitializing' | 'api')": "void",
      "openedItem()": "string | null",
      "isDisplayed()": "boolean",
      "getDef()": "SideBarDef | undefined",
      "getState()": "SideBarState"
    }
  },
  "ToolPanelDef": {
    "meta": {},
    "type": {
      "id": "string",
      "labelKey": "string",
      "labelDefault": "string",
      "minWidth?": "number",
      "maxWidth?": "number",
      "width?": "number",
      "iconKey": "string",
      "toolPanel?": "any",
      "toolPanelParams?": "any"
    },
    "docs": {
      "id": "/** The unique ID for this panel. Used in the API and elsewhere to refer to the panel. */",
      "labelKey": "/** The key used for localisation for displaying the label. The label is displayed in the tab button. */",
      "labelDefault": "/** The default label if `labelKey` is missing or does not map to valid text through localisation. */",
      "minWidth?": "/** The min width of the tool panel.\n     * @default 100\n     */",
      "maxWidth?": "/** The max width of the tool panel. */",
      "width?": "/** The initial width of the tool panel.\n     * @default $side-bar-panel-width (theme variable)\n     */",
      "iconKey": "/** The key of the icon to be used as a graphical aid beside the label in the side bar. */",
      "toolPanel?": "/** The tool panel component to use as the panel.\n     * The provided panels use components `agColumnsToolPanel` and `agFiltersToolPanel`.\n     * To provide your own custom panel component, you reference it here.\n     */",
      "toolPanelParams?": "/** Customise the parameters provided to the `toolPanel` component. */"
    }
  },
  "SideBarDef": {
    "meta": {},
    "type": {
      "toolPanels?": "(ToolPanelDef | string)[]",
      "defaultToolPanel?": "string",
      "hiddenByDefault?": "boolean",
      "position?": "'left' | 'right'"
    },
    "docs": {
      "toolPanels?": "/** A list of all the panels to place in the side bar. The panels will be displayed in the provided order from top to bottom.\n     */",
      "defaultToolPanel?": "/** The panel (identified by ID) to open by default. If none specified, the side bar is initially displayed closed. */",
      "hiddenByDefault?": "/** To hide the side bar by default, set this to `true`. If left undefined the side bar will be shown. */",
      "position?": "/** Sets the side bar position relative to the grid. */"
    }
  },
  "ISparklineCellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "sparklineOptions?": "SparklineOptions",
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "SparklineOptions": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "LineSparklineOptions | AreaSparklineOptions | ColumnSparklineOptions | BarSparklineOptions"
  },
  "BaseSparklineOptions": {
    "meta": {},
    "type": {
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "PaddingOptions",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyleOptions",
      "tooltip?": "SparklineTooltipOptions"
    },
    "docs": {
      "xKey?": "/** The key to use to retrieve X values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'x'\n     */",
      "yKey?": "/** The key to use to retrieve Y values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'y'\n     */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the items are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "LineSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'line'",
      "line?": "SparklineLineOptions",
      "marker?": "SparklineMarkerOptions",
      "crosshairs?": "SparklineCrosshairsOptions",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "PaddingOptions",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyleOptions",
      "tooltip?": "SparklineTooltipOptions"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'line'`. */",
      "line?": "/** The configuration for the line. */",
      "marker?": "/** The configuration for the marker styles. */",
      "crosshairs?": "/** The configuration for the crosshairs. */",
      "xKey?": "/** The key to use to retrieve X values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'x'\n     */",
      "yKey?": "/** The key to use to retrieve Y values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'y'\n     */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the items are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "AreaSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'area'",
      "fill?": "string",
      "line?": "SparklineLineOptions",
      "marker?": "SparklineMarkerOptions",
      "crosshairs?": "SparklineCrosshairsOptions",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "PaddingOptions",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyleOptions",
      "tooltip?": "SparklineTooltipOptions"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'area'`. */",
      "fill?": "/** The CSS colour value for the fill of the area.\n     * @default 'rgba(124, 181, 236, 0.25)'\n     */",
      "line?": "/** The configuration for the line. */",
      "marker?": "/** The configuration for the marker styles. */",
      "crosshairs?": "/** The configuration for the crosshairs. */",
      "xKey?": "/** The key to use to retrieve X values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'x'\n     */",
      "yKey?": "/** The key to use to retrieve Y values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'y'\n     */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the items are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "ColumnSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'column'",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "paddingInner?": "number",
      "paddingOuter?": "number",
      "valueAxisDomain?": "[ number, number ]",
      "formatter?": "SparklineColumnFormatter",
      "label?": "SparklineLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "PaddingOptions",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyleOptions",
      "tooltip?": "SparklineTooltipOptions"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'column'`. */",
      "fill?": "/** The CSS colour value for the fill of the columns.\n     * @default 'rgb(124, 181, 236)'\n     */",
      "stroke?": "/** The CSS colour value for the outline of the columns.\n     * @default 'silver'\n     */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the columns.\n     * @default 0\n     */",
      "paddingInner?": "/** The size of the gap between the columns as a proportion, between 0 and 1. This value is a fraction of the “step”, which is the interval between the start of a band and the start of the next band.\n     * @default 0.1\n     */",
      "paddingOuter?": "/** The padding on the outside i.e. left and right of the first and last columns, to leave some room for the axis. In association with `paddingInner`, this value can be between 0 and 1.\n     * @default 0.2\n     */",
      "valueAxisDomain?": "/** User override for the automatically determined domain (based on data min and max values). Only applied to `number` axes.\n     * Used to interpolate the numeric pixel values corresponding to each data value.\n     */",
      "formatter?": "/** A callback function to return format styles of type ColumnFormat, based on the data represented by individual columns. */",
      "label?": "/** Configuration for the labels. */",
      "xKey?": "/** The key to use to retrieve X values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'x'\n     */",
      "yKey?": "/** The key to use to retrieve Y values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'y'\n     */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the items are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "BarSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'bar'",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "paddingInner?": "number",
      "paddingOuter?": "number",
      "valueAxisDomain?": "[ number, number ]",
      "formatter?": "SparklineBarFormatter",
      "label?": "SparklineLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "PaddingOptions",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyleOptions",
      "tooltip?": "SparklineTooltipOptions"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'bar'`. */",
      "fill?": "/** The CSS colour value for the fill of the bars.\n     * @default 'rgb(124, 181, 236)'\n     */",
      "stroke?": "/** The CSS colour value for the outline of the bars.\n     * Default `'silver'`\n     */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the bars.\n     * @default 0\n     */",
      "paddingInner?": "/** The size of the gap between the bars as a proportion, between 0 and 1. This value is a fraction of the “step”, which is the interval between the start of a band and the start of the next band.\n     * @default 0.1\n     */",
      "paddingOuter?": "/** The padding on the outside i.e. left and right of the first and last bars, to leave some room for the axis. In association with `paddingInner`, this value can be between 0 and 1.\n     * @default 0.2\n     */",
      "valueAxisDomain?": "/** User override for the automatically determined domain (based on data min and max values). Only applied to `number` axes.\n     * Used to interpolate the numeric pixel values corresponding to each data value.\n     */",
      "formatter?": "/** A callback function to return format styles of type BarFormat, based on the data represented by individual bars. */",
      "label?": "/** Configuration for the labels. */",
      "xKey?": "/** The key to use to retrieve X values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'x'\n     */",
      "yKey?": "/** The key to use to retrieve Y values from the data. This will only be used if the data array contains objects with key-value pairs.\n     * @default 'y'\n     */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the items are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "SparklineLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontSize?": "number",
      "fontFamily?": "string",
      "fontStyle?": "'normal' | 'italic' | 'oblique'",
      "fontWeight?": "'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'",
      "color?": "string",
      "formatter?": "(params: LabelFormatterParams) => string",
      "placement?": "BarColumnLabelPlacement"
    },
    "docs": {
      "enabled?": "/** Set to true to enable labels.\n     * @default false\n     */",
      "fontSize?": "/** Set size of the font.\n     * @default 8\n     */",
      "fontFamily?": "/** Specify the font for the label text.\n     * @default Verdana, sans-serif\n     */",
      "fontStyle?": "/** Specify the font style for the label text. */",
      "fontWeight?": "/** Set how thick or thin characters in label text should be displayed. */",
      "color?": "/** Set the color of the label text. The color can be specified by a color name, a HEX or an RGB value.\n     * @default rgba(70, 70, 70, 1)\n     */",
      "formatter?": "/** A callback function to return the text to be displayed as the label, based on the value represented by the column or bar.\n     * By default the values are simply stringified. */",
      "placement?": "/** Where to render labels relative to the segments.\n     * @default insideEnd\n     */"
    }
  },
  "LabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "number | undefined"
    },
    "docs": {
      "value": "/** The Y value of the data point. */"
    }
  },
  "BarColumnLabelPlacement": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "InsideBase = 'insideBase'",
      "InsideEnd = 'insideEnd'",
      "Center = 'center'",
      "OutsideEnd = 'outsideEnd'"
    ],
    "docs": [
      null,
      null,
      null,
      null
    ]
  },
  "PaddingOptions": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number"
    },
    "docs": {
      "top?": "/** The number of pixels of padding at the top of the sparkline area.\n     * @default 3\n     */",
      "right?": "/** The number of pixels of padding at the right of the sparkline area.\n     * @default 3\n     */",
      "bottom?": "/** The number of pixels of padding at the bottom of the sparkline area.\n     * @default 3\n     */",
      "left?": "/** The number of pixels of padding at the left of the sparkline area.\n     * @default 3\n     */"
    }
  },
  "SparklineAxisOptions": {
    "meta": {},
    "type": {
      "type?": "AxisType",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "type?": "/** The type of axis used to plot the data.\n     * @default 'category'\n     */",
      "stroke?": "/** The CSS colour value for the outline of the axis line.\n     * @default 'rgb(204, 214, 235)'\n     */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the axis line.\n     * @default 1\n     */"
    }
  },
  "AxisType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'number' | 'category' | 'time'"
  },
  "SparklineTooltipOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "container?": "HTMLElement",
      "xOffset?": "number",
      "yOffset?": "number",
      "renderer?": "SparklineTooltipRenderer"
    },
    "docs": {
      "enabled?": "/** Set to false to disable tooltips. */",
      "container?": "/** The element to place the tooltip into. This can be used to confine the tooltip to a specific area which may be outside of the sparkline grid cell. */",
      "xOffset?": "/** The horizontal distance in pixels between the cursor and the top left corner of the tooltip.\n     * @default 10\n     */",
      "yOffset?": "/** The vertical distance in pixels between the cursor and the top left corner of the tooltip.\n     * @default 0\n     */",
      "renderer?": "/** A callback function used to create the content for the tooltips. This function should return an object or a HTML string used to render the tooltip. */"
    }
  },
  "SparklineTooltipRenderer": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params: TooltipRendererParams) => TooltipRendererResult"
  },
  "TooltipRendererResult": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "content?": "string",
      "title?": "string",
      "color?": "string",
      "backgroundColor?": "string",
      "opacity?": "number"
    },
    "docs": {
      "enabled?": "/** Set to false to disable individual tooltip. */",
      "content?": "/** The content to display in each tooltip. */",
      "title?": "/** The title of the tooltip. */",
      "color?": "/** The CSS color for the title text. */",
      "backgroundColor?": "/** The CSS color for the background of the tooltip title. */",
      "opacity?": "/** The opacity of the background for the tooltip title. */"
    }
  },
  "TooltipRendererParams": {
    "meta": {},
    "type": {
      "context?": "any",
      "datum": "any",
      "xValue": "any",
      "yValue": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "SparklineLineOptions": {
    "meta": {},
    "type": {
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "stroke?": "/** The CSS colour value for the line.\n     *  @default 'rgb(124, 181, 236)'\n     */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the line.\n     * @default 1\n     */"
    }
  },
  "HighlightStyleOptions": {
    "meta": {},
    "type": {
      "size?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "size?": "/** The width in pixels of the markers when hovered over. This is only for the Line and Area sparklines as Column and Bar sparklines do not have markers.\n     * @default 6\n     */",
      "fill?": "/** The fill colour of the markers, columns or bars when hovered over. Use `undefined` for no highlight fill.\n     * @default 'yellow'\n     */",
      "stroke?": "/** The CSS colour value for the outline of the markers, columns or bars when hovered over. Use `undefined` for no highlight stroke.\n     * @default 'silver'\n     */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the markers, columns or bars when hovered over.\n     * @default 1\n     */"
    }
  },
  "SparklineCrosshairsOptions": {
    "meta": {},
    "type": {
      "xLine?": "CrosshairLineOptions",
      "yLine?": "CrosshairLineOptions"
    }
  },
  "CrosshairLineOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "stroke?": "string",
      "strokeWidth?": "number",
      "lineDash?": "'dash' | 'dashDot' | 'dashDotDot' | 'dot' | 'longDash' | 'longDashDot' | 'longDashDotDot' | 'shortDash' | 'shortDashDot' | 'shortDashDotDot' | 'shortDot' | 'solid'",
      "lineCap?": "'round' | 'square' | 'butt'"
    },
    "docs": {
      "enabled?": "/** Set to true to show crosshair line.\n     * @default false\n     */",
      "stroke?": "/** The CSS colour value for the crosshair line.\n     * @default rgba(0,0,0, 0.54)\n     */",
      "strokeWidth?": "/** The thickness in pixels for the crosshair line.\n     * @default 1\n     */",
      "lineDash?": "/** Defines how the crosshair stroke is rendered. This can be one of the lineDash style options.\n     * The default is `solid`, this renders a solid stroke with no gaps.\n     * @default 'solid'\n     */",
      "lineCap?": "/** The shape used to draw the end points of the crosshair line.\n     * The options include `butt` (the ends of the line are squared off at the endpoints), `round` (the ends of the line are rounded) and `square` (the ends of the line are squared off by adding a box with width equal to the line's strokeWidth and height equal to half the line's strokeWidth).\n     * @default butt\n     */"
    }
  },
  "SparklineColumnFormatter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params: ColumnFormatterParams) => ColumnFormat"
  },
  "SparklineBarFormatter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params: BarFormatterParams) => BarFormat"
  },
  "ColumnFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "xValue": "any",
      "yValue": "any",
      "width": "number",
      "height": "number",
      "min?": "boolean",
      "max?": "boolean",
      "first?": "boolean",
      "last?": "boolean",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean"
    },
    "docs": {
      "datum": "/** The raw data associated with the specific column. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */",
      "width": "/** The width of the column in pixels. */",
      "height": "/** The height of the column in pixels. */",
      "min?": "/** Whether or not the column is a minimum point. */",
      "max?": "/** Whether or not the column is a maximum point. */",
      "first?": "/** Whether or not the column represents the first data point. */",
      "last?": "/** Whether or not the column represents the last data point. */",
      "fill?": "/** The CSS colour value for the fill of the individual column. */",
      "stroke?": "/** The CSS colour value for the outline of the individual column. */",
      "strokeWidth": "/** The thickness in pixels for the stroke of the individual column. */",
      "highlighted": "/** Whether or not the column is highlighted. */"
    }
  },
  "ColumnFormat": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "fill?": "/** The CSS colour value for the fill of the individual column. */",
      "stroke?": "/** The CSS colour value for the outline of the individual column. */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the individual column.*/"
    }
  },
  "BarFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "xValue": "any",
      "yValue": "any",
      "width": "number",
      "height": "number",
      "min?": "boolean",
      "max?": "boolean",
      "first?": "boolean",
      "last?": "boolean",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean"
    },
    "docs": {
      "datum": "/** The raw data associated with the specific bar. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */",
      "width": "/** The width of the bar in pixels. */",
      "height": "/** The height of the bar in pixels. */",
      "min?": "/** Whether or not the bar is a minimum point. */",
      "max?": "/** Whether or not the bar is a maximum point. */",
      "first?": "/** Whether or not the bar represents the first data point. */",
      "last?": "/** Whether or not the bar represents the last data point. */",
      "fill?": "/** The CSS colour value for the fill of the individual bar. */",
      "stroke?": "/** The CSS colour value for the outline of the individual bar. */",
      "strokeWidth": "/** The thickness in pixels for the stroke of the individual bar. */",
      "highlighted": "/** Whether or not the bar is highlighted. */"
    }
  },
  "BarFormat": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "fill?": "/** The CSS colour value for the fill of the individual bar. */",
      "stroke?": "/** The CSS colour value for the outline of the individual bar. */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the individual bar.*/"
    }
  },
  "SparklineMarkerOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "formatter?": "SparklineMarkerFormatter"
    },
    "docs": {
      "enabled?": "/** By default this is set to `true` whilst marker size is set to `0`, which means the markers are present but not visible.\n     * @default true\n     */",
      "shape?": "/** The shape of the markers.\n     * @default 'circle'\n     */",
      "size?": "/** The width in pixels of markers. By default this is `0`, increase the size to make markers visible.\n     * @default 0\n     */",
      "fill?": "/** The CSS colour value for the fill of the markers.\n     * @default 'rgb(124, 181, 236)'\n     */",
      "stroke?": "/** The CSS colour value for the outline of the markers.\n     * @default 'rgb(124, 181, 236)'\n     */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the markers.\n     * @default 1\n     */",
      "formatter?": "/** A callback function to return format styles for individual markers. */"
    }
  },
  "SparklineMarkerFormatter": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(params: MarkerFormatterParams) => MarkerFormat"
  },
  "MarkerFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "xValue": "any",
      "yValue": "any",
      "min?": "boolean",
      "max?": "boolean",
      "first?": "boolean",
      "last?": "boolean",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "size": "number",
      "highlighted": "boolean"
    },
    "docs": {
      "datum": "/** The raw data associated with the specific marker. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */",
      "min?": "/** Whether or not the marker is a minimum point. */",
      "max?": "/** Whether or not the marker is a maximum point. */",
      "first?": "/** Whether or not the marker represents the first data point. */",
      "last?": "/** Whether or not the marker represents the last data point. */",
      "fill?": "/** The CSS colour value for the fill of the individual marker. */",
      "stroke?": "/** The CSS colour value for the outline of the individual marker. */",
      "strokeWidth": "/** The thickness in pixels for the stroke of the individual marker. */",
      "size": "/** The width in pixels of the individual marker. */",
      "highlighted": "/** Whether or not the marker is highlighted. */"
    }
  },
  "MarkerFormat": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "size?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "enabled?": "/** Set to false to make marker invisible. */",
      "size?": "/** The width in pixels of the individual marker. */",
      "fill?": "/** The CSS colour value for the fill of the individual marker. */",
      "stroke?": "/** The CSS colour value for the outline of the individual marker. */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the individual marker.*/"
    }
  },
  "IStatusBarService": {
    "meta": {},
    "type": {
      "registerStatusPanel(key: string, component: IStatusPanelComp)": "void",
      "getStatusPanel(key: string)": "IStatusPanelComp",
      "getStatusPanelSelector()": "ComponentSelector"
    }
  },
  "StatusPanelDef": {
    "meta": {},
    "type": {
      "statusPanel?": "any",
      "align?": "string",
      "key?": "string",
      "statusPanelParams?": "any"
    }
  },
  "IStatusPanelParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "AggregationStatusPanelAggFunc": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'count' | 'sum' | 'min' | 'max' | 'avg'"
  },
  "IAggregationStatusPanelParams": {
    "meta": {},
    "type": {
      "aggFuncs": "AggregationStatusPanelAggFunc[]"
    }
  },
  "AggregationStatusPanelParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "aggFuncs": "AggregationStatusPanelAggFunc[]",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IStatusPanel": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "boolean"
    },
    "docs": {
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "/** Called when the `statusBar` grid option is updated.\n     * If this method returns `true`,\n     * the grid assumes that the status panel has updated with the latest params,\n     * and takes no further action.\n     * If this method returns `false`, or is not implemented,\n     * the grid will destroy and recreate the status panel.\n     */"
    }
  },
  "IStatusPanelComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "boolean",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IStatusPanelParams<TData, TContext>)": "AgPromise<void> | void"
    },
    "docs": {
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "/** Called when the `statusBar` grid option is updated.\n     * If this method returns `true`,\n     * the grid assumes that the status panel has updated with the latest params,\n     * and takes no further action.\n     * If this method returns `false`, or is not implemented,\n     * the grid will destroy and recreate the status panel.\n     */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IStatusPanelParams<TData, TContext>)": "/** The init(params) method is called on the component once. */"
    }
  },
  "BaseToolPanelParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TState = any"
      ]
    },
    "type": {
      "initialState?": "TState | undefined",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "initialState?": "/** The tool-panel-specific initial state as provided in grid options if applicable */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IToolPanelParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TState = any"
      ]
    },
    "type": {
      "onStateUpdated": "() => void",
      "initialState?": "TState | undefined",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "onStateUpdated": "/** If tool panel is saving and restoring state, this should be called after the state is updated */",
      "initialState?": "/** The tool-panel-specific initial state as provided in grid options if applicable */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IToolPanel": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TState = any"
      ]
    },
    "type": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "boolean | void",
      "getState?()": "TState | undefined"
    },
    "docs": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "/** Called when `api.refreshToolPanel()` is called (with the current params).\n     * Also called when the `sideBar` grid option is updated (with the updated params).\n     * When `sideBar` is updated, if this method returns `true`,\n     * then the grid will take no further action.\n     * Otherwise, the tool panel will be destroyed and recreated.\n     */",
      "getState?()": "/** If saving and restoring state, this should return the current state */"
    }
  },
  "IToolPanelComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TState = any"
      ]
    },
    "type": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "boolean | void",
      "getState?()": "TState | undefined",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IToolPanelParams<TData, TContext, TState>)": "AgPromise<void> | void"
    },
    "docs": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "/** Called when `api.refreshToolPanel()` is called (with the current params).\n     * Also called when the `sideBar` grid option is updated (with the updated params).\n     * When `sideBar` is updated, if this method returns `true`,\n     * then the grid will take no further action.\n     * Otherwise, the tool panel will be destroyed and recreated.\n     */",
      "getState?()": "/** If saving and restoring state, this should return the current state */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IToolPanelParams<TData, TContext, TState>)": "/** The init(params) method is called on the component once. */"
    }
  },
  "ToolPanelColumnCompParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** @deprecated v31.3 - Use `IToolPanelColumnCompParams` instead.\n */"
    },
    "type": {
      "onStateUpdated": "() => void",
      "initialState?": "TState | undefined",
      "api": "GridApi<TData>",
      "context": "TContext",
      "suppressColumnMove": "boolean",
      "suppressRowGroups": "boolean",
      "suppressValues": "boolean",
      "suppressPivots": "boolean",
      "suppressPivotMode": "boolean",
      "suppressColumnFilter": "boolean",
      "suppressColumnSelectAll": "boolean",
      "suppressColumnExpandAll": "boolean",
      "contractColumnSelection": "boolean",
      "suppressSyncLayoutWithGrid": "boolean"
    },
    "docs": {
      "onStateUpdated": "/** If tool panel is saving and restoring state, this should be called after the state is updated */",
      "initialState?": "/** The tool-panel-specific initial state as provided in grid options if applicable */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */",
      "suppressColumnMove": "/** Suppress Column Move */",
      "suppressRowGroups": "/** Suppress Row Groups section */",
      "suppressValues": "/** Suppress Values section */",
      "suppressPivots": "/** Suppress Column Labels (Pivot) section */",
      "suppressPivotMode": "/** Suppress Pivot Mode selection */",
      "suppressColumnFilter": "/** Suppress Column Filter section */",
      "suppressColumnSelectAll": "/** Suppress Select / Un-select all widget */",
      "suppressColumnExpandAll": "/** Suppress Expand / Collapse all widget */",
      "contractColumnSelection": "/** By default, column groups start expanded. Pass `true` to default to contracted groups */",
      "suppressSyncLayoutWithGrid": "/** Suppress updating the layout of columns as they are rearranged in the grid */"
    }
  },
  "IToolPanelColumnCompParams": {
    "meta": {},
    "type": {
      "suppressColumnMove": "boolean",
      "suppressRowGroups": "boolean",
      "suppressValues": "boolean",
      "suppressPivots": "boolean",
      "suppressPivotMode": "boolean",
      "suppressColumnFilter": "boolean",
      "suppressColumnSelectAll": "boolean",
      "suppressColumnExpandAll": "boolean",
      "contractColumnSelection": "boolean",
      "suppressSyncLayoutWithGrid": "boolean"
    },
    "docs": {
      "suppressColumnMove": "/** Suppress Column Move */",
      "suppressRowGroups": "/** Suppress Row Groups section */",
      "suppressValues": "/** Suppress Values section */",
      "suppressPivots": "/** Suppress Column Labels (Pivot) section */",
      "suppressPivotMode": "/** Suppress Pivot Mode selection */",
      "suppressColumnFilter": "/** Suppress Column Filter section */",
      "suppressColumnSelectAll": "/** Suppress Select / Un-select all widget */",
      "suppressColumnExpandAll": "/** Suppress Expand / Collapse all widget */",
      "contractColumnSelection": "/** By default, column groups start expanded. Pass `true` to default to contracted groups */",
      "suppressSyncLayoutWithGrid": "/** Suppress updating the layout of columns as they are rearranged in the grid */"
    }
  },
  "IToolPanelFiltersCompParams": {
    "meta": {},
    "type": {
      "suppressExpandAll": "boolean",
      "suppressFilterSearch": "boolean",
      "suppressSyncLayoutWithGrid": "boolean"
    },
    "docs": {
      "suppressExpandAll": "/** To suppress Expand / Collapse All */",
      "suppressFilterSearch": "/** To suppress the Filter Search */",
      "suppressSyncLayoutWithGrid": "/** Suppress updating the layout of columns as they are rearranged in the grid */"
    }
  },
  "IViewportDatasource": {
    "meta": {},
    "type": {
      "init(params: IViewportDatasourceParams)": "void",
      "setViewportRange(firstRow: number, lastRow: number)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "init(params: IViewportDatasourceParams)": "/** Gets called exactly once before viewPort is used. Passes methods to be used to tell viewPort of data loads / changes. */",
      "setViewportRange(firstRow: number, lastRow: number)": "/** Tell the viewport what the scroll position of the grid is, so it knows what rows it has to get. */",
      "destroy?()": "/** Gets called once when viewPort is no longer used. If you need to do any cleanup, do it here. */"
    }
  },
  "IViewportDatasourceParams": {
    "meta": {},
    "type": {
      "setRowCount": "(count: number, keepRenderedRows?: boolean) => void",
      "setRowData": "(rowData: { [key: number]: any; }) => void",
      "getRow": "(rowIndex: number) => IRowNode"
    },
    "docs": {
      "setRowCount": "/** Datasource calls this method when the total row count changes. This in turn sets the height of the grids vertical scroll. */",
      "setRowData": "/** Datasource calls this when new data arrives. The grid then updates the provided rows. The rows are mapped [rowIndex]=>rowData].*/",
      "getRow": "/** Datasource calls this when it wants a row node - typically used when it wants to update the row node. */"
    }
  },
  "IWatermark": {
    "meta": {},
    "type": {
      "getWatermarkSelector()": "ComponentSelector"
    }
  },
  "XmlElement": {
    "meta": {},
    "type": {
      "name": "string",
      "properties?": "XmlAttributes",
      "children?": "XmlElement[]",
      "textNode?": "string | null"
    }
  },
  "HeaderElement": {
    "meta": {},
    "type": {
      "[key: string]": "string | undefined",
      "version?": "string",
      "standalone?": "string",
      "encoding?": "string"
    }
  },
  "XmlAttributes": {
    "meta": {},
    "type": {
      "prefixedAttributes?": "PrefixedXmlAttributes[]",
      "rawMap?": "any"
    }
  },
  "PrefixedXmlAttributes": {
    "meta": {},
    "type": {
      "prefix": "string",
      "map": "any"
    }
  },
  "IDetailCellRenderer": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "addOrRemoveDetailGridCssClass(cssClassName: string, on: boolean)": "void",
      "setDetailGrid(gridOptions: GridOptions<TData>)": "void",
      "setRowData(rowData: TData[])": "void",
      "getGui()": "HTMLElement"
    }
  },
  "IDetailCellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TDetail = any"
      ]
    },
    "type": {
      "detailGridOptions": "GridOptions<TDetail>",
      "getDetailRowData": "GetDetailRowData<TData, TDetail>",
      "refreshStrategy": "'rows' | 'everything' | 'nothing'",
      "template": "string | TemplateFunc<TData>",
      "agGridReact": "any",
      "frameworkComponentWrapper": "any",
      "pinned": "'left' | 'right' | null | undefined",
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "detailGridOptions": "/** Provide Grid Options to use for the Detail Grid.\n     */",
      "getDetailRowData": "/** A function that provides what rows to display in the Detail Grid. */",
      "refreshStrategy": "/** Defines how to refresh the Detail Grids as data is changing in the Master Grid. */",
      "template": "/** Allows changing the template used around the Detail Grid. */",
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "GetDetailRowData": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any",
        "TDetail = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "GetDetailRowDataParams<TData, TDetail>"
      },
      "returnType": "void"
    }
  },
  "GetDetailRowDataParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TDetail = any"
      ]
    },
    "type": {
      "node": "IRowNode<TData>",
      "data": "TData",
      "successCallback(rowData: TDetail[])": "void"
    },
    "docs": {
      "node": "/** Row node for the details request. */",
      "data": "/** Data for the current row. */",
      "successCallback(rowData: TDetail[])": "/** Success callback: pass the rows back for the grid request.  */"
    }
  },
  "TemplateFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ICellRendererParams<TData>"
      },
      "returnType": "string"
    }
  },
  "IDetailCellRendererCtrl": {
    "meta": {},
    "type": {
      "init(comp: IDetailCellRenderer, params: IDetailCellRendererParams)": "void",
      "registerDetailWithMaster(api: GridApi)": "void",
      "refresh()": "boolean",
      "beanName?": "BeanName",
      "wireBeans?(beans: BeanCollection)": "void",
      "postConstruct?()": "void",
      "destroy?()": "void"
    },
    "docs": {
      "beanName?": "/** AG Grid internal - do not use */",
      "wireBeans?(beans: BeanCollection)": "/** AG Grid internal - do not call */",
      "postConstruct?()": "/** AG Grid internal - do not call */",
      "destroy?()": "/** AG Grid internal - do not call */"
    }
  },
  "MenuItemLeafDef": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "(params: IMenuActionParams<TData, TContext>) => void",
      "checked?": "boolean",
      "icon?": "Element | string",
      "cssClasses?": "string[]",
      "tooltip?": "string",
      "suppressCloseOnSelect?": "boolean"
    },
    "docs": {
      "name": "/** Name of the menu item. */",
      "disabled?": "/** Set to `true` to display the menu item as disabled. */",
      "shortcut?": "/** Shortcut text displayed inside menu item.\n     * Setting this doesn’t actually create a keyboard shortcut binding.\n     */",
      "action?": "/** Function that gets executed when item is chosen. */",
      "checked?": "/** Set to true to provide a check beside the option. */",
      "icon?": "/** The icon to display, either a DOM element or HTML string. */",
      "cssClasses?": "/** CSS classes to apply to the menu item. */",
      "tooltip?": "/** Tooltip text to be displayed for the menu item. */",
      "suppressCloseOnSelect?": "/** If `true`, will keep the menu open when the item is selected.\n     * Note that if this item has a sub menu,\n     * it will always remain open regardless of this property.\n     */"
    }
  },
  "MenuItemDef": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "subMenu?": "(MenuItemDef<TData, TContext> | string)[]",
      "menuItem?": "any",
      "menuItemParams?": "any",
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "(params: IMenuActionParams<TData, TContext>) => void",
      "checked?": "boolean",
      "icon?": "Element | string",
      "cssClasses?": "string[]",
      "tooltip?": "string",
      "suppressCloseOnSelect?": "boolean"
    },
    "docs": {
      "subMenu?": "/** If this item is a sub menu, contains a list of menu item definitions */",
      "menuItem?": "/** Provide a custom menu item component.\n     * See [Menu Item Component](https://www.ag-grid.com/javascript-data-grid/component-menu-item/#implementing-a-menu-item-component) for framework specific implementation details.\n     */",
      "menuItemParams?": "/** Parameters to be passed to the custom menu item component specified in `menuItem`.\n     */",
      "name": "/** Name of the menu item. */",
      "disabled?": "/** Set to `true` to display the menu item as disabled. */",
      "shortcut?": "/** Shortcut text displayed inside menu item.\n     * Setting this doesn’t actually create a keyboard shortcut binding.\n     */",
      "action?": "/** Function that gets executed when item is chosen. */",
      "checked?": "/** Set to true to provide a check beside the option. */",
      "icon?": "/** The icon to display, either a DOM element or HTML string. */",
      "cssClasses?": "/** CSS classes to apply to the menu item. */",
      "tooltip?": "/** Tooltip text to be displayed for the menu item. */",
      "suppressCloseOnSelect?": "/** If `true`, will keep the menu open when the item is selected.\n     * Note that if this item has a sub menu,\n     * it will always remain open regardless of this property.\n     */"
    }
  },
  "IMenuConfigParams": {
    "meta": {},
    "type": {
      "suppressTooltip?": "boolean",
      "suppressClick?": "boolean",
      "suppressMouseDown?": "boolean",
      "suppressMouseOver?": "boolean",
      "suppressKeyboardSelect?": "boolean",
      "suppressTabIndex?": "boolean",
      "suppressAria?": "boolean",
      "suppressRootStyles?": "boolean",
      "suppressFocus?": "boolean"
    },
    "docs": {
      "suppressTooltip?": "/** Suppress the grid-provided tooltip on hover.\n     */",
      "suppressClick?": "/** Suppress handling of click events. If `true`, the component will need to implement its own click event handler.\n     * The grid will no longer handle performing the action and opening the sub menu (if appropriate).\n     */",
      "suppressMouseDown?": "/** Suppress handling of mouse down events. */",
      "suppressMouseOver?": "/** Suppress handling of mouseenter and mouseleave events, If `true`,\n     * The grid will no longer update the active status of the menu item or open sub menus.\n     */",
      "suppressKeyboardSelect?": "/** Suppress handling of keyboard events to select the current item. If `true`,\n     * the grid will not select the menu item on Enter or Space.\n     */",
      "suppressTabIndex?": "/** Suppress setting tabindex on the root element. If `true`,\n     * will need to set tabindex elsewhere for keyboard navigation to work.\n     */",
      "suppressAria?": "/** Suppress setting Aria properties on the root element.\n     */",
      "suppressRootStyles?": "/** Suppress setting CSS classes on the root element. If `true` and\n     * mixing custom menu item components with grid-provided ones,\n     * will need to style with table display rules, as well as adding active and disabled styling.\n     */",
      "suppressFocus?": "/** Suppress focusing the root element when made active. If `true`,\n     * will need to handle keyboard navigation.\n     */"
    }
  },
  "BaseMenuItemParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "level": "number",
      "isAnotherSubMenuOpen": "() => boolean",
      "openSubMenu": "(activateFirstItem?: boolean) => void",
      "closeSubMenu": "() => void",
      "closeMenu": "(event?: KeyboardEvent | MouseEvent) => void",
      "updateTooltip": "(tooltip?: string, shouldDisplayTooltip?: () => boolean) => void",
      "subMenu?": "(MenuItemDef<TData, TContext> | string)[]",
      "menuItem?": "any",
      "menuItemParams?": "any",
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "(params: IMenuActionParams<TData, TContext>) => void",
      "checked?": "boolean",
      "icon?": "Element | string",
      "cssClasses?": "string[]",
      "tooltip?": "string",
      "suppressCloseOnSelect?": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "level": "/** Level within the menu tree (starts at 0). */",
      "isAnotherSubMenuOpen": "/** Returns `true` if another sub menu is open. */",
      "openSubMenu": "/** Open the sub menu for this item.\n     * @param activateFirstItem If `true`, activate the first item in the sub menu.\n     */",
      "closeSubMenu": "/** Close the sub menu for this item. */",
      "closeMenu": "/** Close the entire menu. */",
      "updateTooltip": "/** Updates the grid-provided tooltip this component.\n     * @param tooltip The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "subMenu?": "/** If this item is a sub menu, contains a list of menu item definitions */",
      "menuItem?": "/** Provide a custom menu item component.\n     * See [Menu Item Component](https://www.ag-grid.com/javascript-data-grid/component-menu-item/#implementing-a-menu-item-component) for framework specific implementation details.\n     */",
      "menuItemParams?": "/** Parameters to be passed to the custom menu item component specified in `menuItem`.\n     */",
      "name": "/** Name of the menu item. */",
      "disabled?": "/** Set to `true` to display the menu item as disabled. */",
      "shortcut?": "/** Shortcut text displayed inside menu item.\n     * Setting this doesn’t actually create a keyboard shortcut binding.\n     */",
      "action?": "/** Function that gets executed when item is chosen. */",
      "checked?": "/** Set to true to provide a check beside the option. */",
      "icon?": "/** The icon to display, either a DOM element or HTML string. */",
      "cssClasses?": "/** CSS classes to apply to the menu item. */",
      "tooltip?": "/** Tooltip text to be displayed for the menu item. */",
      "suppressCloseOnSelect?": "/** If `true`, will keep the menu open when the item is selected.\n     * Note that if this item has a sub menu,\n     * it will always remain open regardless of this property.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IMenuItemParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "onItemActivated": "() => void",
      "level": "number",
      "isAnotherSubMenuOpen": "() => boolean",
      "openSubMenu": "(activateFirstItem?: boolean) => void",
      "closeSubMenu": "() => void",
      "closeMenu": "(event?: KeyboardEvent | MouseEvent) => void",
      "updateTooltip": "(tooltip?: string, shouldDisplayTooltip?: () => boolean) => void",
      "subMenu?": "(MenuItemDef<TData, TContext> | string)[]",
      "menuItem?": "any",
      "menuItemParams?": "any",
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "(params: IMenuActionParams<TData, TContext>) => void",
      "checked?": "boolean",
      "icon?": "Element | string",
      "cssClasses?": "string[]",
      "tooltip?": "string",
      "suppressCloseOnSelect?": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "onItemActivated": "/** Callback to let the menu know that the current item has become active.\n     * Required if updating the active status within the menu item.\n     */",
      "level": "/** Level within the menu tree (starts at 0). */",
      "isAnotherSubMenuOpen": "/** Returns `true` if another sub menu is open. */",
      "openSubMenu": "/** Open the sub menu for this item.\n     * @param activateFirstItem If `true`, activate the first item in the sub menu.\n     */",
      "closeSubMenu": "/** Close the sub menu for this item. */",
      "closeMenu": "/** Close the entire menu. */",
      "updateTooltip": "/** Updates the grid-provided tooltip this component.\n     * @param tooltip The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "subMenu?": "/** If this item is a sub menu, contains a list of menu item definitions */",
      "menuItem?": "/** Provide a custom menu item component.\n     * See [Menu Item Component](https://www.ag-grid.com/javascript-data-grid/component-menu-item/#implementing-a-menu-item-component) for framework specific implementation details.\n     */",
      "menuItemParams?": "/** Parameters to be passed to the custom menu item component specified in `menuItem`.\n     */",
      "name": "/** Name of the menu item. */",
      "disabled?": "/** Set to `true` to display the menu item as disabled. */",
      "shortcut?": "/** Shortcut text displayed inside menu item.\n     * Setting this doesn’t actually create a keyboard shortcut binding.\n     */",
      "action?": "/** Function that gets executed when item is chosen. */",
      "checked?": "/** Set to true to provide a check beside the option. */",
      "icon?": "/** The icon to display, either a DOM element or HTML string. */",
      "cssClasses?": "/** CSS classes to apply to the menu item. */",
      "tooltip?": "/** Tooltip text to be displayed for the menu item. */",
      "suppressCloseOnSelect?": "/** If `true`, will keep the menu open when the item is selected.\n     * Note that if this item has a sub menu,\n     * it will always remain open regardless of this property.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "BaseMenuItem": {
    "meta": {},
    "type": {
      "select?()": "void",
      "configureDefaults?()": "boolean | IMenuConfigParams"
    },
    "docs": {
      "select?()": "/** Called when the item is selected, e.g. clicked or Enter is pressed. */",
      "configureDefaults?()": "/** Configure the default grid behaviour for this item, including styling,\n     * and mouse and keyboard interactions.\n     *\n     * @returns `true` to use all default behaviour, `false` to use no default behaviour\n     * (equivalent to `configureDefaults` not being defined),\n     * or `IMenuConfigParams` to choose what default behaviour to use.\n     */"
    }
  },
  "IMenuItem": {
    "meta": {},
    "type": {
      "setActive?(active: boolean)": "void",
      "setExpanded?(expanded: boolean)": "void",
      "select?()": "void",
      "configureDefaults?()": "boolean | IMenuConfigParams"
    },
    "docs": {
      "setActive?(active: boolean)": "/** Called when the item is activated/deactivated, either via mouseover or keyboard navigation. */",
      "setExpanded?(expanded: boolean)": "/** If the item has a sub menu, called when the sub menu is opened/closed. */",
      "select?()": "/** Called when the item is selected, e.g. clicked or Enter is pressed. */",
      "configureDefaults?()": "/** Configure the default grid behaviour for this item, including styling,\n     * and mouse and keyboard interactions.\n     *\n     * @returns `true` to use all default behaviour, `false` to use no default behaviour\n     * (equivalent to `configureDefaults` not being defined),\n     * or `IMenuConfigParams` to choose what default behaviour to use.\n     */"
    }
  },
  "IMenuItemComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: IMenuItemParams<TData, TContext>)": "AgPromise<void> | void",
      "setActive?(active: boolean)": "void",
      "setExpanded?(expanded: boolean)": "void",
      "select?()": "void",
      "configureDefaults?()": "boolean | IMenuConfigParams"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: IMenuItemParams<TData, TContext>)": "/** The init(params) method is called on the component once. */",
      "setActive?(active: boolean)": "/** Called when the item is activated/deactivated, either via mouseover or keyboard navigation. */",
      "setExpanded?(expanded: boolean)": "/** If the item has a sub menu, called when the sub menu is opened/closed. */",
      "select?()": "/** Called when the item is selected, e.g. clicked or Enter is pressed. */",
      "configureDefaults?()": "/** Configure the default grid behaviour for this item, including styling,\n     * and mouse and keyboard interactions.\n     *\n     * @returns `true` to use all default behaviour, `false` to use no default behaviour\n     * (equivalent to `configureDefaults` not being defined),\n     * or `IMenuConfigParams` to choose what default behaviour to use.\n     */"
    }
  },
  "IRenderStatusService": {
    "meta": {},
    "type": {
      "areHeaderCellsRendered()": "boolean"
    },
    "docs": {
      "areHeaderCellsRendered()": "/** Checks that every header cell that is currently visible has been rendered.\n     * Can only be false under some circumstances when using React.\n     */"
    }
  },
  "RowDataTransaction": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "addIndex?": "number | null",
      "add?": "TData[] | null",
      "remove?": "TData[] | null",
      "update?": "TData[] | null"
    },
    "docs": {
      "addIndex?": "/** Index to add rows */",
      "add?": "/** Rows to add */",
      "remove?": "/** Rows to remove */",
      "update?": "/** Rows to update */"
    }
  },
  "RowNodeTransaction": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "add": "IRowNode<TData>[]",
      "remove": "IRowNode<TData>[]",
      "update": "IRowNode<TData>[]"
    },
    "docs": {
      "add": "/** Row nodes added */",
      "remove": "/** Row nodes removed */",
      "update": "/** Row nodes updated */"
    }
  },
  "ServerSideRowSelectionState": {
    "meta": {},
    "type": {
      "selectAll": "boolean",
      "toggledNodes": "string[]"
    },
    "docs": {
      "selectAll": "/** Whether the majority of rows are selected or not */",
      "toggledNodes": "/** All rows that have the opposite selection state to `selectAll` */"
    }
  },
  "ServerSideRowGroupSelectionState": {
    "meta": {},
    "type": {
      "nodeId?": "string",
      "selectAllChildren?": "boolean",
      "toggledNodes?": "ServerSideRowGroupSelectionState[]"
    }
  },
  "ServerSideTransaction": {
    "meta": {},
    "type": {
      "route?": "string[]",
      "addIndex?": "number",
      "add?": "any[]",
      "remove?": "any[]",
      "update?": "any[]"
    },
    "docs": {
      "route?": "/** The Row Store to apply the transaction to, ie what group level.\n     * eg ['Ireland','2002'] to update the child store found after expanding Ireland and 2002 groups.\n     * Passing in blank to empty applies the transaction to the top level.\n     */",
      "addIndex?": "/** Index position to add at. If missing, rows will be added to the end. */",
      "add?": "/** Rows to add */",
      "remove?": "/** Rows to remove */",
      "update?": "/** Rows to update */"
    }
  },
  "ServerSideTransactionResult": {
    "meta": {},
    "type": {
      "status": "ServerSideTransactionResultStatus",
      "add?": "IRowNode[]",
      "remove?": "IRowNode[]",
      "update?": "IRowNode[]"
    },
    "docs": {
      "status": "/** The status of applying the transaction. */",
      "add?": "/** If rows were added, the newly created Row Nodes for those rows. */",
      "remove?": "/** If rows were removed, the deleted Row Nodes. */",
      "update?": "/** If rows were updated, the updated Row Nodes. */"
    }
  },
  "ServerSideTransactionResultStatus": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Applied = 'Applied'",
      "StoreNotFound = 'StoreNotFound'",
      "StoreLoading = 'StoreLoading'",
      "StoreWaitingToLoad = 'StoreWaitingToLoad'",
      "StoreLoadingFailed = 'StoreLoadingFailed'",
      "StoreWrongType = 'StoreWrongType'",
      "Cancelled = 'Cancelled'",
      "StoreNotStarted = 'StoreNotStarted'"
    ],
    "docs": [
      "/** Transaction was successfully applied */",
      "/** Store was not found, transaction not applied.\n     * Either invalid route, or the parent row has not yet been expanded.\n     */",
      "/** Store is loading, transaction not applied.\n     */",
      "/** Store is loading (as max loads exceeded), transaction not applied.\n     */",
      "/** Store load attempt failed, transaction not applied.\n     */",
      "/** Store is type Partial, which doesn't accept transactions\n     */",
      "/** Transaction was cancelled, due to grid.\n     * Callback isApplyServerSideTransaction() returning false\n     */",
      "/** Store has not started yet, transaction not applied\n     */"
    ]
  },
  "TaskItem": {
    "meta": {},
    "type": {
      "task": "() => void",
      "index": "number",
      "createOrder": "number"
    }
  },
  "TaskList": {
    "meta": {},
    "type": {
      "list": "TaskItem[]",
      "sorted": "boolean"
    }
  },
  "BaseShowColumnMenuParams": {
    "meta": {},
    "type": {
      "column?": "Column"
    }
  },
  "BaseShowFilterMenuParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "containerType": "ContainerType"
    }
  },
  "MouseShowMenuParams": {
    "meta": {},
    "type": {
      "mouseEvent": "MouseEvent | Touch",
      "positionBy": "'mouse'"
    }
  },
  "ButtonShowMenuParams": {
    "meta": {},
    "type": {
      "buttonElement": "HTMLElement",
      "positionBy": "'button'"
    }
  },
  "AutoShowMenuParams": {
    "meta": {},
    "type": {
      "positionBy": "'auto'"
    }
  },
  "ShowColumnMenuParams": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(MouseShowMenuParams | ButtonShowMenuParams | AutoShowMenuParams) & BaseShowColumnMenuParams"
  },
  "ShowFilterMenuParams": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(MouseShowMenuParams | ButtonShowMenuParams | AutoShowMenuParams) & BaseShowFilterMenuParams"
  },
  "ShowContextMenuParams": {
    "meta": {},
    "type": {
      "rowNode?": "RowNode | null",
      "column?": "Column | null",
      "value": "any"
    },
    "docs": {
      "rowNode?": "/** The `RowNode` associated with the Context Menu */",
      "column?": "/** The `Column` associated with the Context Menu */",
      "value": "/** The value that will be passed to the Context Menu (useful with `getContextMenuItems`). If none is passed, and `RowNode` and `Column` are provided, this will be the respective Cell value */"
    }
  },
  "MouseShowContextMenuParams": {
    "meta": {},
    "type": {
      "mouseEvent": "MouseEvent"
    }
  },
  "TouchShowContextMenuParam": {
    "meta": {},
    "type": {
      "touchEvent": "TouchEvent"
    }
  },
  "EventShowContextMenuParams": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(MouseShowContextMenuParams | TouchShowContextMenuParam) & ShowContextMenuParams"
  },
  "IContextMenuParams": {
    "meta": {},
    "type": {
      "x?": "number",
      "y?": "number",
      "rowNode?": "RowNode | null",
      "column?": "Column | null",
      "value": "any"
    },
    "docs": {
      "x?": "/** The x position for the Context Menu, if no value is given and `RowNode` and `Column` are provided, this will default to be middle of the cell, otherwise it will be `0`. */",
      "y?": "/** The y position for the Context Menu, if no value is given and `RowNode` and `Column` are provided, this will default to be middle of the cell, otherwise it will be `0`. */",
      "rowNode?": "/** The `RowNode` associated with the Context Menu */",
      "column?": "/** The `Column` associated with the Context Menu */",
      "value": "/** The value that will be passed to the Context Menu (useful with `getContextMenuItems`). If none is passed, and `RowNode` and `Column` are provided, this will be the respective Cell value */"
    }
  },
  "ModuleNames": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "CommunityCoreModule = '@ag-grid-community/core'",
      "InfiniteRowModelModule = '@ag-grid-community/infinite-row-model'",
      "ClientSideRowModelModule = '@ag-grid-community/client-side-row-model'",
      "CsvExportModule = '@ag-grid-community/csv-export'",
      "EnterpriseCoreModule = '@ag-grid-enterprise/core'",
      "RowGroupingModule = '@ag-grid-enterprise/row-grouping'",
      "ColumnsToolPanelModule = '@ag-grid-enterprise/column-tool-panel'",
      "FiltersToolPanelModule = '@ag-grid-enterprise/filter-tool-panel'",
      "MenuModule = '@ag-grid-enterprise/menu'",
      "SetFilterModule = '@ag-grid-enterprise/set-filter'",
      "MultiFilterModule = '@ag-grid-enterprise/multi-filter'",
      "StatusBarModule = '@ag-grid-enterprise/status-bar'",
      "SideBarModule = '@ag-grid-enterprise/side-bar'",
      "RangeSelectionModule = '@ag-grid-enterprise/range-selection'",
      "MasterDetailModule = '@ag-grid-enterprise/master-detail'",
      "RichSelectModule = '@ag-grid-enterprise/rich-select'",
      "GridChartsModule = '@ag-grid-enterprise/charts'",
      "ViewportRowModelModule = '@ag-grid-enterprise/viewport-row-model'",
      "ServerSideRowModelModule = '@ag-grid-enterprise/server-side-row-model'",
      "ExcelExportModule = '@ag-grid-enterprise/excel-export'",
      "ClipboardModule = '@ag-grid-enterprise/clipboard'",
      "SparklinesModule = '@ag-grid-enterprise/sparklines'",
      "AdvancedFilterModule = '@ag-grid-enterprise/advanced-filter'",
      "AngularModule = '@ag-grid-community/angular'",
      "ReactModule = '@ag-grid-community/react'",
      "VueModule = '@ag-grid-community/vue'"
    ],
    "docs": [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    ]
  },
  "GridOptionKey": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "keyof GridOptions"
  },
  "AnyGridOptions": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ [K in keyof GridOptions]: GridOptions[K] extends 'NO_MATCH' ? K : never; }[keyof GridOptions]"
  },
  "KeysLike": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "U"
      ]
    },
    "type": "Exclude<GetKeys<GridOptions, U>, undefined>"
  },
  "CallbackKeys": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "KeysOfType<(any: AgGridCommon<any, any>) => any>"
  },
  "FunctionKeys": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Exclude<KeysLike<Function>, CallbackKeys>"
  },
  "InitialGridOptionKey": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "keyof typeof INITIAL_GRID_OPTION_KEYS"
  },
  "ManagedGridOptionKey": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Exclude<GridOptionKey, InitialGridOptionKey>"
  },
  "ManagedGridOptions": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": "{[K in ManagedGridOptionKey]?: GridOptions<TData>[K]}"
  },
  "ICellComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setUserStyles(styles: CellStyle)": "void",
      "getFocusableElement()": "HTMLElement",
      "setIncludeSelection(include: boolean)": "void",
      "setIncludeRowDrag(include: boolean)": "void",
      "setIncludeDndSource(include: boolean)": "void",
      "getCellEditor()": "ICellEditor | null",
      "getCellRenderer()": "ICellRenderer | null",
      "getParentOfValue()": "HTMLElement | null",
      "setRenderDetails(compDetails: UserCompDetails | undefined, valueToDisplay: any, forceNewCellRendererInstance: boolean)": "void",
      "setEditDetails(compDetails?: UserCompDetails, popup?: boolean, position?: 'over' | 'under', reactiveCustomComponents?: boolean)": "void"
    }
  },
  "CellCtrlInstanceId": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "BrandedType<string, 'CellCtrlInstanceId'>"
  },
  "ICheckboxCellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "disabled?": "boolean",
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "disabled?": "/** Set to `true` for the input to be disabled. */",
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ICellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ISetFilterCellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "any",
      "valueFormatted": "string | null | undefined",
      "colDef?": "ColDef",
      "column?": "Column",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ICellRenderer": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "refresh(params: ICellRendererParams<TData>)": "boolean"
    },
    "docs": {
      "refresh(params: ICellRendererParams<TData>)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n     * then the grid will refresh the cell for you.\n     */"
    }
  },
  "ICellRendererComp": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: ICellRendererParams<TData>)": "AgPromise<void> | void",
      "refresh(params: ICellRendererParams<TData>)": "boolean"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: ICellRendererParams<TData>)": "/** The init(params) method is called on the component once. */",
      "refresh(params: ICellRendererParams<TData>)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n     * then the grid will refresh the cell for you.\n     */"
    }
  },
  "ICellRendererFunc": {
    "meta": {
      "isCallSignature": true,
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "arguments": {
        "params": "ICellRendererParams<TData>"
      },
      "returnType": "HTMLElement | string"
    }
  },
  "ILoadingCellRendererParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ILoadingCellRenderer": {
    "meta": {},
    "type": {}
  },
  "ILoadingCellRendererComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: ILoadingCellRendererParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: ILoadingCellRendererParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "PositionableOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/** Used for when a popup needs to be resized by an element within itself\n     * In that case, the feature will configured as `popup=false` but the offsetParent\n     * needs to be the popupParent.\n     */"
    }
  },
  "ResizableSides": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'topLeft' | 'top' | 'topRight' | 'right' | 'bottomRight' | 'bottom' | 'bottomLeft' | 'left'"
  },
  "ResizableStructure": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{[key in ResizableSides]?: boolean}"
  },
  "MappedResizer": {
    "meta": {},
    "type": {
      "element": "HTMLElement",
      "dragSource?": "DragListenerParams"
    }
  },
  "PositionableFeatureEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'resize'"
  },
  "ILoadingOverlayParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ILoadingOverlay": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "refresh?(params: TParams)": "void"
    }
  },
  "ILoadingOverlayComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: TParams)": "AgPromise<void> | void",
      "refresh?(params: TParams)": "void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: TParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "INoRowsOverlayParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "INoRowsOverlay": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "refresh?(params: TParams)": "void"
    }
  },
  "INoRowsOverlayComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: TParams)": "AgPromise<void> | void",
      "refresh?(params: TParams)": "void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: TParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "IOverlayParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ]
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "IOverlay": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TParams extends Readonly<IOverlayParams<TData, TContext>> = IOverlayParams<TData, TContext>"
      ]
    },
    "type": {
      "refresh?(params: TParams)": "void"
    }
  },
  "IOverlayComp": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TParams extends Readonly<IOverlayParams<TData, TContext>> = IOverlayParams<TData, TContext>"
      ]
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: TParams)": "AgPromise<void> | void",
      "refresh?(params: TParams)": "void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: TParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "OverlayServiceState": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "Hidden = 0",
      "Loading = 1",
      "NoRows = 2"
    ],
    "docs": [
      null,
      null,
      null
    ]
  },
  "RowCssClassCalculatorParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowIsEven": "boolean",
      "rowLevel": "number",
      "fullWidthRow?": "boolean",
      "firstRowOnPage": "boolean",
      "lastRowOnPage": "boolean",
      "printLayout": "boolean",
      "expandable": "boolean",
      "pinned": "ColumnPinnedType",
      "extraCssClass?": "string",
      "rowFocused?": "boolean",
      "fadeRowIn?": "boolean"
    }
  },
  "RowType": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'Normal' | 'FullWidth' | 'FullWidthLoading' | 'FullWidthGroup' | 'FullWidthDetail'"
  },
  "RowCtrlInstanceId": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "BrandedType<string, 'RowCtrlInstanceId'>"
  },
  "IRowComp": {
    "meta": {},
    "type": {
      "setDomOrder(domOrder: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setCellCtrls(cellCtrls: CellCtrl[], useFlushSync: boolean)": "void",
      "showFullWidth(compDetails: UserCompDetails)": "void",
      "getFullWidthCellRenderer()": "ICellRenderer | null | undefined",
      "setTop(top: string)": "void",
      "setTransform(transform: string)": "void",
      "setRowIndex(rowIndex: string)": "void",
      "setRowId(rowId: string)": "void",
      "setRowBusinessKey(businessKey: string)": "void",
      "setUserStyles(styles: RowStyle | undefined)": "void",
      "refreshFullWidth(getUpdatedParams: () => ICellRendererParams)": "boolean"
    }
  },
  "RowGui": {
    "meta": {},
    "type": {
      "rowComp": "IRowComp",
      "element": "HTMLElement",
      "containerType": "RowContainerType"
    }
  },
  "CellCtrlListAndMap": {
    "meta": {},
    "type": {
      "list": "CellCtrl[]",
      "map": "{ [key: ColumnInstanceId]: CellCtrl; }"
    }
  },
  "RowCtrlEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "RenderedRowEvent"
  },
  "IRowDragItem": {
    "meta": {},
    "type": {
      "defaultTextValue": "string",
      "rowNode?": "IRowNode",
      "rowNodes?": "IRowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{ [key: string]: boolean; }",
      "pivotState?": "{ [key: string]: { pivot?: boolean; rowGroup?: boolean; aggFunc?: string | IAggFunc | null; }; }",
      "value?": "TValue"
    },
    "docs": {
      "defaultTextValue": "/** The default text that would be applied to this Drag Element */",
      "rowNode?": "/** When dragging a row, this contains the row node being dragged\n     * When dragging multiple rows, this contains the row that started the drag.\n     */",
      "rowNodes?": "/** When dragging multiple rows, this contains all rows being dragged */",
      "columns?": "/** When dragging columns, this contains the columns being dragged */",
      "visibleState?": "/** When dragging columns, this contains the visible state of the columns */",
      "pivotState?": "/** When dragging columns, this contains the pivot state of the columns. This is only populated/used in column tool panel */",
      "value?": "/** Additional state */"
    }
  },
  "RowCtrlIdMap": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Record<RowCtrlInstanceId, RowCtrl>"
  },
  "RowCtrlByRowIndex": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Record<number, RowCtrl>"
  },
  "RowCtrlByRowNodeIdMap": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "Record<string, RowCtrl>"
  },
  "RowNodeMap": {
    "meta": {},
    "type": {
      "[id: string]": "IRowNode"
    }
  },
  "GetCellsParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "rowNodes?": "IRowNode<TData>[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "RefreshCellsParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "force?": "boolean",
      "suppressFlash?": "boolean",
      "rowNodes?": "IRowNode<TData>[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "force?": "/** Skip change detection, refresh everything. */",
      "suppressFlash?": "/** Skip cell flashing, if cell flashing is enabled. */",
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "FlashCellsParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "flashDelay?": "number",
      "fadeDelay?": "number",
      "flashDuration?": "number",
      "fadeDuration?": "number",
      "rowNodes?": "IRowNode<TData>[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "flashDelay?": "/** @deprecated v31.1 Use `flashDuration` instead. */",
      "fadeDelay?": "/** @deprecated v31.1 Use `fadeDuration` instead. */",
      "flashDuration?": "/** The duration in milliseconds of how long a cell should remain in its \"flashed\" state. */",
      "fadeDuration?": "/** The duration in milliseconds of how long the \"flashed\" state animation takes to fade away after the timer set by `flashDuration` has completed. */",
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "GetCellRendererInstancesParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "rowNodes?": "IRowNode<TData>[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "GetCellEditorInstancesParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "rowNodes?": "IRowNode<TData>[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "RedrawRowsParams": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "rowNodes?": "IRowNode<TData>[]"
    },
    "docs": {
      "rowNodes?": "/** Row nodes to redraw */"
    }
  },
  "RefreshViewParams": {
    "meta": {},
    "type": {
      "recycleRows?": "boolean",
      "animate?": "boolean",
      "suppressKeepFocus?": "boolean",
      "onlyBody?": "boolean",
      "newData?": "boolean",
      "newPage?": "boolean",
      "domLayoutChanged?": "boolean"
    }
  },
  "TooltipLocation": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'advancedFilter' | 'cell' | 'columnToolPanelColumn' | 'columnToolPanelColumnGroup' | 'filterToolPanelColumnGroup' | 'fullWidthRow' | 'header' | 'headerGroup' | 'menu' | 'pivotColumnsList' | 'rowGroupColumnsList' | 'setFilterValue' | 'valueColumnsList' | 'UNKNOWN'"
  },
  "ITooltipParams": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ]
    },
    "type": {
      "location": "TooltipLocation",
      "value?": "TValue | null",
      "valueFormatted?": "string | null",
      "colDef?": "ColDef<TData, TValue> | ColGroupDef<TData> | null",
      "column?": "Column<TValue> | ColumnGroup",
      "rowIndex?": "number",
      "node?": "IRowNode<TData>",
      "data?": "TData",
      "hideTooltipCallback?": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "location": "/** What part of the application is showing the tooltip, e.g. 'cell', 'header', 'menuItem' etc */",
      "value?": "/** The value to be rendered by the tooltip. */",
      "valueFormatted?": "/** The formatted value to be rendered by the tooltip. */",
      "colDef?": "/** Column / ColumnGroup definition. */",
      "column?": "/** Column / ColumnGroup */",
      "rowIndex?": "/** The index of the row containing the cell rendering the tooltip. */",
      "node?": "/** The row node. */",
      "data?": "/** Data for the row node in question. */",
      "hideTooltipCallback?": "/** A callback function that hides the tooltip */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "ITooltipComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "init?(params: ITooltipParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "init?(params: ITooltipParams)": "/** The init(params) method is called on the component once. */"
    }
  },
  "LoadCompleteEvent": {
    "meta": {},
    "type": {
      "success": "boolean",
      "block": "RowNodeBlock",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "LoadSuccessParams": {
    "meta": {},
    "type": {
      "rowData": "any[]",
      "rowCount?": "number",
      "groupLevelInfo?": "any",
      "pivotResultFields?": "string[]"
    },
    "docs": {
      "rowData": "/** Data retrieved from the server as requested by the grid.\n     */",
      "rowCount?": "/** The last row, if known, to help Infinite Scroll.\n     */",
      "groupLevelInfo?": "/** Any extra information for the grid to associate with this load.\n     */",
      "pivotResultFields?": "/** The pivot fields in the response - if provided the grid will attempt to generate secondary columns.\n     */"
    }
  },
  "RowNodeBlockState": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'needsLoading' | 'loading' | 'loaded' | 'failed'"
  },
  "RowNodeBlockEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'loadComplete'"
  },
  "RowNodeBlockLoaderEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'blockLoaded' | 'blockLoaderFinished'"
  },
  "SortOption": {
    "meta": {},
    "type": {
      "sort": "'asc' | 'desc'",
      "column": "Column"
    }
  },
  "SortedRowNode": {
    "meta": {},
    "type": {
      "currentPos": "number",
      "rowNode": "RowNode"
    }
  },
  "ISelectionContext": {
    "meta": {
      "typeParams": [
        "TNode"
      ]
    },
    "type": {
      "init(rowModel: IRowModel)": "void",
      "reset()": "void",
      "setRoot(node: TNode)": "void",
      "setEndRange(node: TNode)": "void",
      "getRange()": "RowNode[]",
      "getRoot()": "TNode | null",
      "isInRange(node: TNode)": "boolean",
      "truncate(node: TNode)": "{ keep: RowNode[]; discard: RowNode[]; }",
      "extend(node: TNode, groupSelectsChildren?: boolean)": "{ keep: RowNode[]; discard: RowNode[]; }"
    }
  },
  "SortModelItem": {
    "meta": {},
    "type": {
      "colId": "string",
      "sort": "'asc' | 'desc'"
    },
    "docs": {
      "colId": "/** Column Id to apply the sort to. */",
      "sort": "/** Sort direction */"
    }
  },
  "LayoutView": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "LayoutCssClasses": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "AUTO_HEIGHT = 'ag-layout-auto-height'",
      "NORMAL = 'ag-layout-normal'",
      "PRINT = 'ag-layout-print'"
    ],
    "docs": [
      null,
      null,
      null
    ]
  },
  "UpdateLayoutClassesParams": {
    "meta": {},
    "type": {
      "autoHeight": "boolean",
      "normal": "boolean",
      "print": "boolean"
    }
  },
  "GenericFunction": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "(...args: any[]) => any"
  },
  "PickByTypeKeyFilter": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T",
        "C"
      ]
    },
    "type": "{[K in keyof T]: T[K] extends C ? K : never}"
  },
  "KeysByType": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T",
        "C"
      ]
    },
    "type": "PickByTypeKeyFilter<T, C>[keyof T]"
  },
  "ValuesByType": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T",
        "C"
      ]
    },
    "type": "{[K in keyof T]: T[K] extends C ? T[K] : never}"
  },
  "PickByType": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T",
        "C"
      ]
    },
    "type": "Pick<ValuesByType<T, C>, KeysByType<T, C>>"
  },
  "MethodsOf": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "KeysByType<Required<T>, GenericFunction>"
  },
  "InterfaceOf": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "PickByType<T, GenericFunction>"
  },
  "PartiallyMockedInterfaceOf": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "{[K in MethodsOf<T>]?: jest.Mock<InterfaceOf<T>[K]>}"
  },
  "CellValueChange": {
    "meta": {},
    "type": {
      "rowPinned": "RowPinnedType",
      "rowIndex": "number",
      "columnId": "string",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "LastFocusedCell": {
    "meta": {},
    "type": {
      "rowPinned": "RowPinnedType",
      "rowIndex": "number",
      "columnId": "string"
    }
  },
  "ColumnSortState": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'ascending' | 'descending' | 'other' | 'none'"
  },
  "PathItem": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "children": "PathItem[] | null"
    }
  },
  "ResolveAndRejectCallback": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "(resolve: (value: T | null) => void, reject: (params: any) => void) => void"
  },
  "AgPromiseStatus": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "IN_PROGRESS",
      "RESOLVED"
    ],
    "docs": [
      null,
      null
    ]
  },
  "StartsWithApiFunctionName": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "`${ApiFunctionName}${string}`"
  },
  "OptionsValidator": {
    "meta": {
      "typeParams": [
        "T extends object"
      ]
    },
    "type": {
      "objectName": "string",
      "allProperties?": "string[]",
      "propertyExceptions?": "string[]",
      "docsUrl?": "`${string}/`",
      "deprecations": "Deprecations<T>",
      "validations": "Validations<T>"
    }
  },
  "Deprecations": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T extends object"
      ]
    },
    "type": "Partial<{ [key in keyof T]: { version: string; message?: string; } | { version: string; renamed: keyof T; }; }>"
  },
  "TypeOfArray": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T"
      ]
    },
    "type": "NonNullable<T extends Array<infer U> ? U : T>"
  },
  "Validations": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T extends object"
      ]
    },
    "type": "Partial<{ [key in keyof T]: (TypeOfArray<T[key]> extends object ? () => OptionsValidator<TypeOfArray<T[key]>> : never) | ((options: T, gridOptions: GridOptions) => OptionsValidation<T> | null) | OptionsValidation<T> | undefined; }>"
  },
  "OptionsValidation": {
    "meta": {
      "typeParams": [
        "T extends object"
      ]
    },
    "type": {
      "module?": "ModuleNames | ModuleNames[]",
      "supportedRowModels?": "RowModelType[]",
      "dependencies?": "DependencyValidator<T>"
    }
  },
  "DependencyValidator": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T extends object"
      ]
    },
    "type": "RequiredOptions<T> | ((options: T, gridOptions: GridOptions) => string | null)"
  },
  "RequiredOptions": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "T extends object"
      ]
    },
    "type": "{[K in keyof T]: T[K][]}"
  },
  "FieldElement": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement"
  },
  "AgAbstractFieldEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'fieldValueChanged'"
  },
  "AgAbstractInputFieldEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "AgAbstractFieldEvent"
  },
  "AgAbstractLabelEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "ComponentEvent"
  },
  "AgInputNumberFieldParams": {
    "meta": {},
    "type": {
      "precision?": "number",
      "step?": "number",
      "min?": "number",
      "max?": "number",
      "allowedCharPattern?": "string",
      "inputName?": "string",
      "inputWidth?": "number | 'flex'",
      "template?": "string",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "AgInputTextFieldParams": {
    "meta": {},
    "type": {
      "allowedCharPattern?": "string",
      "inputName?": "string",
      "inputWidth?": "number | 'flex'",
      "template?": "string",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "AgInputTextFieldEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "AgAbstractInputFieldEvent"
  },
  "ListOption": {
    "meta": {
      "typeParams": [
        "TValue = string"
      ]
    },
    "type": {
      "value": "TValue",
      "text?": "string"
    }
  },
  "AgListEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'fieldValueChanged' | 'selectedItem'"
  },
  "AgPickerFieldEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "AgAbstractFieldEvent"
  },
  "AgRadioButtonParams": {
    "meta": {},
    "type": {
      "readOnly?": "boolean",
      "passive?": "boolean",
      "inputName?": "string",
      "inputWidth?": "number | 'flex'",
      "template?": "string",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "AgSelectParams": {
    "meta": {
      "typeParams": [
        "TValue = string"
      ]
    },
    "type": {
      "options?": "ListOption<TValue>[]",
      "pickerType?": "string",
      "pickerAriaLabelKey?": "string",
      "pickerAriaLabelValue?": "string",
      "placeholder?": "string",
      "pickerGap?": "number",
      "variableWidth?": "boolean",
      "minPickerWidth?": "number | string",
      "maxPickerWidth?": "number | string",
      "maxPickerHeight?": "number | string",
      "template?": "string",
      "agComponents?": "ComponentSelector[]",
      "className?": "string",
      "pickerIcon?": "string",
      "ariaRole?": "string",
      "modalPicker?": "boolean",
      "inputWidth?": "number | 'flex'",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    },
    "docs": {
      "variableWidth?": "/** If true, will set min-width and max-width (if present), and will set width to wrapper element width.\n     * If false, will set min-width, max-width and width to maxPickerWidth or wrapper element width.\n     */"
    }
  },
  "AgSelectEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'selectedItem'"
  },
  "AgToggleButtonParams": {
    "meta": {},
    "type": {
      "readOnly?": "boolean",
      "passive?": "boolean",
      "inputName?": "string",
      "inputWidth?": "number | 'flex'",
      "template?": "string",
      "value?": "any",
      "width?": "number",
      "onValueChange?": "(value?: any) => void",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "disabled?": "boolean"
    }
  },
  "ComponentEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'displayChanged' | BeanStubEvent"
  },
  "VisibleChangedEvent": {
    "meta": {},
    "type": {
      "visible": "boolean",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "ComponentSelector": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "{ component: { new (params?: any): Component<any>; }; selector: AgComponentSelector; }"
  },
  "AgComponentSelector": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'AG-AUTOCOMPLETE' | 'AG-CHECKBOX' | 'AG-COLOR-INPUT' | 'AG-COLOR-PICKER' | 'AG-FAKE-HORIZONTAL-SCROLL' | 'AG-FAKE-VERTICAL-SCROLL' | 'AG-FILTERS-TOOL-PANEL-HEADER' | 'AG-FILTERS-TOOL-PANEL-LIST' | 'AG-GRID-BODY' | 'AG-GRID-HEADER-DROP-ZONES' | 'AG-GROUP-COMPONENT' | 'AG-HEADER-ROOT' | 'AG-INPUT-DATE-FIELD' | 'AG-INPUT-NUMBER-FIELD' | 'AG-INPUT-RANGE' | 'AG-INPUT-TEXT-AREA' | 'AG-INPUT-TEXT-FIELD' | 'AG-NAME-VALUE' | 'AG-OVERLAY-WRAPPER' | 'AG-PAGE-SIZE-SELECTOR' | 'AG-PAGINATION' | 'AG-PRIMARY-COLS-HEADER' | 'AG-PRIMARY-COLS-LIST' | 'AG-PRIMARY-COLS' | 'AG-ROW-CONTAINER' | 'AG-SELECT' | 'AG-SIDE-BAR' | 'AG-SIDE-BAR-BUTTONS' | 'AG-SLIDER' | 'AG-SORT-INDICATOR' | 'AG-STATUS-BAR' | 'AG-TOGGLE-BUTTON' | 'AG-WATERMARK'"
  },
  "ManagedFocusCallbacks": {
    "meta": {},
    "type": {
      "shouldStopEventPropagation?": "(e: KeyboardEvent) => boolean",
      "onTabKeyDown?": "(e: KeyboardEvent) => void",
      "handleKeyDown?": "(e: KeyboardEvent) => void",
      "onFocusIn?": "(e: FocusEvent) => void",
      "onFocusOut?": "(e: FocusEvent) => void"
    }
  },
  "PopupPositionParams": {
    "meta": {},
    "type": {
      "ePopup": "HTMLElement",
      "column?": "AgColumn | null",
      "rowNode?": "IRowNode | null",
      "nudgeX?": "number",
      "nudgeY?": "number",
      "position?": "'over' | 'under'",
      "alignSide?": "'left' | 'right'",
      "keepWithinBounds?": "boolean",
      "skipObserver?": "boolean",
      "updatePosition?": "() => { x: number; y: number; }",
      "postProcessCallback?": "() => void"
    }
  },
  "PopupEventParams": {
    "meta": {},
    "type": {
      "originalMouseEvent?": "MouseEvent | Touch | null",
      "mouseEvent?": "MouseEvent",
      "touchEvent?": "TouchEvent",
      "keyboardEvent?": "KeyboardEvent",
      "forceHide?": "boolean"
    }
  },
  "AgPopup": {
    "meta": {},
    "type": {
      "element": "HTMLElement",
      "wrapper": "HTMLElement",
      "hideFunc": "(params?: PopupEventParams) => void",
      "isAnchored": "boolean",
      "instanceId": "number",
      "alignedToElement?": "HTMLElement",
      "stopAnchoringPromise?": "AgPromise<() => void>"
    }
  },
  "DIRECTION": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "vertical",
      "horizontal"
    ],
    "docs": [
      null,
      null
    ]
  },
  "AddPopupParams": {
    "meta": {},
    "type": {
      "modal?": "boolean",
      "eChild": "HTMLElement",
      "closeOnEsc?": "boolean",
      "closedCallback?": "(e?: MouseEvent | TouchEvent | KeyboardEvent) => void",
      "click?": "MouseEvent | Touch | null",
      "alwaysOnTop?": "boolean",
      "afterGuiAttached?": "(params: IAfterGuiAttachedParams) => void",
      "positionCallback?": "() => void",
      "anchorToElement?": "HTMLElement",
      "ariaLabel": "string"
    }
  },
  "AddPopupResult": {
    "meta": {},
    "type": {
      "hideFunc": "(params?: PopupEventParams) => void"
    }
  },
  "TabGuardClassNames": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "TAB_GUARD = 'ag-tab-guard'",
      "TAB_GUARD_TOP = 'ag-tab-guard-top'",
      "TAB_GUARD_BOTTOM = 'ag-tab-guard-bottom'"
    ],
    "docs": [
      null,
      null,
      null
    ]
  },
  "ITabGuard": {
    "meta": {},
    "type": {
      "setTabIndex(tabIndex?: string)": "void"
    }
  },
  "TabGuardParams": {
    "meta": {},
    "type": {
      "focusInnerElement?": "(fromBottom: boolean) => void",
      "shouldStopEventPropagation?": "() => boolean",
      "onFocusIn?": "(e: FocusEvent) => void",
      "onFocusOut?": "(e: FocusEvent) => void",
      "onTabKeyDown?": "(e: KeyboardEvent) => void",
      "handleKeyDown?": "(e: KeyboardEvent) => void",
      "focusTrapActive?": "boolean",
      "forceFocusOutWhenTabGuardsAreEmpty?": "boolean",
      "isFocusableContainer?": "boolean"
    },
    "docs": {
      "onFocusIn?": "/** @return `true` to prevent the default onFocusIn behavior\n     */",
      "onFocusOut?": "/** @return `true` to prevent the default onFocusOut behavior\n     */",
      "focusTrapActive?": "/** Set to true to create a circular focus pattern when keyboard tabbing.\n     */",
      "forceFocusOutWhenTabGuardsAreEmpty?": "/** Set to true to find a focusable element outside of the TabGuards to focus\n     */"
    }
  },
  "ITooltipFeatureCtrl": {
    "meta": {},
    "type": {
      "getTooltipValue()": "any",
      "getGui()": "HTMLElement",
      "getLocation()": "TooltipLocation",
      "getColumn?()": "AgColumn | AgColumnGroup",
      "getColDef?()": "ColDef | ColGroupDef",
      "getRowIndex?()": "number",
      "getRowNode?()": "RowNode",
      "getValueFormatted?()": "string",
      "getTooltipShowDelayOverride?()": "number",
      "getTooltipHideDelayOverride?()": "number",
      "shouldDisplayTooltip?()": "boolean"
    }
  },
  "TooltipParentComp": {
    "meta": {},
    "type": {
      "getTooltipParams()": "WithoutGridCommon<ITooltipParams>",
      "getGui()": "HTMLElement"
    }
  },
  "TooltipStates": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "NOTHING",
      "WAITING_TO_SHOW",
      "SHOWING"
    ],
    "docs": [
      null,
      null,
      null
    ]
  },
  "TooltipTrigger": {
    "meta": {
      "isEnum": true
    },
    "type": [
      "HOVER",
      "FOCUS"
    ],
    "docs": [
      null,
      null
    ]
  },
  "TapEvent": {
    "meta": {},
    "type": {
      "touchStart": "Touch",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "DoubleTapEvent": {
    "meta": {},
    "type": {
      "touchStart": "Touch",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "LongTapEvent": {
    "meta": {},
    "type": {
      "touchStart": "Touch",
      "touchEvent": "TouchEvent",
      "type": "TEventType"
    },
    "docs": {
      "type": "/** Event identifier */"
    }
  },
  "TouchListenerEvent": {
    "meta": {
      "isTypeAlias": true
    },
    "type": "'tap' | 'doubleTap' | 'longTap'"
  },
  "AgFrameworkComponent": {
    "meta": {
      "typeParams": [
        "T"
      ]
    },
    "type": {
      "agInit(params: T)": "void"
    },
    "docs": {
      "agInit(params: T)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "IHeaderGroupAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IHeaderGroupParams)": "void"
    },
    "docs": {
      "agInit(params: IHeaderGroupParams)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "IHeaderAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IHeaderParams)": "void",
      "refresh(params: IHeaderParams)": "boolean"
    },
    "docs": {
      "agInit(params: IHeaderParams)": "/** Mandatory - Params for rendering this component. */",
      "refresh(params: IHeaderParams)": "/** Get the header to refresh. Gets called whenever Column Defs are updated. */"
    }
  },
  "IFloatingFilterAngularComp": {
    "meta": {
      "typeParams": [
        "P = any"
      ]
    },
    "type": {
      "agInit(params: IFloatingFilterParams<P>)": "void",
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "void",
      "refresh?(params: IFloatingFilterParams<P>)": "void",
      "afterGuiAttached?()": "void"
    },
    "docs": {
      "agInit(params: IFloatingFilterParams<P>)": "/** Mandatory - Params for rendering this component. */",
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "/** Gets called every time the parent filter changes.\n     * Your floating filter would typically refresh its UI to reflect the new filter state.\n     * The provided parentModel is what the parent filter returns from its getModel() method.\n     * The event is the FilterChangedEvent that the grid fires.\n     */",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "/** @deprecated v31.1 - Use `refresh` instead */",
      "refresh?(params: IFloatingFilterParams<P>)": "/** A hook to perform any necessary operations when the column definition is updated. */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */"
    }
  },
  "IDateAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IDateParams)": "void",
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "onParamsUpdated?(params: IDateParams)": "void",
      "refresh?(params: IDateParams)": "void",
      "setDisabled?(disabled: boolean)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void"
    },
    "docs": {
      "agInit(params: IDateParams)": "/** Mandatory - Params for rendering this component. */",
      "getDate()": "/** Returns the current date represented by this component */",
      "setDate(date: Date | null)": "/** Sets the date represented by this component */",
      "onParamsUpdated?(params: IDateParams)": "/** @deprecated v31.1 - Use `refresh` instead. */",
      "refresh?(params: IDateParams)": "/** When used in a floating filter, a hook to perform any necessary operations\n     * when the column definition is updated.\n     */",
      "setDisabled?(disabled: boolean)": "/** Optional: Sets the disabled state of this component */",
      "setInputPlaceholder?(placeholder: string)": "/** Optional: Sets the current input placeholder */",
      "setInputAriaLabel?(placeholder: string)": "/** Optional: Sets the current input aria label */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after\n     * the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters),\n     * this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing,\n     * such as putting focus on a particular DOM element.\n     */"
    }
  },
  "IFilterAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IFilterParams)": "void",
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "agInit(params: IFilterParams)": "/** Mandatory - Params for rendering this component. */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "ICellRendererAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: ICellRendererParams)": "void",
      "refresh(params: ICellRendererParams<TData>)": "boolean"
    },
    "docs": {
      "agInit(params: ICellRendererParams)": "/** Mandatory - Params for rendering this component. */",
      "refresh(params: ICellRendererParams<TData>)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n     * then the grid will refresh the cell for you.\n     */"
    }
  },
  "ICellEditorRendererAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: ICellEditorRendererParams)": "void"
    },
    "docs": {
      "agInit(params: ICellEditorRendererParams)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "ICellEditorAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: ICellEditorParams)": "void",
      "getValue()": "TValue | null | undefined",
      "refresh?(params: ICellEditorParams<any, TValue>)": "void",
      "afterGuiAttached?()": "void",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "'over' | 'under' | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "agInit(params: ICellEditorParams)": "/** Mandatory - Params for rendering this component. */",
      "getValue()": "/** Return the final value - called by the grid once after editing is complete\n     */",
      "refresh?(params: ICellEditorParams<any, TValue>)": "/** Optional: Gets called with the latest cell editor params every time they update\n     */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * This method is called each time the edit component is activated.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "isPopup?()": "/** Optional: Gets called once after initialised. If you return true, the editor will\n     * appear in a popup, so is not constrained to the boundaries of the cell.\n     * This is great if you want to, for example, provide you own custom dropdown list\n     * for selection. Default is false (ie if you don't provide the method).\n     */",
      "getPopupPosition?()": "/** Optional: Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n     * should cover the cell, or \"under\" if it should be positioned below leaving the\n     * cell value visible. If this method is not present, the default is \"over\".\n     */",
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */"
    }
  },
  "AgRendererComponent": {
    "meta": {},
    "type": {
      "agInit(params: ICellRendererParams)": "void",
      "refresh(params: ICellRendererParams<TData>)": "boolean"
    },
    "docs": {
      "agInit(params: ICellRendererParams)": "/** Mandatory - Params for rendering this component. */",
      "refresh(params: ICellRendererParams<TData>)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n     * then the grid will refresh the cell for you.\n     */"
    }
  },
  "AgEditorComponent": {
    "meta": {},
    "type": {
      "agInit(params: ICellEditorParams)": "void",
      "getValue()": "TValue | null | undefined",
      "refresh?(params: ICellEditorParams<any, TValue>)": "void",
      "afterGuiAttached?()": "void",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "'over' | 'under' | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "agInit(params: ICellEditorParams)": "/** Mandatory - Params for rendering this component. */",
      "getValue()": "/** Return the final value - called by the grid once after editing is complete\n     */",
      "refresh?(params: ICellEditorParams<any, TValue>)": "/** Optional: Gets called with the latest cell editor params every time they update\n     */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * This method is called each time the edit component is activated.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "isPopup?()": "/** Optional: Gets called once after initialised. If you return true, the editor will\n     * appear in a popup, so is not constrained to the boundaries of the cell.\n     * This is great if you want to, for example, provide you own custom dropdown list\n     * for selection. Default is false (ie if you don't provide the method).\n     */",
      "getPopupPosition?()": "/** Optional: Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n     * should cover the cell, or \"under\" if it should be positioned below leaving the\n     * cell value visible. If this method is not present, the default is \"over\".\n     */",
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */"
    }
  },
  "AgFilterComponent": {
    "meta": {},
    "type": {
      "agInit(params: IFilterParams)": "void",
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "agInit(params: IFilterParams)": "/** Mandatory - Params for rendering this component. */",
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "AgFloatingFilterComponent": {
    "meta": {},
    "type": {
      "agInit(params: IFloatingFilterParams<P>)": "void",
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "void",
      "refresh?(params: IFloatingFilterParams<P>)": "void",
      "afterGuiAttached?()": "void"
    },
    "docs": {
      "agInit(params: IFloatingFilterParams<P>)": "/** Mandatory - Params for rendering this component. */",
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "/** Gets called every time the parent filter changes.\n     * Your floating filter would typically refresh its UI to reflect the new filter state.\n     * The provided parentModel is what the parent filter returns from its getModel() method.\n     * The event is the FilterChangedEvent that the grid fires.\n     */",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "/** @deprecated v31.1 - Use `refresh` instead */",
      "refresh?(params: IFloatingFilterParams<P>)": "/** A hook to perform any necessary operations when the column definition is updated. */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */"
    }
  },
  "ILoadingCellRendererAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: ILoadingCellRendererParams)": "void"
    },
    "docs": {
      "agInit(params: ILoadingCellRendererParams)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "ILoadingOverlayAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: ILoadingOverlayParams)": "void",
      "refresh?(params: TParams)": "void"
    },
    "docs": {
      "agInit(params: ILoadingOverlayParams)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "INoRowsOverlayAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: INoRowsOverlayParams)": "void",
      "refresh?(params: TParams)": "void"
    },
    "docs": {
      "agInit(params: INoRowsOverlayParams)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "IStatusPanelAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IStatusPanelParams)": "void",
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "boolean"
    },
    "docs": {
      "agInit(params: IStatusPanelParams)": "/** Mandatory - Params for rendering this component. */",
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "/** Called when the `statusBar` grid option is updated.\n     * If this method returns `true`,\n     * the grid assumes that the status panel has updated with the latest params,\n     * and takes no further action.\n     * If this method returns `false`, or is not implemented,\n     * the grid will destroy and recreate the status panel.\n     */"
    }
  },
  "IToolPanelAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IToolPanelParams)": "void",
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "boolean | void",
      "getState?()": "TState | undefined"
    },
    "docs": {
      "agInit(params: IToolPanelParams)": "/** Mandatory - Params for rendering this component. */",
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "/** Called when `api.refreshToolPanel()` is called (with the current params).\n     * Also called when the `sideBar` grid option is updated (with the updated params).\n     * When `sideBar` is updated, if this method returns `true`,\n     * then the grid will take no further action.\n     * Otherwise, the tool panel will be destroyed and recreated.\n     */",
      "getState?()": "/** If saving and restoring state, this should return the current state */"
    }
  },
  "ITooltipAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: ITooltipParams)": "void"
    },
    "docs": {
      "agInit(params: ITooltipParams)": "/** Mandatory - Params for rendering this component. */"
    }
  },
  "IMenuItemAngularComp": {
    "meta": {},
    "type": {
      "agInit(params: IMenuItemParams)": "void",
      "setActive?(active: boolean)": "void",
      "setExpanded?(expanded: boolean)": "void",
      "select?()": "void",
      "configureDefaults?()": "boolean | IMenuConfigParams"
    },
    "docs": {
      "agInit(params: IMenuItemParams)": "/** Mandatory - Params for rendering this component. */",
      "setActive?(active: boolean)": "/** Called when the item is activated/deactivated, either via mouseover or keyboard navigation. */",
      "setExpanded?(expanded: boolean)": "/** If the item has a sub menu, called when the sub menu is opened/closed. */",
      "select?()": "/** Called when the item is selected, e.g. clicked or Enter is pressed. */",
      "configureDefaults?()": "/** Configure the default grid behaviour for this item, including styling,\n     * and mouse and keyboard interactions.\n     *\n     * @returns `true` to use all default behaviour, `false` to use no default behaviour\n     * (equivalent to `configureDefaults` not being defined),\n     * or `IMenuConfigParams` to choose what default behaviour to use.\n     */"
    }
  },
  "WrapperParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "P",
        "M"
      ]
    },
    "type": "{ initialProps: P; CustomComponentClass: any; setMethods: (methods: M) => void; addUpdateCallback: (callback: (props: P) => void) => void; }"
  },
  "CustomContextParams": {
    "meta": {
      "isTypeAlias": true,
      "typeParams": [
        "M"
      ]
    },
    "type": "{ setMethods: (methods: M) => void; }"
  },
  "CustomCellEditorProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom cell editor components */"
    },
    "type": {
      "initialValue": "TValue | null | undefined",
      "value": "TValue | null | undefined",
      "onValueChange": "(value: TValue | null | undefined) => void",
      "eventKey": "string | null",
      "column": "Column<TValue>",
      "colDef": "ColDef<TData, TValue>",
      "node": "IRowNode<TData>",
      "data": "TData",
      "rowIndex": "number",
      "cellStartedEdit": "boolean",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: string) => TValue | null | undefined",
      "formatValue": "(value: TValue | null | undefined) => string",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "initialValue": "/** The value in the cell when editing started. */",
      "value": "/** The current value for the editor. */",
      "onValueChange": "/** Callback that should be called every time the value in the editor changes. */",
      "eventKey": "/** Key value of key that started the edit, eg 'Enter' or 'F2' - non-printable\n     *  characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n     *  (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n     *  arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. Call with input parameter\n     * true to prevent focus from moving to the next cell after editing stops in case the\n     * grid property `enterNavigatesVerticallyAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n     *  will live inside. Useful if you want to add event listeners or classes at this level.\n     *  This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomDateProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom date components */"
    },
    "type": {
      "date": "Date | null",
      "onDateChange": "(date: Date | null) => void",
      "filterParams": "DateFilterParams",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "date": "/** The current date for the component. */",
      "onDateChange": "/** Callback that should be called every time the date in the component changes. */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomFilterProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TModel = any"
      ],
      "doc": "/** Props provided to custom filter components */"
    },
    "type": {
      "model": "TModel | null",
      "onModelChange": "(model: TModel | null) => void",
      "onUiChange": "() => void",
      "column": "Column",
      "colDef": "ColDef<TData>",
      "rowModel": "IRowModel",
      "getValue": "<TValue = any>(node: IRowNode<TData>, column?: string | ColDef<TData, TValue> | Column<TValue>) => TValue | null | undefined",
      "doesRowPassOtherFilter": "(rowNode: IRowNode<TData>) => boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "model": "/** The current filter model for the component. */",
      "onModelChange": "/** Callback that should be called every time the model in the component changes. */",
      "onUiChange": "/** Callback that can be optionally called every time the filter UI changes.\n     * The grid will respond with emitting a FilterModifiedEvent.\n     * Apart from emitting the event, the grid takes no further action.\n     */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n     * If the filter needs to know which rows are\n     * a) in the table,\n     * b) currently visible (i.e. not already filtered),\n     * c) which groups,\n     * d) what order - all of this can be read from the rowModel.\n     */",
      "getValue": "/** Get the cell value for the given row node and column, which can be the column ID, definition, or `Column` object.\n     * If no column is provided, the column this filter is on will be used.\n     */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n     * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n     * The set filter uses this to remove from the list,\n     * items that are no longer available due to the state of other filters (like Excel type filtering).\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomFloatingFilterProps": {
    "meta": {
      "typeParams": [
        "P = IFilter",
        "TData = any",
        "TContext = any",
        "TModel = any"
      ],
      "doc": "/** Props provided to custom floating filter components */"
    },
    "type": {
      "model": "TModel | null",
      "onModelChange": "(model: TModel | null) => void",
      "column": "Column",
      "filterParams": "IFilterParams",
      "suppressFilterButton": "boolean",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: IFloatingFilterParentCallback<P>) => void",
      "showParentFilter": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "model": "/** The current filter model for the component. */",
      "onModelChange": "/** Callback that should be called every time the model in the component changes. */",
      "column": "/** The column this filter is for. */",
      "filterParams": "/** The params object passed to the filter.\n     * This is to allow the floating filter access to the configuration of the parent filter.\n     * For example, the provided filters use debounceMs from the parent filter params.\n     * */",
      "suppressFilterButton": "/** @deprecated v31.1 Use `colDef.suppressFloatingFilterButton` instead. */",
      "currentParentModel": "/** This is a shortcut to invoke getModel on the parent filter.\n     * If the parent filter doesn't exist (filters are lazily created as needed)\n     * then it returns null rather than calling getModel() on the parent filter.\n     */",
      "parentFilterInstance": "/** Gets a reference to the parent filter. The result is returned asynchronously\n     * via a callback as the parent filter may not exist yet. If it does\n     * not exist, it is created and asynchronously returned (AG Grid itself\n     * does not create components asynchronously, however if providing a framework\n     * provided filter e.g. React, it might be).\n     *\n     * The floating filter can then call any method it likes on the parent filter.\n     * The parent filter will typically provide its own method for the floating\n     * filter to call to set the filter. For example, if creating custom filter A,\n     * it should have a method your floating A can call to set the state\n     * when the user updates via the floating filter.\n     */",
      "showParentFilter": "/** Shows the parent filter popup.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomToolPanelProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any",
        "TState = any"
      ],
      "doc": "/** Props provided to custom tool panel components */"
    },
    "type": {
      "state": "TState | undefined",
      "onStateChange": "(model: TState | undefined) => void",
      "initialState?": "TState | undefined",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "state": "/** The current state for the component (used in grid state).\n     * Initially set to the same value as `initialState`\n     */",
      "onStateChange": "/** If using grid state, callback that should be called every time the state in the component changes.\n     * If not using grid state, not required.\n     */",
      "initialState?": "/** The tool-panel-specific initial state as provided in grid options if applicable */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomMenuItemProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom menu item components */"
    },
    "type": {
      "active": "boolean",
      "expanded": "boolean",
      "onActiveChange": "(active: boolean) => void",
      "level": "number",
      "isAnotherSubMenuOpen": "() => boolean",
      "openSubMenu": "(activateFirstItem?: boolean) => void",
      "closeSubMenu": "() => void",
      "closeMenu": "(event?: KeyboardEvent | MouseEvent) => void",
      "updateTooltip": "(tooltip?: string, shouldDisplayTooltip?: () => boolean) => void",
      "subMenu?": "(MenuItemDef<TData, TContext> | string)[]",
      "menuItem?": "any",
      "menuItemParams?": "any",
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "(params: IMenuActionParams<TData, TContext>) => void",
      "checked?": "boolean",
      "icon?": "Element | string",
      "cssClasses?": "string[]",
      "tooltip?": "string",
      "suppressCloseOnSelect?": "boolean",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "active": "/** The active status of the item (is it currently hovered with the mouse, or navigated to via the keyboard). */",
      "expanded": "/** If the item is a sub menu, whether it is currently opened or closed. */",
      "onActiveChange": "/** Callback that should be called every time the active status is updated (if providing custom behaviour). */",
      "level": "/** Level within the menu tree (starts at 0). */",
      "isAnotherSubMenuOpen": "/** Returns `true` if another sub menu is open. */",
      "openSubMenu": "/** Open the sub menu for this item.\n     * @param activateFirstItem If `true`, activate the first item in the sub menu.\n     */",
      "closeSubMenu": "/** Close the sub menu for this item. */",
      "closeMenu": "/** Close the entire menu. */",
      "updateTooltip": "/** Updates the grid-provided tooltip this component.\n     * @param tooltip The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "subMenu?": "/** If this item is a sub menu, contains a list of menu item definitions */",
      "menuItem?": "/** Provide a custom menu item component.\n     * See [Menu Item Component](https://www.ag-grid.com/javascript-data-grid/component-menu-item/#implementing-a-menu-item-component) for framework specific implementation details.\n     */",
      "menuItemParams?": "/** Parameters to be passed to the custom menu item component specified in `menuItem`.\n     */",
      "name": "/** Name of the menu item. */",
      "disabled?": "/** Set to `true` to display the menu item as disabled. */",
      "shortcut?": "/** Shortcut text displayed inside menu item.\n     * Setting this doesn’t actually create a keyboard shortcut binding.\n     */",
      "action?": "/** Function that gets executed when item is chosen. */",
      "checked?": "/** Set to true to provide a check beside the option. */",
      "icon?": "/** The icon to display, either a DOM element or HTML string. */",
      "cssClasses?": "/** CSS classes to apply to the menu item. */",
      "tooltip?": "/** Tooltip text to be displayed for the menu item. */",
      "suppressCloseOnSelect?": "/** If `true`, will keep the menu open when the item is selected.\n     * Note that if this item has a sub menu,\n     * it will always remain open regardless of this property.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomLoadingOverlayProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom loading overlay component */"
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomNoRowsOverlayProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom no-rows overlay component */"
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomStatusPanelProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom status panel components */"
    },
    "type": {
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomCellRendererProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom cell renderer components */"
    },
    "type": {
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomDetailCellRendererProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TDetail = any"
      ],
      "doc": "/** Props provided to custom detail cell renderer components */"
    },
    "type": {
      "detailGridOptions": "GridOptions<TDetail>",
      "getDetailRowData": "GetDetailRowData<TData, TDetail>",
      "refreshStrategy": "'rows' | 'everything' | 'nothing'",
      "template": "string | TemplateFunc<TData>",
      "agGridReact": "any",
      "frameworkComponentWrapper": "any",
      "pinned": "'left' | 'right' | null | undefined",
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "detailGridOptions": "/** Provide Grid Options to use for the Detail Grid.\n     */",
      "getDetailRowData": "/** A function that provides what rows to display in the Detail Grid. */",
      "refreshStrategy": "/** Defines how to refresh the Detail Grids as data is changing in the Master Grid. */",
      "template": "/** Allows changing the template used around the Detail Grid. */",
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomGroupCellRendererProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any"
      ],
      "doc": "/** Props provided to custom group cell renderer components */"
    },
    "type": {
      "suppressPadding?": "boolean",
      "suppressDoubleClickExpand?": "boolean",
      "suppressEnterExpand?": "boolean",
      "footerValueGetter?": "string | FooterValueGetterFunc",
      "totalValueGetter?": "string | TotalValueGetterFunc",
      "suppressCount?": "boolean",
      "checkbox?": "boolean | GroupCheckboxSelectionCallback<TData, TValue>",
      "innerRenderer?": "any",
      "innerRendererParams?": "any",
      "innerRendererSelector?": "CellRendererSelectorFunc"
    },
    "docs": {
      "suppressPadding?": "/** Set to `true` to not include any padding (indentation) in the child rows. */",
      "suppressDoubleClickExpand?": "/** Set to `true` to suppress expand on double click. */",
      "suppressEnterExpand?": "/** Set to `true` to suppress expand on <kbd>↵ Enter</kbd> */",
      "footerValueGetter?": "/** The value getter for the footer text. Can be a function or expression. @deprecated v31.2 use `totalValueGetter` */",
      "totalValueGetter?": "/** The value getter for the total row text. Can be a function or expression. */",
      "suppressCount?": "/** If `true`, count is not displayed beside the name. */",
      "checkbox?": "/** Set to `true`, or a function that returns `true`, if a checkbox should be included.\n     */",
      "innerRenderer?": "/** The renderer to use for inside the cell (after grouping functions are added) */",
      "innerRendererParams?": "/** Additional params to customise to the `innerRenderer`. */",
      "innerRendererSelector?": "/** Callback to enable different innerRenderers to be used based of value of params. */"
    }
  },
  "CustomHeaderProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom header components */"
    },
    "type": {
      "column": "Column",
      "displayName": "string",
      "enableSorting": "boolean | undefined",
      "enableMenu": "boolean",
      "enableFilterButton": "boolean",
      "enableFilterIcon": "boolean",
      "showColumnMenu": "(source: HTMLElement) => void",
      "showColumnMenuAfterMouseClick": "(mouseEvent: MouseEvent | Touch) => void",
      "showFilter": "(source: HTMLElement) => void",
      "progressSort": "(multiSort?: boolean) => void",
      "setSort": "(sort: SortDirection, multiSort?: boolean) => void",
      "template?": "string",
      "eGridHeader": "HTMLElement",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "column": "/** The column the header is for. */",
      "displayName": "/** The name to display for the column.\n     * If the column is using a headerValueGetter, the displayName will take this into account.\n     */",
      "enableSorting": "/** Whether sorting is enabled for the column.\n     * Only put sort logic into your header if this is true.\n     */",
      "enableMenu": "/** Whether menu is enabled for the column.\n     * Only display a menu button in your header if this is true.\n     */",
      "enableFilterButton": "/** Whether filter button should be displayed in the header (for new column menu).\n     */",
      "enableFilterIcon": "/** Whether filter icon should be displayed in the header (for legacy tabbed column menu).\n     */",
      "showColumnMenu": "/** Callback to request the grid to show the column menu.\n     * Pass in the html element of the column menu button to have the\n     * grid position the menu over the button.\n     */",
      "showColumnMenuAfterMouseClick": "/** Callback to request the grid to show the column menu.\n     * Similar to `showColumnMenu`, but will position the menu next to the provided `mouseEvent`.\n     */",
      "showFilter": "/** Callback to request the grid to show the filter.\n     * Pass in the html element of the filter button to have the\n     * grid position the menu over the button.\n     */",
      "progressSort": "/** Callback to progress the sort for this column.\n     * The grid will decide the next sort direction eg ascending, descending or 'no sort'.\n     * Pass `multiSort=true` if you want to do a multi sort (eg user has Shift held down when they click).\n     */",
      "setSort": "/** Callback to set the sort for this column.\n     * Pass the sort direction to use ignoring the current sort eg one of 'asc', 'desc' or null (for no sort).\n     * Pass `multiSort=true` if you want to do a multi sort (eg user has Shift held down when they click)\n     */",
      "template?": "/** Custom header template if provided to `headerComponentParams`, otherwise will be `undefined`. See [Header Templates](https://ag-grid.com/javascript-data-grid/column-headers/#header-templates) */",
      "eGridHeader": "/** The header the grid provides.\n     * The custom header component is a child of the grid provided header.\n     * The grid's header component is what contains the grid managed functionality such as resizing, keyboard navigation etc.\n     * This is provided should you want to make changes to this cell,\n     * eg add ARIA tags, or add keyboard event listener (as focus goes here when navigating to the header).\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomHeaderGroupProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom header group components */"
    },
    "type": {
      "columnGroup": "ColumnGroup",
      "displayName": "string",
      "setExpanded": "(expanded: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "columnGroup": "/** The column group the header is for. */",
      "displayName": "/** The text label to render.\n     * If the column is using a headerValueGetter, the displayName will take this into account.\n     */",
      "setExpanded": "/** Opens / closes the column group */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomLoadingCellRendererProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom loading cell renderer components */"
    },
    "type": {
      "value": "TValue | null | undefined",
      "valueFormatted": "string | null | undefined",
      "fullWidth?": "boolean",
      "pinned?": "'left' | 'right' | null",
      "data": "TData | undefined",
      "node": "IRowNode<TData>",
      "colDef?": "ColDef<TData, TValue>",
      "column?": "Column<TValue>",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => TValue | null | undefined",
      "setValue?": "(value: TValue | null | undefined) => void",
      "formatValue?": "(value: TValue | null | undefined) => string",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void",
      "setTooltip": "(value: string, shouldDisplayTooltip?: () => boolean) => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. Data property can be `undefined` when row grouping or loading infinite row models. */",
      "node": "/** The row node. */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to data value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n     * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n     * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n     * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n     * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n     */",
      "setTooltip": "/** Sets a tooltip to the main element of this component.\n     * @param value The value to be displayed by the tooltip\n     * @param shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when `enableBrowserTooltips={true}`.\n     */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomTooltipProps": {
    "meta": {
      "typeParams": [
        "TData = any",
        "TValue = any",
        "TContext = any"
      ],
      "doc": "/** Props provided to custom tooltip components */"
    },
    "type": {
      "location": "TooltipLocation",
      "value?": "TValue | null",
      "valueFormatted?": "string | null",
      "colDef?": "ColDef<TData, TValue> | ColGroupDef<TData> | null",
      "column?": "Column<TValue> | ColumnGroup",
      "rowIndex?": "number",
      "node?": "IRowNode<TData>",
      "data?": "TData",
      "hideTooltipCallback?": "() => void",
      "api": "GridApi<TData>",
      "context": "TContext"
    },
    "docs": {
      "location": "/** What part of the application is showing the tooltip, e.g. 'cell', 'header', 'menuItem' etc */",
      "value?": "/** The value to be rendered by the tooltip. */",
      "valueFormatted?": "/** The formatted value to be rendered by the tooltip. */",
      "colDef?": "/** Column / ColumnGroup definition. */",
      "column?": "/** Column / ColumnGroup */",
      "rowIndex?": "/** The index of the row containing the cell rendering the tooltip. */",
      "node?": "/** The row node. */",
      "data?": "/** Data for the row node in question. */",
      "hideTooltipCallback?": "/** A callback function that hides the tooltip */",
      "api": "/** The grid api. */",
      "context": "/** Application context as set on `gridOptions.context`. */"
    }
  },
  "CustomCellEditorCallbacks": {
    "meta": {
      "doc": "/** Callbacks for custom cell editor components */"
    },
    "type": {
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */"
    }
  },
  "CustomDateCallbacks": {
    "meta": {
      "doc": "/** Callbacks for custom date components */"
    },
    "type": {
      "setDisabled?(disabled: boolean)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void"
    },
    "docs": {
      "setDisabled?(disabled: boolean)": "/** Optional: Sets the disabled state of this component */",
      "setInputPlaceholder?(placeholder: string)": "/** Optional: Sets the current input placeholder */",
      "setInputAriaLabel?(placeholder: string)": "/** Optional: Sets the current input aria label */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after\n     * the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters),\n     * this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing,\n     * such as putting focus on a particular DOM element.\n     */"
    }
  },
  "CustomFilterCallbacks": {
    "meta": {
      "doc": "/** Callbacks for custom filter components */"
    },
    "type": {
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void"
    },
    "docs": {
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */"
    }
  },
  "CustomFloatingFilterCallbacks": {
    "meta": {
      "doc": "/** Callbacks for custom floating filter components */"
    },
    "type": {
      "afterGuiAttached?()": "void"
    },
    "docs": {
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */"
    }
  },
  "CustomMenuItemCallbacks": {
    "meta": {
      "doc": "/** Callbacks for custom menu item components */"
    },
    "type": {
      "select?()": "void",
      "configureDefaults?()": "boolean | IMenuConfigParams"
    },
    "docs": {
      "select?()": "/** Called when the item is selected, e.g. clicked or Enter is pressed. */",
      "configureDefaults?()": "/** Configure the default grid behaviour for this item, including styling,\n     * and mouse and keyboard interactions.\n     *\n     * @returns `true` to use all default behaviour, `false` to use no default behaviour\n     * (equivalent to `configureDefaults` not being defined),\n     * or `IMenuConfigParams` to choose what default behaviour to use.\n     */"
    }
  },
  "SharedProps": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "gridOptions?": "GridOptions<TData>",
      "modules?": "Module[]",
      "containerStyle?": "any",
      "className?": "string",
      "setGridApi?": "(gridApi: GridApi<TData>) => void",
      "componentWrappingElement?": "string",
      "maxComponentCreationTimeMs?": "number",
      "children?": "any",
      "statusBar?": "{ statusPanels: StatusPanelDef[]; }",
      "sideBar?": "SideBarDef | string | string[] | boolean | null",
      "suppressContextMenu?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "columnMenu?": "'legacy' | 'new'",
      "suppressMenuHide?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "tooltipTrigger?": "'hover' | 'focus'",
      "tooltipShowDelay?": "number",
      "tooltipHideDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "tooltipShowMode?": "'standard' | 'whenTruncated'",
      "tooltipInteraction?": "boolean",
      "popupParent?": "HTMLElement | null",
      "copyHeadersToClipboard?": "boolean",
      "copyGroupHeadersToClipboard?": "boolean",
      "clipboardDelimiter?": "string",
      "suppressCopyRowsToClipboard?": "boolean",
      "suppressCopySingleCellRanges?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "suppressCutToClipboard?": "boolean",
      "columnDefs?": "(ColDef<TData> | ColGroupDef<TData>)[] | null",
      "defaultColDef?": "ColDef<TData>",
      "defaultColGroupDef?": "Partial<ColGroupDef<TData>>",
      "columnTypes?": "{ [key: string]: ColTypeDef<TData>; }",
      "dataTypeDefinitions?": "{ [cellDataType: string]: DataTypeDefinition<TData>; }",
      "maintainColumnOrder?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "headerHeight?": "number",
      "groupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "pivotHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "suppressRowGroupHidesColumns?": "boolean",
      "colResizeDefault?": "'shift'",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "autoSizeStrategy?": "SizeColumnsToFitGridStrategy | SizeColumnsToFitProvidedWidthStrategy | SizeColumnsToContentStrategy",
      "components?": "{ [p: string]: any; }",
      "editType?": "'fullRow'",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "readOnlyEdit?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "enterNavigatesVertically?": "boolean",
      "enterNavigatesVerticallyAfterEdit?": "boolean",
      "enableCellEditingOnBackspace?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "defaultCsvExportParams?": "CsvExportParams",
      "suppressCsvExport?": "boolean",
      "defaultExcelExportParams?": "ExcelExportParams",
      "suppressExcelExport?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "includeHiddenColumnsInQuickFilter?": "boolean",
      "quickFilterParser?": "(quickFilter: string) => string[]",
      "quickFilterMatcher?": "(quickFilterParts: string[], rowQuickFilterAggregateText: string) => boolean",
      "applyQuickFilterBeforePivotOrAgg?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "enableAdvancedFilter?": "boolean",
      "advancedFilterModel?": "AdvancedFilterModel | null",
      "includeHiddenColumnsInAdvancedFilter?": "boolean",
      "advancedFilterParent?": "HTMLElement | null",
      "advancedFilterBuilderParams?": "IAdvancedFilterBuilderParams",
      "suppressAdvancedFilterEval?": "boolean",
      "enableCharts?": "boolean",
      "chartThemes?": "string[]",
      "customChartThemes?": "{ [name: string]: AgChartTheme; }",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "chartToolPanelsDef?": "ChartToolPanelsDef",
      "chartMenuItems?": "(string | MenuItemDef)[] | GetChartMenuItems<TData>",
      "loadingCellRenderer?": "any",
      "loadingCellRendererParams?": "any",
      "loadingCellRendererSelector?": "LoadingCellRendererSelectorFunc<TData>",
      "localeText?": "{ [key: string]: string; }",
      "masterDetail?": "boolean",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "detailCellRenderer?": "any",
      "detailCellRendererParams?": "any",
      "detailRowHeight?": "number",
      "detailRowAutoHeight?": "boolean",
      "context?": "any",
      "alignedGrids?": "AlignedGrid[] | (() => AlignedGrid[])",
      "tabIndex?": "number",
      "rowBuffer?": "number",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "enableCellExpressions?": "boolean",
      "suppressTouch?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "suppressBrowserResizeObserver?": "boolean",
      "suppressPropertyNamesCheck?": "boolean",
      "suppressChangeDetection?": "boolean",
      "debug?": "boolean",
      "loading?": "boolean",
      "overlayLoadingTemplate?": "string",
      "loadingOverlayComponent?": "any",
      "loadingOverlayComponentParams?": "any",
      "suppressLoadingOverlay?": "boolean",
      "overlayNoRowsTemplate?": "string",
      "noRowsOverlayComponent?": "any",
      "noRowsOverlayComponentParams?": "any",
      "suppressNoRowsOverlay?": "boolean",
      "pagination?": "boolean",
      "paginationPageSize?": "number",
      "paginationPageSizeSelector?": "number[] | boolean",
      "paginationAutoPageSize?": "boolean",
      "paginateChildRows?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pivotMode?": "boolean",
      "pivotPanelShow?": "'always' | 'onlyWhenPivoting' | 'never'",
      "pivotMaxGeneratedColumns?": "number",
      "pivotDefaultExpanded?": "number",
      "pivotColumnGroupTotals?": "'before' | 'after'",
      "pivotRowTotals?": "'before' | 'after'",
      "pivotSuppressAutoColumn?": "boolean",
      "suppressExpandablePivotGroups?": "boolean",
      "functionsReadOnly?": "boolean",
      "aggFuncs?": "{ [key: string]: IAggFunc<TData>; }",
      "suppressAggFuncInHeader?": "boolean",
      "alwaysAggregateAtRootLevel?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "removePivotHeaderRowWhenSingleValueColumn?": "boolean",
      "animateRows?": "boolean",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDuration?": "number",
      "cellFlashDelay?": "number",
      "cellFadeDuration?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "domLayout?": "DomLayoutType",
      "ensureDomOrder?": "boolean",
      "enableRtl?": "boolean",
      "suppressColumnVirtualisation?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "suppressRowVirtualisation?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "rowDragEntireRow?": "boolean",
      "rowDragMultiRow?": "boolean",
      "rowDragText?": "(params: IRowDragItem, dragItemCount: number) => string",
      "fullWidthCellRenderer?": "any",
      "fullWidthCellRendererParams?": "any",
      "embedFullWidthRows?": "boolean",
      "suppressGroupMaintainValueType?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupDefaultExpanded?": "number",
      "autoGroupColumnDef?": "ColDef<TData>",
      "groupMaintainOrder?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupLockGroupColumns?": "number",
      "groupAggFiltering?": "boolean | IsRowFilterable<TData>",
      "groupIncludeFooter?": "boolean | UseGroupFooter<TData>",
      "groupIncludeTotalFooter?": "boolean",
      "groupTotalRow?": "'top' | 'bottom' | UseGroupTotalRow<TData>",
      "grandTotalRow?": "'top' | 'bottom'",
      "suppressStickyTotalRow?": "boolean | 'grand' | 'group'",
      "groupSuppressBlankHeader?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "showOpenedGroup?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "groupAllowUnbalanced?": "boolean",
      "rowGroupPanelShow?": "'always' | 'onlyWhenGrouping' | 'never'",
      "groupRowRenderer?": "any",
      "groupRowRendererParams?": "any",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "treeData?": "boolean",
      "rowGroupPanelSuppressSort?": "boolean",
      "suppressGroupRowsSticky?": "boolean",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "rowModelType?": "RowModelType",
      "rowData?": "TData[] | null",
      "asyncTransactionWaitMillis?": "number",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "datasource?": "IDatasource",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "serverSideInitialRowCount?": "number",
      "suppressServerSideInfiniteScroll?": "boolean",
      "suppressServerSideFullWidthLoadingRow?": "boolean",
      "cacheBlockSize?": "number",
      "maxBlocksInCache?": "number",
      "maxConcurrentDatasourceRequests?": "number",
      "blockLoadDebounceMillis?": "number",
      "purgeClosedRowNodes?": "boolean",
      "serverSideDatasource?": "IServerSideDatasource",
      "serverSideSortAllLevels?": "boolean",
      "serverSideEnableClientSideSort?": "boolean",
      "serverSideOnlyRefreshFilteredGroups?": "boolean",
      "serverSideSortOnServer?": "boolean",
      "serverSideFilterOnServer?": "boolean",
      "serverSidePivotResultFieldSeparator?": "string",
      "viewportDatasource?": "IViewportDatasource",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressScrollWhenPopupsAreOpen?": "boolean",
      "suppressAnimationFrame?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "scrollbarWidth?": "number",
      "rowSelection?": "'single' | 'multiple'",
      "rowMultiSelectWithClick?": "boolean",
      "suppressRowDeselection?": "boolean",
      "suppressRowClickSelection?": "boolean",
      "suppressCellFocus?": "boolean",
      "suppressHeaderFocus?": "boolean",
      "suppressMultiRangeSelection?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "'x' | 'y' | 'xy'",
      "suppressClearOnFillReduction?": "boolean",
      "sortingOrder?": "SortDirection[]",
      "accentedSort?": "boolean",
      "unSortIcon?": "boolean",
      "suppressMultiSort?": "boolean",
      "alwaysMultiSort?": "boolean",
      "multiSortKey?": "'ctrl'",
      "suppressMaintainUnsortedOrder?": "boolean",
      "icons?": "{ [key: string]: ((...args: any[]) => any) | string; }",
      "rowHeight?": "number",
      "rowStyle?": "RowStyle",
      "rowClass?": "string | string[]",
      "rowClassRules?": "RowClassRules<TData>",
      "suppressRowHoverHighlight?": "boolean",
      "suppressRowTransform?": "boolean",
      "columnHoverHighlight?": "boolean",
      "gridId?": "string",
      "deltaSort?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "enableGroupEdit?": "boolean",
      "initialState?": "GridState",
      "reactiveCustomComponents?": "boolean",
      "getContextMenuItems?": "GetContextMenuItems<TData>",
      "getMainMenuItems?": "GetMainMenuItems<TData>",
      "postProcessPopup?": "(params: PostProcessPopupParams<TData>) => void",
      "processUnpinnedColumns?": "(params: ProcessUnpinnedColumnsParams<TData>) => Column[]",
      "processCellForClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "processHeaderForClipboard?": "(params: ProcessHeaderForExportParams<TData>) => any",
      "processGroupHeaderForClipboard?": "(params: ProcessGroupHeaderForExportParams<TData>) => any",
      "processCellFromClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "sendToClipboard?": "(params: SendToClipboardParams<TData>) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams<TData>) => string[][] | null",
      "isExternalFilterPresent?": "(params: IsExternalFilterPresentParams<TData>) => boolean",
      "doesExternalFilterPass?": "(node: IRowNode<TData>) => boolean",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "createChartContainer?": "(params: ChartRefParams<TData>) => void",
      "focusGridInnerElement?": "(params: FocusGridInnerElementParams<TData>) => boolean",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams<TData>) => HeaderPosition | null",
      "tabToNextHeader?": "(params: TabToNextHeaderParams<TData>) => HeaderPosition | boolean | null",
      "navigateToNextCell?": "(params: NavigateToNextCellParams<TData>) => CellPosition | null",
      "tabToNextCell?": "(params: TabToNextCellParams<TData>) => CellPosition | boolean | null",
      "getLocaleText?": "(params: GetLocaleTextParams<TData>) => string",
      "getDocument?": "() => Document",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams<TData>) => string",
      "getGroupRowAgg?": "(params: GetGroupRowAggParams<TData>) => any",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams<TData>) => boolean",
      "initialGroupOrderComparator?": "(params: InitialGroupOrderComparatorParams<TData>) => number",
      "processPivotResultColDef?": "(colDef: ColDef<TData>) => void",
      "processPivotResultColGroupDef?": "(colGroupDef: ColGroupDef<TData>) => void",
      "getDataPath?": "GetDataPath<TData>",
      "getChildCount?": "(dataItem: any) => number",
      "getServerSideGroupLevelParams?": "(params: GetServerSideGroupLevelParamsParams) => ServerSideGroupLevelParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "isServerSideGroup?": "IsServerSideGroup",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getBusinessKeyForNode?": "(node: IRowNode<TData>) => string",
      "getRowId?": "GetRowIdFunc<TData>",
      "resetRowDataOnUpdate?": "boolean",
      "processRowPostCreate?": "(params: ProcessRowParams<TData>) => void",
      "isRowSelectable?": "IsRowSelectable<TData>",
      "isRowMaster?": "IsRowMaster<TData>",
      "fillOperation?": "(params: FillOperationParams<TData>) => any",
      "postSortRows?": "(params: PostSortRowsParams<TData>) => void",
      "getRowStyle?": "(params: RowClassParams<TData>) => RowStyle | undefined",
      "getRowClass?": "(params: RowClassParams<TData>) => string | string[] | undefined",
      "getRowHeight?": "(params: RowHeightParams<TData>) => number | undefined | null",
      "isFullWidthRow?": "(params: IsFullWidthRowParams<TData>) => boolean",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "void",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "void",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "void",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "void",
      "onCutStart?(event: CutStartEvent<TData>)": "void",
      "onCutEnd?(event: CutEndEvent<TData>)": "void",
      "onPasteStart?(event: PasteStartEvent<TData>)": "void",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "void",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "void",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "void",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "void",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "void",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "void",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "void",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "void",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "void",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "void",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "void",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "void",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "void",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "void",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "void",
      "onFillStart?(event: FillStartEvent<TData>)": "void",
      "onFillEnd?(event: FillEndEvent<TData>)": "void",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "void",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "void",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "void",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "void",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "void",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "void",
      "onGridReady?(event: GridReadyEvent<TData>)": "void",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "void",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "void",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "void",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "void",
      "onDragStarted?(event: DragStartedEvent<TData>)": "void",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "void",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "void",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "void",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "void",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "void",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "void",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "void",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "void",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "void",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "void",
      "onCellClicked?(event: CellClickedEvent<TData>)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "void",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "void",
      "onRowClicked?(event: RowClickedEvent<TData>)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "void",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "void",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "void",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "void",
      "onSortChanged?(event: SortChangedEvent<TData>)": "void",
      "api?": "never"
    },
    "docs": {
      "modules?": "/** Used to register AG Grid Modules directly with this instance of the grid.\n     * See [Providing Modules To Individual Grids](https://www.ag-grid.com/react-data-grid/modules/#providing-modules-to-individual-grids) for more information.\n     */",
      "statusBar?": "/** Specifies the status bar components to use in the status bar.\n     */",
      "sideBar?": "/** Specifies the side bar components.\n     */",
      "suppressContextMenu?": "/** Set to `true` to not show the context menu. Use if you don't want to use the default 'right click' context menu.\n     * @default false\n     */",
      "preventDefaultOnContextMenu?": "/** When using `suppressContextMenu`, you can use the `onCellContextMenu` function to provide your own code to handle cell `contextmenu` events.\n     * This flag is useful to prevent the browser from showing its default context menu.\n     * @default false\n     */",
      "allowContextMenuWithControlKey?": "/** Allows context menu to show, even when `Ctrl` key is held down.\n     * @default false\n     */",
      "columnMenu?": "/** Changes the display type of the column menu.\n     * `'new'` just displays the main list of menu items. `'legacy'` displays a tabbed menu.\n     * @default 'new'\n     * @initial\n     */",
      "suppressMenuHide?": "/** When `true`, the column menu button will always be shown.\n     * When `false, the column menu button will only show when the mouse is over the column header.\n     * If `columnMenu = 'legacy'`, this will default to `false` instead of `true`.\n     * @default true\n     */",
      "enableBrowserTooltips?": "/** Set to `true` to use the browser's default tooltip instead of using the grid's Tooltip Component.\n     * @default false\n     * @initial\n     */",
      "tooltipTrigger?": "/** The trigger that will cause tooltips to show and hide.\n     *  - `hover` - The tooltip will show/hide when a cell/header is hovered.\n     *  - `focus` - The tooltip will show/hide when a cell/header is focused.\n     * @default 'hover'\n     * @initial\n     */",
      "tooltipShowDelay?": "/** The delay in milliseconds that it takes for tooltips to show up once an element is hovered over.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true`.\n     * @default 2000\n     */",
      "tooltipHideDelay?": "/** The delay in milliseconds that it takes for tooltips to hide once they have been displayed.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true` and `tooltipHideTriggers` includes `timeout`.\n     * @default 10000\n     */",
      "tooltipMouseTrack?": "/** Set to `true` to have tooltips follow the cursor once they are displayed.\n     * @default false\n     * @initial\n     */",
      "tooltipShowMode?": "/** This defines when tooltip will show up for Cells, Headers and SetFilter Items.\n     *  - `standard` - The tooltip always shows up when the items configured with Tooltips are hovered.\n     * - `whenTruncated` - The tooltip will only be displayed when the items hovered have truncated (showing ellipsis) values. This property does not work when `enableBrowserTooltips={true}`.\n     * @default `standard`\n     */",
      "tooltipInteraction?": "/** Set to `true` to enable tooltip interaction. When this option is enabled, the tooltip will not hide while the\n     * tooltip itself it being hovered or has focus.\n     * @default false\n     * @initial\n     */",
      "popupParent?": "/** DOM element to use as the popup parent for grid popups (context menu, column menu etc).\n     */",
      "copyHeadersToClipboard?": "/** Set to `true` to also include headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "copyGroupHeadersToClipboard?": "/** Set to `true` to also include group headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "clipboardDelimiter?": "/** Specify the delimiter to use when copying to clipboard.\n     * @default '\\t'\n     */",
      "suppressCopyRowsToClipboard?": "/** Set to `true` to copy the cell range or focused cell to the clipboard and never the selected rows.\n     * @default false\n     */",
      "suppressCopySingleCellRanges?": "/** Set to `true` to copy rows instead of ranges when a range with only a single cell is selected.\n     * @default false\n     */",
      "suppressLastEmptyLineOnPaste?": "/** Set to `true` to work around a bug with Excel (Windows) that adds an extra empty line at the end of ranges copied to the clipboard.\n     * @default false\n     */",
      "suppressClipboardPaste?": "/** Set to `true` to turn off paste operations within the grid.\n     * @default false\n     */",
      "suppressClipboardApi?": "/** Set to `true` to stop the grid trying to use the Clipboard API, if it is blocked, and immediately fallback to the workaround.\n     * @default false\n     */",
      "suppressCutToClipboard?": "/** Set to `true` to block **cut** operations within the grid.\n     * @default false\n     */",
      "columnDefs?": "/** Array of Column / Column Group definitions.\n     */",
      "defaultColDef?": "/** A default column definition. Items defined in the actual column definitions get precedence.\n     */",
      "defaultColGroupDef?": "/** A default column group definition. All column group definitions will use these properties. Items defined in the actual column group definition get precedence.\n     * @initial\n     */",
      "columnTypes?": "/** An object map of custom column types which contain groups of properties that column definitions can reuse by referencing in their `type` property.\n     */",
      "dataTypeDefinitions?": "/** An object map of cell data types to their definitions.\n     * Cell data types can either override/update the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`),\n     * or can be custom data types.\n     */",
      "maintainColumnOrder?": "/** Keeps the order of Columns maintained after new Column Definitions are updated.\n     * @default false\n     */",
      "suppressFieldDotNotation?": "/** If `true`, then dots in field names (e.g. `'address.firstLine'`) are not treated as deep references. Allows you to use dots in your field name if you prefer.\n     * @default false\n     */",
      "headerHeight?": "/** The height in pixels for the row containing the column label header. If not specified, it uses the theme value of `header-height`.\n     */",
      "groupHeaderHeight?": "/** The height in pixels for the rows containing header column groups. If not specified, it uses `headerHeight`.\n     */",
      "floatingFiltersHeight?": "/** The height in pixels for the row containing the floating filters. If not specified, it uses the theme value of `header-height`.\n     */",
      "pivotHeaderHeight?": "/** The height in pixels for the row containing the columns when in pivot mode. If not specified, it uses `headerHeight`.\n     */",
      "pivotGroupHeaderHeight?": "/** The height in pixels for the row containing header column groups when in pivot mode. If not specified, it uses `groupHeaderHeight`.\n     */",
      "allowDragFromColumnsToolPanel?": "/** Allow reordering and pinning columns by dragging columns from the Columns Tool Panel to the grid.\n     * @default false\n     */",
      "suppressMovableColumns?": "/** Set to `true` to suppress column moving, i.e. to make the columns fixed position.\n     * @default false\n     */",
      "suppressColumnMoveAnimation?": "/** If `true`, the `ag-column-moving` class is not added to the grid while columns are moving. In the default themes, this results in no animation when moving columns.\n     * @default false\n     */",
      "suppressDragLeaveHidesColumns?": "/** If `true`, when you drag a column out of the grid (e.g. to the group zone) the column is not hidden.\n     * @default false\n     */",
      "suppressRowGroupHidesColumns?": "/** If `true`, when you drag a column into a row group panel the column is not hidden.\n     * @default false\n     */",
      "colResizeDefault?": "/** Set to `'shift'` to have shift-resize as the default resize operation (same as user holding down `Shift` while resizing).\n     */",
      "suppressAutoSize?": "/** Suppresses auto-sizing columns for columns. In other words, double clicking a column's header's edge will not auto-size.\n     * @default false\n     * @initial\n     */",
      "autoSizePadding?": "/** Number of pixels to add to a column width after the [auto-sizing](./column-sizing/#auto-size-columns-to-fit-cell-contents) calculation.\n     * Set this if you want to add extra room to accommodate (for example) sort icons, or some other dynamic nature of the header.\n     * @default 20\n     */",
      "skipHeaderOnAutoSize?": "/** Set this to `true` to skip the `headerName` when `autoSize` is called by default.\n     * @default false\n     * @initial\n     */",
      "autoSizeStrategy?": "/** Auto-size the columns when the grid is loaded. Can size to fit the grid width, fit a provided width, or fit the cell contents.\n     * @initial\n     */",
      "components?": "/** A map of component names to components.\n     * @initial\n     */",
      "editType?": "/** Set to `'fullRow'` to enable Full Row Editing. Otherwise leave blank to edit one cell at a time.\n     */",
      "singleClickEdit?": "/** Set to `true` to enable Single Click Editing for cells, to start editing with a single click.\n     * @default false\n     */",
      "suppressClickEdit?": "/** Set to `true` so that neither single nor double click starts editing.\n     * @default false\n     */",
      "readOnlyEdit?": "/** Set to `true` to stop the grid updating data after `Edit`, `Clipboard` and `Fill Handle` operations. When this is set, it is intended the application will update the data, eg in an external immutable store, and then pass the new dataset to the grid. <br />**Note:** `rowNode.setDataValue()` does not update the value of the cell when this is `True`, it fires `onCellEditRequest` instead.\n     * @default false\n     */",
      "stopEditingWhenCellsLoseFocus?": "/** Set this to `true` to stop cell editing when grid loses focus.\n     * The default is that the grid stays editing until focus goes onto another cell.\n     * @default false\n     * @initial\n     */",
      "enterNavigatesVertically?": "/** Set to `true` along with `enterNavigatesVerticallyAfterEdit` to have Excel-style behaviour for the `Enter` key.\n     * i.e. pressing the `Enter` key will move down to the cell beneath and `Shift+Enter` will move up to the cell above.\n     * @default false\n     */",
      "enterNavigatesVerticallyAfterEdit?": "/** Set to `true` along with `enterNavigatesVertically` to have Excel-style behaviour for the 'Enter' key.\n     * i.e. pressing the Enter key will move down to the cell beneath and Shift+Enter key will move up to the cell above.\n     * @default false\n     */",
      "enableCellEditingOnBackspace?": "/** Forces Cell Editing to start when backspace is pressed. This is only relevant for MacOS users.\n     */",
      "undoRedoCellEditing?": "/** Set to `true` to enable Undo / Redo while editing.\n     * @initial\n     */",
      "undoRedoCellEditingLimit?": "/** Set the size of the undo / redo stack.\n     * @default 10\n     * @initial\n     */",
      "defaultCsvExportParams?": "/** A default configuration object used to export to CSV.\n     */",
      "suppressCsvExport?": "/** Prevents the user from exporting the grid to CSV.\n     * @default false\n     */",
      "defaultExcelExportParams?": "/** A default configuration object used to export to Excel.\n     */",
      "suppressExcelExport?": "/** Prevents the user from exporting the grid to Excel.\n     * @default false\n     */",
      "excelStyles?": "/** A list (array) of Excel styles to be used when exporting to Excel with styles.\n     * @initial\n     */",
      "quickFilterText?": "/** Rows are filtered using this text as a Quick Filter.\n     */",
      "cacheQuickFilter?": "/** Set to `true` to turn on the Quick Filter cache, used to improve performance when using the Quick Filter.\n     * @default false\n     * @initial\n     */",
      "includeHiddenColumnsInQuickFilter?": "/** Hidden columns are excluded from the Quick Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "quickFilterParser?": "/** Changes how the Quick Filter splits the Quick Filter text into search terms.\n     */",
      "quickFilterMatcher?": "/** Changes the matching logic for whether a row passes the Quick Filter.\n     */",
      "applyQuickFilterBeforePivotOrAgg?": "/** When pivoting, Quick Filter is only applied on the pivoted data\n     * (or aggregated data if `groupAggFiltering = true`).\n     * Set to `true` to apply Quick Filter before pivoting (/aggregating) instead.\n     * @default false\n     */",
      "excludeChildrenWhenTreeDataFiltering?": "/** Set to `true` to override the default tree data filtering behaviour to instead exclude child nodes from filter results.\n     * @default false\n     */",
      "enableAdvancedFilter?": "/** Set to true to enable the Advanced Filter.\n     * @default false\n     */",
      "advancedFilterModel?": "/** @deprecated As of v31, use `initialState.filter.advancedFilterModel` instead.\n     * @initial\n     */",
      "includeHiddenColumnsInAdvancedFilter?": "/** Hidden columns are excluded from the Advanced Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "advancedFilterParent?": "/** DOM element to use as the parent for the Advanced Filter to allow it to appear outside of the grid.\n     * Set to `null` or `undefined` to appear inside the grid.\n     */",
      "advancedFilterBuilderParams?": "/** Customise the parameters passed to the Advanced Filter Builder.\n     */",
      "suppressAdvancedFilterEval?": "/** By default, Advanced Filter sanitises user input and passes it to `new Function()` to provide the best performance.\n     * Set to `true` to prevent this and use defined functions instead.\n     * This will result in slower filtering, but it enables Advanced Filter to work when `unsafe-eval` is disabled.\n     * @default false\n     */",
      "enableCharts?": "/** Set to `true` to Enable Charts.\n     * @default false\n     */",
      "chartThemes?": "/** The list of chart themes that a user can choose from in the chart panel.\n     * @default ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];\n     * @initial\n     */",
      "customChartThemes?": "/** A map containing custom chart themes.\n     * @initial\n     */",
      "chartThemeOverrides?": "/** Chart theme overrides applied to all themes.\n     * @initial\n     */",
      "chartToolPanelsDef?": "/** Allows customisation of the Chart Tool Panels, such as changing the tool panels visibility and order, as well as choosing which charts should be displayed in the chart panel.\n     * @initial\n     */",
      "chartMenuItems?": "/** Get chart menu items. Only applies when using AG Charts Enterprise.\n     */",
      "loadingCellRenderer?": "/** Provide your own loading cell renderer to use when data is loading via a DataSource.\n     * See [Loading Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-loading-cell-renderer/) for framework specific implementation details.\n     */",
      "loadingCellRendererParams?": "/** Params to be passed to the `loadingCellRenderer` component.\n     */",
      "loadingCellRendererSelector?": "/** Callback to select which loading cell renderer to be used when data is loading via a DataSource.\n     * @initial\n     */",
      "localeText?": "/** A map of key->value pairs for localising text within the grid.\n     * @initial\n     */",
      "masterDetail?": "/** Set to `true` to enable Master Detail.\n     * @default false\n     */",
      "keepDetailRows?": "/** Set to `true` to keep detail rows for when they are displayed again.\n     * @default false\n     * @initial\n     */",
      "keepDetailRowsCount?": "/** Sets the number of details rows to keep.\n     * @default 10\n     * @initial\n     */",
      "detailCellRenderer?": "/** Provide a custom `detailCellRenderer` to use when a master row is expanded.\n     * See [Detail Cell Renderer](https://www.ag-grid.com/javascript-data-grid/master-detail-custom-detail/) for framework specific implementation details.\n     */",
      "detailCellRendererParams?": "/** Specifies the params to be used by the Detail Cell Renderer. Can also be a function that provides the params to enable dynamic definitions of the params.\n     */",
      "detailRowHeight?": "/** Set fixed height in pixels for each detail row.\n     * @initial\n     */",
      "detailRowAutoHeight?": "/** Set to `true` to have the detail grid dynamically change it's height to fit it's rows.\n     * @initial\n     */",
      "context?": "/** Provides a context object that is provided to different callbacks the grid uses. Used for passing additional information to the callbacks by your application.\n     * @initial\n     */",
      "alignedGrids?": "/**\n     * A list of grids to treat as Aligned Grids.\n     * Provide a list if the grids / apis already exist or return via a callback to allow the aligned grids to be retrieved asynchronously.\n     * If grids are aligned then the columns and horizontal scrolling will be kept in sync.\n     */",
      "tabIndex?": "/** Change this value to set the tabIndex order of the Grid within your application.\n     * @default 0\n     * @initial\n     */",
      "rowBuffer?": "/** The number of rows rendered outside the viewable area the grid renders.\n     * Having a buffer means the grid will have rows ready to show as the user slowly scrolls vertically.\n     * @default 10\n     */",
      "valueCache?": "/** Set to `true` to turn on the value cache.\n     * @default false\n     * @initial\n     */",
      "valueCacheNeverExpires?": "/** Set to `true` to configure the value cache to not expire after data updates.\n     * @default false\n     * @initial\n     */",
      "enableCellExpressions?": "/** Set to `true` to allow cell expressions.\n     * @default false\n     * @initial\n     */",
      "suppressTouch?": "/** Disables touch support (but does not remove the browser's efforts to simulate mouse events on touch).\n     * @default false\n     * @initial\n     */",
      "suppressFocusAfterRefresh?": "/** Set to `true` to not set focus back on the grid after a refresh. This can avoid issues where you want to keep the focus on another part of the browser.\n     * @default false\n     */",
      "suppressAsyncEvents?": "/** Disables the asynchronous nature of the events introduced in v10, and makes them synchronous. This property only exists for the purpose of supporting legacy code which has a dependency on synchronous events from earlier versions (v9 or earlier) of AG Grid. **It is strongly recommended that you do not change this property unless you have legacy issues.**\n     * @deprecated v31 Events should be handled asynchronously.\n     * @default false\n     * @initial\n     */",
      "suppressBrowserResizeObserver?": "/** The grid will check for `ResizeObserver` and use it if it exists in the browser, otherwise it will use the grid's alternative implementation. Some users reported issues with Chrome's `ResizeObserver`. Use this property to always use the grid's alternative implementation should such problems exist.\n     * @default false\n     * @initial\n     */",
      "suppressPropertyNamesCheck?": "/** Disables showing a warning message in the console if using a `gridOptions` or `colDef` property that doesn't exist.\n     * @default false\n     * @initial\n     */",
      "suppressChangeDetection?": "/** Disables change detection.\n     * @default false\n     */",
      "debug?": "/** Set this to `true` to enable debug information from the grid and related components. Will result in additional logging being output, but very useful when investigating problems.\n     * @default false\n     * @initial\n     */",
      "loading?": "/** Show or hide the loading overlay.\n     */",
      "overlayLoadingTemplate?": "/** Provide a HTML string to override the default loading overlay.\n     */",
      "loadingOverlayComponent?": "/** Provide a custom loading overlay component.\n     * @initial\n     */",
      "loadingOverlayComponentParams?": "/** Customise the parameters provided to the loading overlay component.\n     */",
      "suppressLoadingOverlay?": "/** Disables the 'loading' overlay.\n     * @deprecated v32 - Deprecated. Use `loading=false` instead.\n     * @default false\n     * @initial\n     */",
      "overlayNoRowsTemplate?": "/** Provide a HTML string to override the default no-rows overlay.\n     */",
      "noRowsOverlayComponent?": "/** Provide a custom no-rows overlay component.\n     * @initial\n     */",
      "noRowsOverlayComponentParams?": "/** Customise the parameters provided to the no-rows overlay component.\n     */",
      "suppressNoRowsOverlay?": "/** Set to `true` to prevent the no-rows overlay being shown when there is no row data.\n     * @default false\n     * @initial\n     */",
      "pagination?": "/** Set whether pagination is enabled.\n     * @default false\n     */",
      "paginationPageSize?": "/** How many rows to load per page. If `paginationAutoPageSize` is specified, this property is ignored.\n     * @default 100\n     */",
      "paginationPageSizeSelector?": "/** Determines if the page size selector is shown in the pagination panel or not.\n     * Set to an array of values to show the page size selector with custom list of possible page sizes.\n     * Set to `true` to show the page size selector with the default page sizes `[20, 50, 100]`.\n     * Set to `false` to hide the page size selector.\n     * @default true\n     * @initial\n     */",
      "paginationAutoPageSize?": "/** Set to `true` so that the number of rows to load per page is automatically adjusted by the grid so each page shows enough rows to just fill the area designated for the grid. If `false`, `paginationPageSize` is used.\n     * @default false\n     */",
      "paginateChildRows?": "/** Set to `true` to have pages split children of groups when using Row Grouping or detail rows with Master Detail.\n     * @default false\n     * @initial\n     */",
      "suppressPaginationPanel?": "/** If `true`, the default grid controls for navigation are hidden.\n     * This is useful if `pagination=true` and you want to provide your own pagination controls.\n     * Otherwise, when `pagination=true` the grid automatically shows the necessary controls at the bottom so that the user can navigate through the different pages.\n     * @default false\n     */",
      "pivotMode?": "/** Set to `true` to enable pivot mode.\n     * @default false\n     */",
      "pivotPanelShow?": "/** When to show the 'pivot panel' (where you drag rows to pivot) at the top. Note that the pivot panel will never show if `pivotMode` is off.\n     * @default 'never'\n     * @initial\n     */",
      "pivotMaxGeneratedColumns?": "/** The maximum number of generated columns before the grid halts execution. Upon reaching this number, the grid halts generation of columns\n     * and triggers a `pivotMaxColumnsExceeded` event. `-1` for no limit.\n     * @default -1\n     */",
      "pivotDefaultExpanded?": "/** If pivoting, set to the number of column group levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "pivotColumnGroupTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear within the Pivot Column Groups, in the position specified.\n     */",
      "pivotRowTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear for each value column in the position specified.\n     */",
      "pivotSuppressAutoColumn?": "/** If `true`, the grid will not swap in the grouping column when pivoting. Useful if pivoting using Server Side Row Model or Viewport Row Model and you want full control of all columns including the group column.\n     * @default false\n     * @initial\n     */",
      "suppressExpandablePivotGroups?": "/** When enabled, pivot column groups will appear 'fixed', without the ability to expand and collapse the column groups.\n     * @default false\n     * @initial\n     */",
      "functionsReadOnly?": "/** If `true`, then row group, pivot and value aggregation will be read-only from the GUI. The grid will display what values are used for each, but will not allow the user to change the selection.\n     * @default false\n     */",
      "aggFuncs?": "/** A map of 'function name' to 'function' for custom aggregation functions.\n     * @initial\n     */",
      "suppressAggFuncInHeader?": "/** When `true`, column headers won't include the `aggFunc` name, e.g. `'sum(Bank Balance)`' will just be `'Bank Balance'`.\n     * @default false\n     * @initial\n     */",
      "alwaysAggregateAtRootLevel?": "/** When using aggregations, the grid will always calculate the root level aggregation value.\n     * @default false\n     */",
      "aggregateOnlyChangedColumns?": "/** When using change detection, only the updated column will be re-aggregated.\n     * @default false\n     */",
      "suppressAggFilteredOnly?": "/** Set to `true` so that aggregations are not impacted by filtering.\n     * @default false\n     */",
      "removePivotHeaderRowWhenSingleValueColumn?": "/** Set to `true` to omit the value Column header when there is only a single value column.\n     * @default false\n     * @initial\n     */",
      "animateRows?": "/** Set to `false` to disable Row Animation which is enabled by default.\n     * @default true\n     */",
      "enableCellChangeFlash?": "/** Set to `true` to have cells flash after data changes.\n     * @default false\n     * @deprecated 31.2 use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns.\n     */",
      "cellFlashDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long a cell should remain in its \"flashed\" state.\n     * @default 500\n     */",
      "cellFlashDelay?": "/** @deprecated v31.1 - use `cellFlashDuration` instead.\n     */",
      "cellFadeDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long the \"flashed\" state animation takes to fade away after the timer set by cellFlashDuration has completed.\n     * @default 1000\n     */",
      "cellFadeDelay?": "/** @deprecated v31.1 - use `cellFadeDuration` instead.\n     */",
      "allowShowChangeAfterFilter?": "/** Set to `true` to have cells flash after data changes even when the change is due to filtering.\n     * @default false\n     * @initial\n     */",
      "domLayout?": "/** Switch between layout options: `normal`, `autoHeight`, `print`.\n     * @default 'normal'\n     */",
      "ensureDomOrder?": "/** When `true`, the order of rows and columns in the DOM are consistent with what is on screen.\n     * Disables row animations.\n     * @default false\n     * @initial\n     */",
      "enableRtl?": "/** Set to `true` to operate the grid in RTL (Right to Left) mode.\n     * @default false\n     * @initial\n     */",
      "suppressColumnVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the columns. For example, if you have 100 columns, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "suppressMaxRenderedRowRestriction?": "/** By default the grid has a limit of rendering a maximum of 500 rows at once (remember the grid only renders rows you can see, so unless your display shows more than 500 rows without vertically scrolling this will never be an issue).\n     * <br />**This is only relevant if you are manually setting `rowBuffer` to a high value (rendering more rows than can be seen), or `suppressRowVirtualisation` is true, or if your grid height is able to display more than 500 rows at once.**\n     * @default false\n     * @initial\n     */",
      "suppressRowVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the rows. For example, if you have 100 rows, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "rowDragManaged?": "/** Set to `true` to enable Managed Row Dragging.\n     * @default false\n     */",
      "suppressRowDrag?": "/** Set to `true` to suppress row dragging.\n     * @default false\n     */",
      "suppressMoveWhenRowDragging?": "/** Set to `true` to suppress moving rows while dragging the `rowDrag` waffle. This option highlights the position where the row will be placed and it will only move the row on mouse up.\n     * @default false\n     */",
      "rowDragEntireRow?": "/** Set to `true` to enable clicking and dragging anywhere on the row without the need for a drag handle.\n     * @default false\n     */",
      "rowDragMultiRow?": "/** Set to `true` to enable dragging multiple rows at the same time.\n     * @default false\n     */",
      "rowDragText?": "/** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.\n     * If this callback is not set, the current cell value will be used.\n     * If the `rowDragText` callback is set in the ColDef it will take precedence over this, except when\n     * `rowDragEntireRow=true`.\n     * @initial\n     */",
      "fullWidthCellRenderer?": "/** Provide your own cell renderer component to use for full width rows.\n     * See [Full Width Rows](https://www.ag-grid.com/javascript-data-grid/full-width-rows/) for framework specific implementation details.\n     */",
      "fullWidthCellRendererParams?": "/** Customise the parameters provided to the `fullWidthCellRenderer` component.\n     */",
      "embedFullWidthRows?": "/** Set to `true` to have the Full Width Rows embedded in grid's main container so they can be scrolled horizontally.\n     */",
      "suppressGroupMaintainValueType?": "/** @deprecated v31\n     * When enabled, the grid will cast group values to string type.\n     * @default false\n     * @initial\n     */",
      "groupDisplayType?": "/** Specifies how the results of row grouping should be displayed.\n     *\n     *  The options are:\n     *\n     * - `'singleColumn'`: single group column automatically added by the grid.\n     * - `'multipleColumns'`: a group column per row group is added automatically.\n     * - `'groupRows'`: group rows are automatically added instead of group columns.\n     * - `'custom'`: informs the grid that group columns will be provided.\n     */",
      "groupDefaultExpanded?": "/** If grouping, set to the number of levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "autoGroupColumnDef?": "/** Allows specifying the group 'auto column' if you are not happy with the default. If grouping, this column definition is included as the first column in the grid. If not grouping, this column is not included.\n     */",
      "groupMaintainOrder?": "/** When `true`, preserves the current group order when sorting on non-group columns.\n     * @default false\n     */",
      "groupSelectsChildren?": "/** When `true`, if you select a group, the children of the group will also be selected.\n     * @default false\n     */",
      "groupLockGroupColumns?": "/** If grouping, locks the group settings of a number of columns, e.g. `0` for no group locking. `1` for first group column locked, `-1` for all group columns locked.\n     * @default 0\n     * @initial\n     */",
      "groupAggFiltering?": "/** Set to determine whether filters should be applied on aggregated group values.\n     * @default false\n     */",
      "groupIncludeFooter?": "/** If grouping, this controls whether to show a group footer when the group is expanded.\n     * If `true`, then by default, the footer will contain aggregate data (if any) when shown and the header will be blank.\n     * When closed, the header will contain the aggregate data regardless of this setting (as the footer is hidden anyway).\n     * This is handy for 'total' rows, that are displayed below the data when the group is open, and alongside the group when it is closed.\n     * If a callback function is provided, it can used to select which groups will have a footer added.\n     * @default false\n     *\n     * @deprecated v31.3 - use `groupTotalRow` instead.\n     */",
      "groupIncludeTotalFooter?": "/** Set to `true` to show a 'grand total' group footer across all groups.\n     * @default false\n     *\n     * @deprecated v31.3 - use `grandTotalRow` instead.\n     */",
      "groupTotalRow?": "/** When provided, an extra row group total row will be inserted into row groups at the specified position, to display\n     * when the group is expanded. This row will contain the aggregate values for the group. If a callback function is\n     * provided, it can be used to selectively determine which groups will have a total row added.\n     */",
      "grandTotalRow?": "/** When provided, an extra grand total row will be inserted into the grid at the specified position.\n     * This row displays the aggregate totals of all rows in the grid.\n     */",
      "suppressStickyTotalRow?": "/** Suppress the sticky behaviour of the total rows, can be suppressed individually by passing `'grand'` or `'group'`.\n     */",
      "groupSuppressBlankHeader?": "/** If `true`, and showing footer, aggregate data will always be displayed at both the header and footer levels. This stops the possibly undesirable behaviour of the header details 'jumping' to the footer on expand.\n     * @default false\n     */",
      "groupSelectsFiltered?": "/** If using `groupSelectsChildren`, then only the children that pass the current filter will get selected.\n     * @default false\n     */",
      "showOpenedGroup?": "/** Shows the open group in the group column for non-group rows.\n     * @default false\n     */",
      "groupRemoveSingleChildren?": "/** Set to `true` to collapse groups that only have one child.\n     * @default false\n     */",
      "groupRemoveLowestSingleChildren?": "/** Set to `true` to collapse lowest level groups that only have one child.\n     * @default false\n     */",
      "groupHideOpenParents?": "/** Set to `true` to hide parents that are open. When used with multiple columns for showing groups, it can give a more pleasing user experience.\n     * @default false\n     */",
      "groupAllowUnbalanced?": "/** Set to `true` to prevent the grid from creating a '(Blanks)' group for nodes which do not belong to a group, and display the unbalanced nodes alongside group nodes.\n     * @default false\n     */",
      "rowGroupPanelShow?": "/** When to show the 'row group panel' (where you drag rows to group) at the top.\n     * @default 'never'\n     */",
      "groupRowRenderer?": "/** Provide the Cell Renderer to use when `groupDisplayType = 'groupRows'`.\n     * See [Group Row Cell Renderer](https://www.ag-grid.com/javascript-data-grid/grouping-group-rows/#providing-cell-renderer) for framework specific implementation details.\n     */",
      "groupRowRendererParams?": "/** Customise the parameters provided to the `groupRowRenderer` component.\n     */",
      "suppressMakeColumnVisibleAfterUnGroup?": "/** By default, when a column is un-grouped, i.e. using the Row Group Panel, it is made visible in the grid. This property stops the column becoming visible again when un-grouping.\n     * @default false\n     */",
      "treeData?": "/** Set to `true` to enable the Grid to work with Tree Data. You must also implement the `getDataPath(data)` callback.\n     * @default false\n     */",
      "rowGroupPanelSuppressSort?": "/** Set to `true` to suppress sort indicators and actions from the row group panel.\n     * @default false\n     * @initial\n     */",
      "suppressGroupRowsSticky?": "/** Set to `true` prevent Group Rows from sticking to the top of the grid.\n     * @default false\n     * @initial\n     */",
      "pinnedTopRowData?": "/** Data to be displayed as pinned top rows in the grid.\n     */",
      "pinnedBottomRowData?": "/** Data to be displayed as pinned bottom rows in the grid.\n     */",
      "rowModelType?": "/** Sets the row model type.\n     * @default 'clientSide'\n     * @initial\n     */",
      "rowData?": "/** Set the data to be displayed as rows in the grid.\n     */",
      "asyncTransactionWaitMillis?": "/** How many milliseconds to wait before executing a batch of async transactions.\n     */",
      "suppressModelUpdateAfterUpdateTransaction?": "/** Prevents Transactions changing sort, filter, group or pivot state when transaction only contains updates.\n     * @default false\n     */",
      "datasource?": "/** Provide the datasource for infinite scrolling.\n     */",
      "cacheOverflowSize?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "infiniteInitialRowCount?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "serverSideInitialRowCount?": "/** Set how many loading rows to display to the user for the root level group.\n     * @default 1\n     * @initial\n     */",
      "suppressServerSideInfiniteScroll?": "/** When `true`, the Server-side Row Model will suppress Infinite Scrolling and load all the data at the current level.\n     * @default false\n     * @initial\n     * @deprecated v31.1\n     */",
      "suppressServerSideFullWidthLoadingRow?": "/** When `true`, the Server-side Row Model will not use a full width loading renderer, instead using the colDef `loadingCellRenderer` if present.\n     */",
      "cacheBlockSize?": "/** How many rows for each block in the store, i.e. how many rows returned from the server at a time.\n     * @default 100\n     */",
      "maxBlocksInCache?": "/** How many blocks to keep in the store. Default is no limit, so every requested block is kept. Use this if you have memory concerns, and blocks that were least recently viewed will be purged when the limit is hit. The grid will additionally make sure it has all the blocks needed to display what is currently visible, in case this property is set to a low value.\n     * @initial\n     */",
      "maxConcurrentDatasourceRequests?": "/** How many requests to hit the server with concurrently. If the max is reached, requests are queued.\n     * Set to `-1` for no maximum restriction on requests.\n     * @default 2\n     * @initial\n     */",
      "blockLoadDebounceMillis?": "/** How many milliseconds to wait before loading a block. Useful when scrolling over many blocks, as it prevents blocks loading until scrolling has settled.\n     * @initial\n     */",
      "purgeClosedRowNodes?": "/** When enabled, closing group rows will remove children of that row. Next time the row is opened, child rows will be read from the datasource again. This property only applies when there is Row Grouping or Tree Data.\n     * @default false\n     */",
      "serverSideDatasource?": "/** Provide the `serverSideDatasource` for server side row model.\n     */",
      "serverSideSortAllLevels?": "/** When enabled, always refreshes top level groups regardless of which column was sorted. This property only applies when there is Row Grouping & sorting is handled on the server.\n     * @default false\n     */",
      "serverSideEnableClientSideSort?": "/** When enabled, sorts fully loaded groups in the browser instead of requesting from the server.\n     * @default false\n     */",
      "serverSideOnlyRefreshFilteredGroups?": "/** When enabled, only refresh groups directly impacted by a filter. This property only applies when there is Row Grouping & filtering is handled on the server.\n     * @default false\n     * @initial\n     */",
      "serverSideSortOnServer?": "/** When enabled, Sorting will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSideFilterOnServer?": "/** When enabled, Filtering will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSidePivotResultFieldSeparator?": "/** Used to split pivot field strings for generating pivot result columns when `pivotResultFields` is provided as part of a `getRows` success.\n     * @default '_'\n     * @initial\n     */",
      "viewportDatasource?": "/** To use the viewport row model you need to provide the grid with a `viewportDatasource`.\n     */",
      "viewportRowModelPageSize?": "/** When using viewport row model, sets the page size for the viewport.\n     * @initial\n     */",
      "viewportRowModelBufferSize?": "/** When using viewport row model, sets the buffer size for the viewport.\n     * @initial\n     */",
      "alwaysShowHorizontalScroll?": "/** Set to `true` to always show the horizontal scrollbar.\n     * @default false\n     */",
      "alwaysShowVerticalScroll?": "/** Set to `true` to always show the vertical scrollbar.\n     * @default false\n     */",
      "debounceVerticalScrollbar?": "/** Set to `true` to debounce the vertical scrollbar. Can provide smoother scrolling on slow machines.\n     * @default false\n     * @initial\n     */",
      "suppressHorizontalScroll?": "/** Set to `true` to never show the horizontal scroll. This is useful if the grid is aligned with another grid and will scroll when the other grid scrolls. (Should not be used in combination with `alwaysShowHorizontalScroll`.)\n     * @default false\n     */",
      "suppressScrollOnNewData?": "/** When `true`, the grid will not scroll to the top when new row data is provided. Use this if you don't want the default behaviour of scrolling to the top every time you load new data.\n     * @default false\n     */",
      "suppressScrollWhenPopupsAreOpen?": "/** When `true`, the grid will not allow mousewheel / touchpad scroll when popup elements are present.\n     * @default false\n     */",
      "suppressAnimationFrame?": "/** When `true`, the grid will not use animation frames when drawing rows while scrolling. Use this if the grid is working fast enough that you don't need animation frames and you don't want the grid to flicker.\n     * @default false\n     * @initial\n     */",
      "suppressMiddleClickScrolls?": "/** If `true`, middle clicks will result in `click` events for cells and rows. Otherwise the browser will use middle click to scroll the grid.<br />**Note:** Not all browsers fire `click` events with the middle button. Most will fire only `mousedown` and `mouseup` events, which can be used to focus a cell, but will not work to call the `onCellClicked` function.\n     * @default false\n     */",
      "suppressPreventDefaultOnMouseWheel?": "/** If `true`, mouse wheel events will be passed to the browser. Useful if your grid has no vertical scrolls and you want the mouse to scroll the browser page.\n     * @default false\n     * @initial\n     */",
      "scrollbarWidth?": "/** Tell the grid how wide in pixels the scrollbar is, which is used in grid width calculations. Set only if using non-standard browser-provided scrollbars, so the grid can use the non-standard size in its calculations.\n     * @initial\n     */",
      "rowSelection?": "/** Type of Row Selection: `single`, `multiple`.\n     */",
      "rowMultiSelectWithClick?": "/** Set to `true` to allow multiple rows to be selected using single click.\n     * @default false\n     */",
      "suppressRowDeselection?": "/** If `true`, rows will not be deselected if you hold down `Ctrl` and click the row or press `Space`.\n     * @default false\n     */",
      "suppressRowClickSelection?": "/** If `true`, row selection won't happen when rows are clicked. Use when you only want checkbox selection.\n     * @default false\n     */",
      "suppressCellFocus?": "/** If `true`, cells won't be focusable. This means keyboard navigation will be disabled for grid cells, but remain enabled in other elements of the grid such as column headers, floating filters, tool panels.\n     * @default false\n     */",
      "suppressHeaderFocus?": "/** If `true`, header cells won't be focusable. This means keyboard navigation will be disabled for grid header cells, but remain enabled in other elements of the grid such as grid cells and tool panels.\n     * @default false\n     */",
      "suppressMultiRangeSelection?": "/** If `true`, only a single range can be selected.\n     * @default false\n     */",
      "enableCellTextSelection?": "/** Set to `true` to be able to select the text within cells.\n     *\n     * **Note:** When this is set to `true`, the clipboard service is disabled and only selected text is copied.\n     * @default false\n     */",
      "enableRangeSelection?": "/** Set to `true` to enable Range Selection.\n     * @default false\n     */",
      "enableRangeHandle?": "/** Set to `true` to enable the Range Handle.\n     * @default false\n     */",
      "enableFillHandle?": "/** Set to `true` to enable the Fill Handle.\n     * @default false\n     */",
      "fillHandleDirection?": "/** Set to `'x'` to force the fill handle direction to horizontal, or set to `'y'` to force the fill handle direction to vertical.\n     * @default 'xy'\n     */",
      "suppressClearOnFillReduction?": "/** Set this to `true` to prevent cell values from being cleared when the Range Selection is reduced by the Fill Handle.\n     * @default false\n     */",
      "sortingOrder?": "/** Array defining the order in which sorting occurs (if sorting is enabled). Values can be `'asc'`, `'desc'` or `null`. For example: `sortingOrder: ['asc', 'desc']`.\n     * @default [null, 'asc', 'desc']\n     */",
      "accentedSort?": "/** Set to `true` to specify that the sort should take accented characters into account. If this feature is turned on the sort will be slower.\n     * @default false\n     */",
      "unSortIcon?": "/** Set to `true` to show the 'no sort' icon.\n     * @default false\n     */",
      "suppressMultiSort?": "/** Set to `true` to suppress multi-sort when the user shift-clicks a column header.\n     * @default false\n     */",
      "alwaysMultiSort?": "/** Set to `true` to always multi-sort when the user clicks a column header, regardless of key presses.\n     * @default false\n     */",
      "multiSortKey?": "/** Set to `'ctrl'` to have multi sorting work using the `Ctrl` (or `Command ⌘` for Mac) key.\n     */",
      "suppressMaintainUnsortedOrder?": "/** Set to `true` to suppress sorting of un-sorted data to match original row data.\n     * @default false\n     */",
      "icons?": "/** Icons to use inside the grid instead of the grid's default icons.\n     * @initial\n     */",
      "rowHeight?": "/** Default row height in pixels.\n     * @default 25\n     */",
      "rowStyle?": "/** The style properties to apply to all rows. Set to an object of key (style names) and values (style values).\n     */",
      "rowClass?": "/** CSS class(es) for all rows. Provide either a string (class name) or array of strings (array of class names).\n     */",
      "rowClassRules?": "/** Rules which can be applied to include certain CSS classes.\n     */",
      "suppressRowHoverHighlight?": "/** Set to `true` to not highlight rows by adding the `ag-row-hover` CSS class.\n     * @default false\n     */",
      "suppressRowTransform?": "/** Uses CSS `top` instead of CSS `transform` for positioning rows. Useful if the transform function is causing issues such as used in row spanning.\n     * @default false\n     * @initial\n     */",
      "columnHoverHighlight?": "/** Set to `true` to highlight columns by adding the `ag-column-hover` CSS class.\n     * @default false\n     */",
      "gridId?": "/** Provide a custom `gridId` for this instance of the grid. Value will be set on the root DOM node using the attribute `grid-id` as well as being accessible via the `gridApi.getGridId()` method.\n     * @initial\n     */",
      "deltaSort?": "/** When enabled, sorts only the rows added/updated by a transaction.\n     * @default false\n     */",
      "treeDataDisplayType?": "/**/",
      "enableGroupEdit?": "/** @initial\n     */",
      "initialState?": "/** Initial state for the grid. Only read once on initialization. Can be used in conjunction with `api.getState()` to save and restore grid state.\n     * @initial\n     */",
      "reactiveCustomComponents?": "/** **React only**.\n     *\n     * @deprecated As of v32 custom components are created reactively by default.\n     * Set this property to `false` to switch to the legacy way of declaring custom components imperatively.\n     * @initial\n     * @default true\n     */",
      "getContextMenuItems?": "/** For customising the context menu.\n     */",
      "getMainMenuItems?": "/** For customising the main 'column header' menu.\n     * @initial\n     */",
      "postProcessPopup?": "/** Allows user to process popups after they are created. Applications can use this if they want to, for example, reposition the popup.\n     */",
      "processUnpinnedColumns?": "/** Allows the user to process the columns being removed from the pinned section because the viewport is too small to accommodate them.\n     * Returns an array of columns to be removed from the pinned areas.\n     * @initial\n     */",
      "processCellForClipboard?": "/** Allows you to process cells for the clipboard. Handy if for example you have `Date` objects that need to have a particular format if importing into Excel.\n     */",
      "processHeaderForClipboard?": "/** Allows you to process header values for the clipboard.\n     */",
      "processGroupHeaderForClipboard?": "/** Allows you to process group header values for the clipboard.\n     */",
      "processCellFromClipboard?": "/** Allows you to process cells from the clipboard. Handy if for example you have number fields, and want to block non-numbers from getting into the grid.\n     */",
      "sendToClipboard?": "/** Allows you to get the data that would otherwise go to the clipboard. To be used when you want to control the 'copy to clipboard' operation yourself.\n     */",
      "processDataFromClipboard?": "/** Allows complete control of the paste operation, including cancelling the operation (so nothing happens) or replacing the data with other data.\n     */",
      "isExternalFilterPresent?": "/** Grid calls this method to know if an external filter is present.\n     */",
      "doesExternalFilterPass?": "/** Should return `true` if external filter passes, otherwise `false`.\n     */",
      "getChartToolbarItems?": "/** Callback to be used to customise the chart toolbar items.\n     * @initial\n     */",
      "createChartContainer?": "/** Callback to enable displaying the chart in an alternative chart container.\n     * @initial\n     */",
      "focusGridInnerElement?": "/** Allows overriding the element that will be focused when the grid receives focus from outside elements (tabbing into the grid).\n     * @returns `True` if this function should override the grid's default behavior, `False` to allow the grid's default behavior.\n     */",
      "navigateToNextHeader?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a header is focused. Return the next Header position to navigate to or `null` to stay on current header.\n     */",
      "tabToNextHeader?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a header is focused.\n     * Return the next header position to navigate to, `true` to stay on the current header,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "navigateToNextCell?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a cell is focused. Return the next Cell position to navigate to or `null` to stay on current cell.\n     */",
      "tabToNextCell?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a cell is focused.\n     * Return the next cell position to navigate to, `true` to stay on the current cell,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "getLocaleText?": "/** A callback for localising text within the grid.\n     * @initial\n     */",
      "getDocument?": "/** Allows overriding what `document` is used. Currently used by Drag and Drop (may extend to other places in the future). Use this when you want the grid to use a different `document` than the one available on the global scope. This can happen if docking out components (something which Electron supports)\n     */",
      "paginationNumberFormatter?": "/** Allows user to format the numbers in the pagination panel, i.e. 'row count' and 'page number' labels. This is for pagination panel only, to format numbers inside the grid's cells (i.e. your data), then use `valueFormatter` in the column definitions.\n     * @initial\n     */",
      "getGroupRowAgg?": "/** Callback to use when you need access to more then the current column for aggregation.\n     */",
      "isGroupOpenByDefault?": "/** (Client-side Row Model only) Allows groups to be open by default.\n     */",
      "initialGroupOrderComparator?": "/** Allows default sorting of groups.\n     */",
      "processPivotResultColDef?": "/** Callback to be used with pivoting, to allow changing the second column definition.\n     */",
      "processPivotResultColGroupDef?": "/** Callback to be used with pivoting, to allow changing the second column group definition.\n     */",
      "getDataPath?": "/** Callback to be used when working with Tree Data when `treeData = true`.\n     */",
      "getChildCount?": "/** Allows setting the child count for a group row.\n     * @initial\n     */",
      "getServerSideGroupLevelParams?": "/** Allows providing different params for different levels of grouping.\n     * @initial\n     */",
      "isServerSideGroupOpenByDefault?": "/** Allows groups to be open by default.\n     */",
      "isApplyServerSideTransaction?": "/** Allows cancelling transactions.\n     */",
      "isServerSideGroup?": "/** SSRM Tree Data: Allows specifying which rows are expandable.\n     */",
      "getServerSideGroupKey?": "/** SSRM Tree Data: Allows specifying group keys.\n     */",
      "getBusinessKeyForNode?": "/** Return a business key for the node. If implemented, each row in the DOM will have an attribute `row-business-key='abc'` where `abc` is what you return as the business key.\n     * This is useful for automated testing, as it provides a way for your tool to identify rows based on unique business keys.\n     */",
      "getRowId?": "/** Allows setting the ID for a particular row node based on the data.\n     * @initial\n     */",
      "resetRowDataOnUpdate?": "/** When enabled, getRowId() callback is implemented and new Row Data is set, the grid will disregard all previous rows and treat the new Row Data as new data. As a consequence, all Row State (eg selection, rendered rows) will be reset.\n     * @default false\n     */",
      "processRowPostCreate?": "/** Callback fired after the row is rendered into the DOM. Should not be used to initiate side effects.\n     */",
      "isRowSelectable?": "/** Callback to be used to determine which rows are selectable. By default rows are selectable, so return `false` to make a row un-selectable.\n     */",
      "isRowMaster?": "/** Callback to be used with Master Detail to determine if a row should be a master row. If `false` is returned no detail row will exist for this row.\n     */",
      "fillOperation?": "/** Callback to fill values instead of simply copying values or increasing number values using linear progression.\n     */",
      "postSortRows?": "/** Callback to perform additional sorting after the grid has sorted the rows.\n     */",
      "getRowStyle?": "/** Callback version of property `rowStyle` to set style for each row individually. Function should return an object of CSS values or undefined for no styles.\n     */",
      "getRowClass?": "/** Callback version of property `rowClass` to set class(es) for each row individually. Function should return either a string (class name), array of strings (array of class names) or undefined for no class.\n     */",
      "getRowHeight?": "/** Callback version of property `rowHeight` to set height for each row individually. Function should return a positive number of pixels, or return `null`/`undefined` to use the default row height.\n     */",
      "isFullWidthRow?": "/** Tells the grid if this row should be rendered as full width.\n     */",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "/** The tool panel visibility has changed. Fires twice if switching between panels - once with the old panel and once with the new panel.\n     */",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "/** The tool panel size has been changed.\n     */",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "/** The column menu visibility has changed. Fires twice if switching between tabs - once with the old tab and once with the new tab.\n     */",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "/** The context menu visibility has changed (opened or closed).\n     */",
      "onCutStart?(event: CutStartEvent<TData>)": "/** Cut operation has started.\n     */",
      "onCutEnd?(event: CutEndEvent<TData>)": "/** Cut operation has ended.\n     */",
      "onPasteStart?(event: PasteStartEvent<TData>)": "/** Paste operation has started.\n     */",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "/** Paste operation has ended.\n     */",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "/** A column, or group of columns, was hidden / shown.\n     */",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "/** A column, or group of columns, was pinned / unpinned.\n     */",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "/** A column was resized.\n     */",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "/** A column was moved.\n     */",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "/** A value column was added or removed.\n     */",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "/** The pivot mode flag was changed.\n     */",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "/** A pivot column was added, removed or order changed.\n     */",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "/** A column group was opened / closed.\n     */",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "/** User set new columns.\n     */",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "/** The list of grid columns changed.\n     */",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "/** The list of displayed columns changed. This can result from columns open / close, column move, pivot, group, etc.\n     */",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "/** The list of rendered columns changed (only columns in the visible scrolled viewport are rendered by default).\n     */",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "/** Shotgun - gets called when either a) new columns are set or b) `api.applyColumnState()` is used, so everything has changed.\n     */",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "/** A mouse cursor is initially moved over a column header.\n     */",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "/** A mouse cursor is moved out of a column header.\n     */",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "/** A click is performed on a column header.\n     */",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "/** A context menu action, such as right-click or context menu key press, is performed on a column header.\n     */",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "/** Only used by Angular, React and VueJS AG Grid components (not used if doing plain JavaScript).\n     * If the grid receives changes due to bound properties, this event fires after the grid has finished processing the change.\n     */",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "/** Value has changed after editing (this event will not fire if editing was cancelled, eg ESC was pressed) or\n     *  if cell value has changed as a result of cut, paste, cell clear (pressing Delete key),\n     * fill handle, copy range down, undo and redo.\n     */",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "/** Value has changed after editing. Only fires when `readOnlyEdit=true`.\n     */",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "/** A cell's value within a row has changed. This event corresponds to Full Row Editing only.\n     */",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "/** Editing a cell has started.\n     */",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "/** Editing a cell has stopped.\n     */",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "/** Editing a row has started (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStarted` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "/** Editing a row has stopped (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStopped` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "/** Undo operation has started.\n     */",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "/** Undo operation has ended.\n     */",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "/** Redo operation has started.\n     */",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "/** Redo operation has ended.\n     */",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "/** Range delete operation (cell clear) has started.\n     */",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "/** Range delete operation (cell clear) has ended.\n     */",
      "onFillStart?(event: FillStartEvent<TData>)": "/** Fill operation has started.\n     */",
      "onFillEnd?(event: FillEndEvent<TData>)": "/** Fill operation has ended.\n     */",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "/** Filter has been opened.\n     */",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "/** Filter has been modified and applied.\n     */",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "/** Filter was modified but not applied. Used when filters have 'Apply' buttons.\n     */",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "/** Advanced Filter Builder visibility has changed (opened or closed).\n     */",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "/** A chart has been created.\n     */",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "/** The data range for the chart has been changed.\n     */",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "/** Formatting changes have been made by users through the Customize Panel.\n     */",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "/** A chart has been destroyed.\n     */",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "/** DOM event `keyDown` happened on a cell.\n     */",
      "onGridReady?(event: GridReadyEvent<TData>)": "/** The grid has initialised and is ready for most api calls, but may not be fully rendered yet  */",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "/** Invoked immediately before the grid is destroyed. This is useful for cleanup logic that needs to run before the grid is torn down.\n     */",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "/** Fired the first time data is rendered into the grid. Use this event if you want to auto resize columns based on their contents */",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "/** The size of the grid `div` has changed. In other words, the grid was resized.\n     */",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "/** Displayed rows have changed. Triggered after sort, filter or tree expand / collapse events.\n     */",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "/** A row was removed from the DOM, for any reason. Use to clean up resources (if any) used by the row.\n     */",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "/** Which rows are rendered in the DOM has changed.\n     */",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "/** The body was scrolled horizontally or vertically.\n     */",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "/** Main body of the grid has stopped scrolling, either horizontally or vertically.\n     */",
      "onDragStarted?(event: DragStartedEvent<TData>)": "/** When dragging starts. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "/** When dragging stops. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "/** Grid state has been updated.\n     */",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "/** Triggered every time the paging state changes. Some of the most common scenarios for this event to be triggered are:\n     *\n     *  - The page size changes.\n     *  - The current shown page is changed.\n     *  - New data is loaded onto the grid.\n     */",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "/** A drag has started, or dragging was already started and the mouse has re-entered the grid having previously left the grid.\n     */",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "/** The mouse has moved while dragging.\n     */",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "/** The mouse has left the grid while dragging.\n     */",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "/** The drag has finished over the grid.\n     */",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "/** A row group column was added, removed or reordered.\n     */",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "/** A row group was opened or closed.\n     */",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "/** Fired when calling either of the API methods `expandAll()` or `collapseAll()`.\n     */",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "/** Exceeded the `pivotMaxGeneratedColumns` limit when generating columns.\n     */",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "/** The client has set new pinned row data into the grid.\n     */",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "/** Client-Side Row Model only. The client has updated data for the grid by either a) setting new Row Data or b) Applying a Row Transaction.\n     */",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "/** Async transactions have been applied. Contains a list of all transaction results.\n     */",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "/** A server side store has finished refreshing.\n     */",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "/** Header is focused.\n     */",
      "onCellClicked?(event: CellClickedEvent<TData>)": "/** Cell is clicked.\n     */",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "/** Cell is double clicked.\n     */",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "/** Cell is focused.\n     */",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "/** Mouse entered cell.\n     */",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "/** Mouse left cell.\n     */",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "/** Mouse down on cell.\n     */",
      "onRowClicked?(event: RowClickedEvent<TData>)": "/** Row is clicked.\n     */",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "/** Row is double clicked.\n     */",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "/** Row is selected or deselected. The event contains the node in question, so call the node's `isSelected()` method to see if it was just selected or deselected.\n     */",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "/** Row selection is changed. Use the grid API `getSelectedNodes()` or `getSelectedRows()` to get the new list of selected nodes / row data.\n     */",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "/** Cell is right clicked.\n     */",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "/** A change to range selection has occurred.\n     */",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "/** A tooltip has been displayed */",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "/** A tooltip was hidden */",
      "onSortChanged?(event: SortChangedEvent<TData>)": "/** Sort has changed. The grid also listens for this and updates the model.\n     */",
      "api?": "/** @deprecated Since v31 api is no longer attached to GridOptions. See https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api for how to access the api in your framework.\n     */"
    }
  },
  "AgReactUiProps": {
    "meta": {
      "typeParams": [
        "TData = any"
      ],
      "doc": "/** @deprecated v31.1 Use `AgGridReactProps` instead. */"
    },
    "type": {
      "gridOptions?": "GridOptions<TData>",
      "modules?": "Module[]",
      "containerStyle?": "any",
      "className?": "string",
      "setGridApi?": "(gridApi: GridApi<TData>) => void",
      "componentWrappingElement?": "string",
      "maxComponentCreationTimeMs?": "number",
      "children?": "any",
      "statusBar?": "{ statusPanels: StatusPanelDef[]; }",
      "sideBar?": "SideBarDef | string | string[] | boolean | null",
      "suppressContextMenu?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "columnMenu?": "'legacy' | 'new'",
      "suppressMenuHide?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "tooltipTrigger?": "'hover' | 'focus'",
      "tooltipShowDelay?": "number",
      "tooltipHideDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "tooltipShowMode?": "'standard' | 'whenTruncated'",
      "tooltipInteraction?": "boolean",
      "popupParent?": "HTMLElement | null",
      "copyHeadersToClipboard?": "boolean",
      "copyGroupHeadersToClipboard?": "boolean",
      "clipboardDelimiter?": "string",
      "suppressCopyRowsToClipboard?": "boolean",
      "suppressCopySingleCellRanges?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "suppressCutToClipboard?": "boolean",
      "columnDefs?": "(ColDef<TData> | ColGroupDef<TData>)[] | null",
      "defaultColDef?": "ColDef<TData>",
      "defaultColGroupDef?": "Partial<ColGroupDef<TData>>",
      "columnTypes?": "{ [key: string]: ColTypeDef<TData>; }",
      "dataTypeDefinitions?": "{ [cellDataType: string]: DataTypeDefinition<TData>; }",
      "maintainColumnOrder?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "headerHeight?": "number",
      "groupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "pivotHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "suppressRowGroupHidesColumns?": "boolean",
      "colResizeDefault?": "'shift'",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "autoSizeStrategy?": "SizeColumnsToFitGridStrategy | SizeColumnsToFitProvidedWidthStrategy | SizeColumnsToContentStrategy",
      "components?": "{ [p: string]: any; }",
      "editType?": "'fullRow'",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "readOnlyEdit?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "enterNavigatesVertically?": "boolean",
      "enterNavigatesVerticallyAfterEdit?": "boolean",
      "enableCellEditingOnBackspace?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "defaultCsvExportParams?": "CsvExportParams",
      "suppressCsvExport?": "boolean",
      "defaultExcelExportParams?": "ExcelExportParams",
      "suppressExcelExport?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "includeHiddenColumnsInQuickFilter?": "boolean",
      "quickFilterParser?": "(quickFilter: string) => string[]",
      "quickFilterMatcher?": "(quickFilterParts: string[], rowQuickFilterAggregateText: string) => boolean",
      "applyQuickFilterBeforePivotOrAgg?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "enableAdvancedFilter?": "boolean",
      "advancedFilterModel?": "AdvancedFilterModel | null",
      "includeHiddenColumnsInAdvancedFilter?": "boolean",
      "advancedFilterParent?": "HTMLElement | null",
      "advancedFilterBuilderParams?": "IAdvancedFilterBuilderParams",
      "suppressAdvancedFilterEval?": "boolean",
      "enableCharts?": "boolean",
      "chartThemes?": "string[]",
      "customChartThemes?": "{ [name: string]: AgChartTheme; }",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "chartToolPanelsDef?": "ChartToolPanelsDef",
      "chartMenuItems?": "(string | MenuItemDef)[] | GetChartMenuItems<TData>",
      "loadingCellRenderer?": "any",
      "loadingCellRendererParams?": "any",
      "loadingCellRendererSelector?": "LoadingCellRendererSelectorFunc<TData>",
      "localeText?": "{ [key: string]: string; }",
      "masterDetail?": "boolean",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "detailCellRenderer?": "any",
      "detailCellRendererParams?": "any",
      "detailRowHeight?": "number",
      "detailRowAutoHeight?": "boolean",
      "context?": "any",
      "alignedGrids?": "AlignedGrid[] | (() => AlignedGrid[])",
      "tabIndex?": "number",
      "rowBuffer?": "number",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "enableCellExpressions?": "boolean",
      "suppressTouch?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "suppressBrowserResizeObserver?": "boolean",
      "suppressPropertyNamesCheck?": "boolean",
      "suppressChangeDetection?": "boolean",
      "debug?": "boolean",
      "loading?": "boolean",
      "overlayLoadingTemplate?": "string",
      "loadingOverlayComponent?": "any",
      "loadingOverlayComponentParams?": "any",
      "suppressLoadingOverlay?": "boolean",
      "overlayNoRowsTemplate?": "string",
      "noRowsOverlayComponent?": "any",
      "noRowsOverlayComponentParams?": "any",
      "suppressNoRowsOverlay?": "boolean",
      "pagination?": "boolean",
      "paginationPageSize?": "number",
      "paginationPageSizeSelector?": "number[] | boolean",
      "paginationAutoPageSize?": "boolean",
      "paginateChildRows?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pivotMode?": "boolean",
      "pivotPanelShow?": "'always' | 'onlyWhenPivoting' | 'never'",
      "pivotMaxGeneratedColumns?": "number",
      "pivotDefaultExpanded?": "number",
      "pivotColumnGroupTotals?": "'before' | 'after'",
      "pivotRowTotals?": "'before' | 'after'",
      "pivotSuppressAutoColumn?": "boolean",
      "suppressExpandablePivotGroups?": "boolean",
      "functionsReadOnly?": "boolean",
      "aggFuncs?": "{ [key: string]: IAggFunc<TData>; }",
      "suppressAggFuncInHeader?": "boolean",
      "alwaysAggregateAtRootLevel?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "removePivotHeaderRowWhenSingleValueColumn?": "boolean",
      "animateRows?": "boolean",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDuration?": "number",
      "cellFlashDelay?": "number",
      "cellFadeDuration?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "domLayout?": "DomLayoutType",
      "ensureDomOrder?": "boolean",
      "enableRtl?": "boolean",
      "suppressColumnVirtualisation?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "suppressRowVirtualisation?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "rowDragEntireRow?": "boolean",
      "rowDragMultiRow?": "boolean",
      "rowDragText?": "(params: IRowDragItem, dragItemCount: number) => string",
      "fullWidthCellRenderer?": "any",
      "fullWidthCellRendererParams?": "any",
      "embedFullWidthRows?": "boolean",
      "suppressGroupMaintainValueType?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupDefaultExpanded?": "number",
      "autoGroupColumnDef?": "ColDef<TData>",
      "groupMaintainOrder?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupLockGroupColumns?": "number",
      "groupAggFiltering?": "boolean | IsRowFilterable<TData>",
      "groupIncludeFooter?": "boolean | UseGroupFooter<TData>",
      "groupIncludeTotalFooter?": "boolean",
      "groupTotalRow?": "'top' | 'bottom' | UseGroupTotalRow<TData>",
      "grandTotalRow?": "'top' | 'bottom'",
      "suppressStickyTotalRow?": "boolean | 'grand' | 'group'",
      "groupSuppressBlankHeader?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "showOpenedGroup?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "groupAllowUnbalanced?": "boolean",
      "rowGroupPanelShow?": "'always' | 'onlyWhenGrouping' | 'never'",
      "groupRowRenderer?": "any",
      "groupRowRendererParams?": "any",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "treeData?": "boolean",
      "rowGroupPanelSuppressSort?": "boolean",
      "suppressGroupRowsSticky?": "boolean",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "rowModelType?": "RowModelType",
      "rowData?": "TData[] | null",
      "asyncTransactionWaitMillis?": "number",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "datasource?": "IDatasource",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "serverSideInitialRowCount?": "number",
      "suppressServerSideInfiniteScroll?": "boolean",
      "suppressServerSideFullWidthLoadingRow?": "boolean",
      "cacheBlockSize?": "number",
      "maxBlocksInCache?": "number",
      "maxConcurrentDatasourceRequests?": "number",
      "blockLoadDebounceMillis?": "number",
      "purgeClosedRowNodes?": "boolean",
      "serverSideDatasource?": "IServerSideDatasource",
      "serverSideSortAllLevels?": "boolean",
      "serverSideEnableClientSideSort?": "boolean",
      "serverSideOnlyRefreshFilteredGroups?": "boolean",
      "serverSideSortOnServer?": "boolean",
      "serverSideFilterOnServer?": "boolean",
      "serverSidePivotResultFieldSeparator?": "string",
      "viewportDatasource?": "IViewportDatasource",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressScrollWhenPopupsAreOpen?": "boolean",
      "suppressAnimationFrame?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "scrollbarWidth?": "number",
      "rowSelection?": "'single' | 'multiple'",
      "rowMultiSelectWithClick?": "boolean",
      "suppressRowDeselection?": "boolean",
      "suppressRowClickSelection?": "boolean",
      "suppressCellFocus?": "boolean",
      "suppressHeaderFocus?": "boolean",
      "suppressMultiRangeSelection?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "'x' | 'y' | 'xy'",
      "suppressClearOnFillReduction?": "boolean",
      "sortingOrder?": "SortDirection[]",
      "accentedSort?": "boolean",
      "unSortIcon?": "boolean",
      "suppressMultiSort?": "boolean",
      "alwaysMultiSort?": "boolean",
      "multiSortKey?": "'ctrl'",
      "suppressMaintainUnsortedOrder?": "boolean",
      "icons?": "{ [key: string]: ((...args: any[]) => any) | string; }",
      "rowHeight?": "number",
      "rowStyle?": "RowStyle",
      "rowClass?": "string | string[]",
      "rowClassRules?": "RowClassRules<TData>",
      "suppressRowHoverHighlight?": "boolean",
      "suppressRowTransform?": "boolean",
      "columnHoverHighlight?": "boolean",
      "gridId?": "string",
      "deltaSort?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "enableGroupEdit?": "boolean",
      "initialState?": "GridState",
      "reactiveCustomComponents?": "boolean",
      "getContextMenuItems?": "GetContextMenuItems<TData>",
      "getMainMenuItems?": "GetMainMenuItems<TData>",
      "postProcessPopup?": "(params: PostProcessPopupParams<TData>) => void",
      "processUnpinnedColumns?": "(params: ProcessUnpinnedColumnsParams<TData>) => Column[]",
      "processCellForClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "processHeaderForClipboard?": "(params: ProcessHeaderForExportParams<TData>) => any",
      "processGroupHeaderForClipboard?": "(params: ProcessGroupHeaderForExportParams<TData>) => any",
      "processCellFromClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "sendToClipboard?": "(params: SendToClipboardParams<TData>) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams<TData>) => string[][] | null",
      "isExternalFilterPresent?": "(params: IsExternalFilterPresentParams<TData>) => boolean",
      "doesExternalFilterPass?": "(node: IRowNode<TData>) => boolean",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "createChartContainer?": "(params: ChartRefParams<TData>) => void",
      "focusGridInnerElement?": "(params: FocusGridInnerElementParams<TData>) => boolean",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams<TData>) => HeaderPosition | null",
      "tabToNextHeader?": "(params: TabToNextHeaderParams<TData>) => HeaderPosition | boolean | null",
      "navigateToNextCell?": "(params: NavigateToNextCellParams<TData>) => CellPosition | null",
      "tabToNextCell?": "(params: TabToNextCellParams<TData>) => CellPosition | boolean | null",
      "getLocaleText?": "(params: GetLocaleTextParams<TData>) => string",
      "getDocument?": "() => Document",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams<TData>) => string",
      "getGroupRowAgg?": "(params: GetGroupRowAggParams<TData>) => any",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams<TData>) => boolean",
      "initialGroupOrderComparator?": "(params: InitialGroupOrderComparatorParams<TData>) => number",
      "processPivotResultColDef?": "(colDef: ColDef<TData>) => void",
      "processPivotResultColGroupDef?": "(colGroupDef: ColGroupDef<TData>) => void",
      "getDataPath?": "GetDataPath<TData>",
      "getChildCount?": "(dataItem: any) => number",
      "getServerSideGroupLevelParams?": "(params: GetServerSideGroupLevelParamsParams) => ServerSideGroupLevelParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "isServerSideGroup?": "IsServerSideGroup",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getBusinessKeyForNode?": "(node: IRowNode<TData>) => string",
      "getRowId?": "GetRowIdFunc<TData>",
      "resetRowDataOnUpdate?": "boolean",
      "processRowPostCreate?": "(params: ProcessRowParams<TData>) => void",
      "isRowSelectable?": "IsRowSelectable<TData>",
      "isRowMaster?": "IsRowMaster<TData>",
      "fillOperation?": "(params: FillOperationParams<TData>) => any",
      "postSortRows?": "(params: PostSortRowsParams<TData>) => void",
      "getRowStyle?": "(params: RowClassParams<TData>) => RowStyle | undefined",
      "getRowClass?": "(params: RowClassParams<TData>) => string | string[] | undefined",
      "getRowHeight?": "(params: RowHeightParams<TData>) => number | undefined | null",
      "isFullWidthRow?": "(params: IsFullWidthRowParams<TData>) => boolean",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "void",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "void",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "void",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "void",
      "onCutStart?(event: CutStartEvent<TData>)": "void",
      "onCutEnd?(event: CutEndEvent<TData>)": "void",
      "onPasteStart?(event: PasteStartEvent<TData>)": "void",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "void",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "void",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "void",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "void",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "void",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "void",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "void",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "void",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "void",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "void",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "void",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "void",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "void",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "void",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "void",
      "onFillStart?(event: FillStartEvent<TData>)": "void",
      "onFillEnd?(event: FillEndEvent<TData>)": "void",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "void",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "void",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "void",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "void",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "void",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "void",
      "onGridReady?(event: GridReadyEvent<TData>)": "void",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "void",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "void",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "void",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "void",
      "onDragStarted?(event: DragStartedEvent<TData>)": "void",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "void",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "void",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "void",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "void",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "void",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "void",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "void",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "void",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "void",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "void",
      "onCellClicked?(event: CellClickedEvent<TData>)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "void",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "void",
      "onRowClicked?(event: RowClickedEvent<TData>)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "void",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "void",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "void",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "void",
      "onSortChanged?(event: SortChangedEvent<TData>)": "void",
      "api?": "never"
    },
    "docs": {
      "modules?": "/** Used to register AG Grid Modules directly with this instance of the grid.\n     * See [Providing Modules To Individual Grids](https://www.ag-grid.com/react-data-grid/modules/#providing-modules-to-individual-grids) for more information.\n     */",
      "statusBar?": "/** Specifies the status bar components to use in the status bar.\n     */",
      "sideBar?": "/** Specifies the side bar components.\n     */",
      "suppressContextMenu?": "/** Set to `true` to not show the context menu. Use if you don't want to use the default 'right click' context menu.\n     * @default false\n     */",
      "preventDefaultOnContextMenu?": "/** When using `suppressContextMenu`, you can use the `onCellContextMenu` function to provide your own code to handle cell `contextmenu` events.\n     * This flag is useful to prevent the browser from showing its default context menu.\n     * @default false\n     */",
      "allowContextMenuWithControlKey?": "/** Allows context menu to show, even when `Ctrl` key is held down.\n     * @default false\n     */",
      "columnMenu?": "/** Changes the display type of the column menu.\n     * `'new'` just displays the main list of menu items. `'legacy'` displays a tabbed menu.\n     * @default 'new'\n     * @initial\n     */",
      "suppressMenuHide?": "/** When `true`, the column menu button will always be shown.\n     * When `false, the column menu button will only show when the mouse is over the column header.\n     * If `columnMenu = 'legacy'`, this will default to `false` instead of `true`.\n     * @default true\n     */",
      "enableBrowserTooltips?": "/** Set to `true` to use the browser's default tooltip instead of using the grid's Tooltip Component.\n     * @default false\n     * @initial\n     */",
      "tooltipTrigger?": "/** The trigger that will cause tooltips to show and hide.\n     *  - `hover` - The tooltip will show/hide when a cell/header is hovered.\n     *  - `focus` - The tooltip will show/hide when a cell/header is focused.\n     * @default 'hover'\n     * @initial\n     */",
      "tooltipShowDelay?": "/** The delay in milliseconds that it takes for tooltips to show up once an element is hovered over.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true`.\n     * @default 2000\n     */",
      "tooltipHideDelay?": "/** The delay in milliseconds that it takes for tooltips to hide once they have been displayed.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true` and `tooltipHideTriggers` includes `timeout`.\n     * @default 10000\n     */",
      "tooltipMouseTrack?": "/** Set to `true` to have tooltips follow the cursor once they are displayed.\n     * @default false\n     * @initial\n     */",
      "tooltipShowMode?": "/** This defines when tooltip will show up for Cells, Headers and SetFilter Items.\n     *  - `standard` - The tooltip always shows up when the items configured with Tooltips are hovered.\n     * - `whenTruncated` - The tooltip will only be displayed when the items hovered have truncated (showing ellipsis) values. This property does not work when `enableBrowserTooltips={true}`.\n     * @default `standard`\n     */",
      "tooltipInteraction?": "/** Set to `true` to enable tooltip interaction. When this option is enabled, the tooltip will not hide while the\n     * tooltip itself it being hovered or has focus.\n     * @default false\n     * @initial\n     */",
      "popupParent?": "/** DOM element to use as the popup parent for grid popups (context menu, column menu etc).\n     */",
      "copyHeadersToClipboard?": "/** Set to `true` to also include headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "copyGroupHeadersToClipboard?": "/** Set to `true` to also include group headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "clipboardDelimiter?": "/** Specify the delimiter to use when copying to clipboard.\n     * @default '\\t'\n     */",
      "suppressCopyRowsToClipboard?": "/** Set to `true` to copy the cell range or focused cell to the clipboard and never the selected rows.\n     * @default false\n     */",
      "suppressCopySingleCellRanges?": "/** Set to `true` to copy rows instead of ranges when a range with only a single cell is selected.\n     * @default false\n     */",
      "suppressLastEmptyLineOnPaste?": "/** Set to `true` to work around a bug with Excel (Windows) that adds an extra empty line at the end of ranges copied to the clipboard.\n     * @default false\n     */",
      "suppressClipboardPaste?": "/** Set to `true` to turn off paste operations within the grid.\n     * @default false\n     */",
      "suppressClipboardApi?": "/** Set to `true` to stop the grid trying to use the Clipboard API, if it is blocked, and immediately fallback to the workaround.\n     * @default false\n     */",
      "suppressCutToClipboard?": "/** Set to `true` to block **cut** operations within the grid.\n     * @default false\n     */",
      "columnDefs?": "/** Array of Column / Column Group definitions.\n     */",
      "defaultColDef?": "/** A default column definition. Items defined in the actual column definitions get precedence.\n     */",
      "defaultColGroupDef?": "/** A default column group definition. All column group definitions will use these properties. Items defined in the actual column group definition get precedence.\n     * @initial\n     */",
      "columnTypes?": "/** An object map of custom column types which contain groups of properties that column definitions can reuse by referencing in their `type` property.\n     */",
      "dataTypeDefinitions?": "/** An object map of cell data types to their definitions.\n     * Cell data types can either override/update the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`),\n     * or can be custom data types.\n     */",
      "maintainColumnOrder?": "/** Keeps the order of Columns maintained after new Column Definitions are updated.\n     * @default false\n     */",
      "suppressFieldDotNotation?": "/** If `true`, then dots in field names (e.g. `'address.firstLine'`) are not treated as deep references. Allows you to use dots in your field name if you prefer.\n     * @default false\n     */",
      "headerHeight?": "/** The height in pixels for the row containing the column label header. If not specified, it uses the theme value of `header-height`.\n     */",
      "groupHeaderHeight?": "/** The height in pixels for the rows containing header column groups. If not specified, it uses `headerHeight`.\n     */",
      "floatingFiltersHeight?": "/** The height in pixels for the row containing the floating filters. If not specified, it uses the theme value of `header-height`.\n     */",
      "pivotHeaderHeight?": "/** The height in pixels for the row containing the columns when in pivot mode. If not specified, it uses `headerHeight`.\n     */",
      "pivotGroupHeaderHeight?": "/** The height in pixels for the row containing header column groups when in pivot mode. If not specified, it uses `groupHeaderHeight`.\n     */",
      "allowDragFromColumnsToolPanel?": "/** Allow reordering and pinning columns by dragging columns from the Columns Tool Panel to the grid.\n     * @default false\n     */",
      "suppressMovableColumns?": "/** Set to `true` to suppress column moving, i.e. to make the columns fixed position.\n     * @default false\n     */",
      "suppressColumnMoveAnimation?": "/** If `true`, the `ag-column-moving` class is not added to the grid while columns are moving. In the default themes, this results in no animation when moving columns.\n     * @default false\n     */",
      "suppressDragLeaveHidesColumns?": "/** If `true`, when you drag a column out of the grid (e.g. to the group zone) the column is not hidden.\n     * @default false\n     */",
      "suppressRowGroupHidesColumns?": "/** If `true`, when you drag a column into a row group panel the column is not hidden.\n     * @default false\n     */",
      "colResizeDefault?": "/** Set to `'shift'` to have shift-resize as the default resize operation (same as user holding down `Shift` while resizing).\n     */",
      "suppressAutoSize?": "/** Suppresses auto-sizing columns for columns. In other words, double clicking a column's header's edge will not auto-size.\n     * @default false\n     * @initial\n     */",
      "autoSizePadding?": "/** Number of pixels to add to a column width after the [auto-sizing](./column-sizing/#auto-size-columns-to-fit-cell-contents) calculation.\n     * Set this if you want to add extra room to accommodate (for example) sort icons, or some other dynamic nature of the header.\n     * @default 20\n     */",
      "skipHeaderOnAutoSize?": "/** Set this to `true` to skip the `headerName` when `autoSize` is called by default.\n     * @default false\n     * @initial\n     */",
      "autoSizeStrategy?": "/** Auto-size the columns when the grid is loaded. Can size to fit the grid width, fit a provided width, or fit the cell contents.\n     * @initial\n     */",
      "components?": "/** A map of component names to components.\n     * @initial\n     */",
      "editType?": "/** Set to `'fullRow'` to enable Full Row Editing. Otherwise leave blank to edit one cell at a time.\n     */",
      "singleClickEdit?": "/** Set to `true` to enable Single Click Editing for cells, to start editing with a single click.\n     * @default false\n     */",
      "suppressClickEdit?": "/** Set to `true` so that neither single nor double click starts editing.\n     * @default false\n     */",
      "readOnlyEdit?": "/** Set to `true` to stop the grid updating data after `Edit`, `Clipboard` and `Fill Handle` operations. When this is set, it is intended the application will update the data, eg in an external immutable store, and then pass the new dataset to the grid. <br />**Note:** `rowNode.setDataValue()` does not update the value of the cell when this is `True`, it fires `onCellEditRequest` instead.\n     * @default false\n     */",
      "stopEditingWhenCellsLoseFocus?": "/** Set this to `true` to stop cell editing when grid loses focus.\n     * The default is that the grid stays editing until focus goes onto another cell.\n     * @default false\n     * @initial\n     */",
      "enterNavigatesVertically?": "/** Set to `true` along with `enterNavigatesVerticallyAfterEdit` to have Excel-style behaviour for the `Enter` key.\n     * i.e. pressing the `Enter` key will move down to the cell beneath and `Shift+Enter` will move up to the cell above.\n     * @default false\n     */",
      "enterNavigatesVerticallyAfterEdit?": "/** Set to `true` along with `enterNavigatesVertically` to have Excel-style behaviour for the 'Enter' key.\n     * i.e. pressing the Enter key will move down to the cell beneath and Shift+Enter key will move up to the cell above.\n     * @default false\n     */",
      "enableCellEditingOnBackspace?": "/** Forces Cell Editing to start when backspace is pressed. This is only relevant for MacOS users.\n     */",
      "undoRedoCellEditing?": "/** Set to `true` to enable Undo / Redo while editing.\n     * @initial\n     */",
      "undoRedoCellEditingLimit?": "/** Set the size of the undo / redo stack.\n     * @default 10\n     * @initial\n     */",
      "defaultCsvExportParams?": "/** A default configuration object used to export to CSV.\n     */",
      "suppressCsvExport?": "/** Prevents the user from exporting the grid to CSV.\n     * @default false\n     */",
      "defaultExcelExportParams?": "/** A default configuration object used to export to Excel.\n     */",
      "suppressExcelExport?": "/** Prevents the user from exporting the grid to Excel.\n     * @default false\n     */",
      "excelStyles?": "/** A list (array) of Excel styles to be used when exporting to Excel with styles.\n     * @initial\n     */",
      "quickFilterText?": "/** Rows are filtered using this text as a Quick Filter.\n     */",
      "cacheQuickFilter?": "/** Set to `true` to turn on the Quick Filter cache, used to improve performance when using the Quick Filter.\n     * @default false\n     * @initial\n     */",
      "includeHiddenColumnsInQuickFilter?": "/** Hidden columns are excluded from the Quick Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "quickFilterParser?": "/** Changes how the Quick Filter splits the Quick Filter text into search terms.\n     */",
      "quickFilterMatcher?": "/** Changes the matching logic for whether a row passes the Quick Filter.\n     */",
      "applyQuickFilterBeforePivotOrAgg?": "/** When pivoting, Quick Filter is only applied on the pivoted data\n     * (or aggregated data if `groupAggFiltering = true`).\n     * Set to `true` to apply Quick Filter before pivoting (/aggregating) instead.\n     * @default false\n     */",
      "excludeChildrenWhenTreeDataFiltering?": "/** Set to `true` to override the default tree data filtering behaviour to instead exclude child nodes from filter results.\n     * @default false\n     */",
      "enableAdvancedFilter?": "/** Set to true to enable the Advanced Filter.\n     * @default false\n     */",
      "advancedFilterModel?": "/** @deprecated As of v31, use `initialState.filter.advancedFilterModel` instead.\n     * @initial\n     */",
      "includeHiddenColumnsInAdvancedFilter?": "/** Hidden columns are excluded from the Advanced Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "advancedFilterParent?": "/** DOM element to use as the parent for the Advanced Filter to allow it to appear outside of the grid.\n     * Set to `null` or `undefined` to appear inside the grid.\n     */",
      "advancedFilterBuilderParams?": "/** Customise the parameters passed to the Advanced Filter Builder.\n     */",
      "suppressAdvancedFilterEval?": "/** By default, Advanced Filter sanitises user input and passes it to `new Function()` to provide the best performance.\n     * Set to `true` to prevent this and use defined functions instead.\n     * This will result in slower filtering, but it enables Advanced Filter to work when `unsafe-eval` is disabled.\n     * @default false\n     */",
      "enableCharts?": "/** Set to `true` to Enable Charts.\n     * @default false\n     */",
      "chartThemes?": "/** The list of chart themes that a user can choose from in the chart panel.\n     * @default ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];\n     * @initial\n     */",
      "customChartThemes?": "/** A map containing custom chart themes.\n     * @initial\n     */",
      "chartThemeOverrides?": "/** Chart theme overrides applied to all themes.\n     * @initial\n     */",
      "chartToolPanelsDef?": "/** Allows customisation of the Chart Tool Panels, such as changing the tool panels visibility and order, as well as choosing which charts should be displayed in the chart panel.\n     * @initial\n     */",
      "chartMenuItems?": "/** Get chart menu items. Only applies when using AG Charts Enterprise.\n     */",
      "loadingCellRenderer?": "/** Provide your own loading cell renderer to use when data is loading via a DataSource.\n     * See [Loading Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-loading-cell-renderer/) for framework specific implementation details.\n     */",
      "loadingCellRendererParams?": "/** Params to be passed to the `loadingCellRenderer` component.\n     */",
      "loadingCellRendererSelector?": "/** Callback to select which loading cell renderer to be used when data is loading via a DataSource.\n     * @initial\n     */",
      "localeText?": "/** A map of key->value pairs for localising text within the grid.\n     * @initial\n     */",
      "masterDetail?": "/** Set to `true` to enable Master Detail.\n     * @default false\n     */",
      "keepDetailRows?": "/** Set to `true` to keep detail rows for when they are displayed again.\n     * @default false\n     * @initial\n     */",
      "keepDetailRowsCount?": "/** Sets the number of details rows to keep.\n     * @default 10\n     * @initial\n     */",
      "detailCellRenderer?": "/** Provide a custom `detailCellRenderer` to use when a master row is expanded.\n     * See [Detail Cell Renderer](https://www.ag-grid.com/javascript-data-grid/master-detail-custom-detail/) for framework specific implementation details.\n     */",
      "detailCellRendererParams?": "/** Specifies the params to be used by the Detail Cell Renderer. Can also be a function that provides the params to enable dynamic definitions of the params.\n     */",
      "detailRowHeight?": "/** Set fixed height in pixels for each detail row.\n     * @initial\n     */",
      "detailRowAutoHeight?": "/** Set to `true` to have the detail grid dynamically change it's height to fit it's rows.\n     * @initial\n     */",
      "context?": "/** Provides a context object that is provided to different callbacks the grid uses. Used for passing additional information to the callbacks by your application.\n     * @initial\n     */",
      "alignedGrids?": "/**\n     * A list of grids to treat as Aligned Grids.\n     * Provide a list if the grids / apis already exist or return via a callback to allow the aligned grids to be retrieved asynchronously.\n     * If grids are aligned then the columns and horizontal scrolling will be kept in sync.\n     */",
      "tabIndex?": "/** Change this value to set the tabIndex order of the Grid within your application.\n     * @default 0\n     * @initial\n     */",
      "rowBuffer?": "/** The number of rows rendered outside the viewable area the grid renders.\n     * Having a buffer means the grid will have rows ready to show as the user slowly scrolls vertically.\n     * @default 10\n     */",
      "valueCache?": "/** Set to `true` to turn on the value cache.\n     * @default false\n     * @initial\n     */",
      "valueCacheNeverExpires?": "/** Set to `true` to configure the value cache to not expire after data updates.\n     * @default false\n     * @initial\n     */",
      "enableCellExpressions?": "/** Set to `true` to allow cell expressions.\n     * @default false\n     * @initial\n     */",
      "suppressTouch?": "/** Disables touch support (but does not remove the browser's efforts to simulate mouse events on touch).\n     * @default false\n     * @initial\n     */",
      "suppressFocusAfterRefresh?": "/** Set to `true` to not set focus back on the grid after a refresh. This can avoid issues where you want to keep the focus on another part of the browser.\n     * @default false\n     */",
      "suppressAsyncEvents?": "/** Disables the asynchronous nature of the events introduced in v10, and makes them synchronous. This property only exists for the purpose of supporting legacy code which has a dependency on synchronous events from earlier versions (v9 or earlier) of AG Grid. **It is strongly recommended that you do not change this property unless you have legacy issues.**\n     * @deprecated v31 Events should be handled asynchronously.\n     * @default false\n     * @initial\n     */",
      "suppressBrowserResizeObserver?": "/** The grid will check for `ResizeObserver` and use it if it exists in the browser, otherwise it will use the grid's alternative implementation. Some users reported issues with Chrome's `ResizeObserver`. Use this property to always use the grid's alternative implementation should such problems exist.\n     * @default false\n     * @initial\n     */",
      "suppressPropertyNamesCheck?": "/** Disables showing a warning message in the console if using a `gridOptions` or `colDef` property that doesn't exist.\n     * @default false\n     * @initial\n     */",
      "suppressChangeDetection?": "/** Disables change detection.\n     * @default false\n     */",
      "debug?": "/** Set this to `true` to enable debug information from the grid and related components. Will result in additional logging being output, but very useful when investigating problems.\n     * @default false\n     * @initial\n     */",
      "loading?": "/** Show or hide the loading overlay.\n     */",
      "overlayLoadingTemplate?": "/** Provide a HTML string to override the default loading overlay.\n     */",
      "loadingOverlayComponent?": "/** Provide a custom loading overlay component.\n     * @initial\n     */",
      "loadingOverlayComponentParams?": "/** Customise the parameters provided to the loading overlay component.\n     */",
      "suppressLoadingOverlay?": "/** Disables the 'loading' overlay.\n     * @deprecated v32 - Deprecated. Use `loading=false` instead.\n     * @default false\n     * @initial\n     */",
      "overlayNoRowsTemplate?": "/** Provide a HTML string to override the default no-rows overlay.\n     */",
      "noRowsOverlayComponent?": "/** Provide a custom no-rows overlay component.\n     * @initial\n     */",
      "noRowsOverlayComponentParams?": "/** Customise the parameters provided to the no-rows overlay component.\n     */",
      "suppressNoRowsOverlay?": "/** Set to `true` to prevent the no-rows overlay being shown when there is no row data.\n     * @default false\n     * @initial\n     */",
      "pagination?": "/** Set whether pagination is enabled.\n     * @default false\n     */",
      "paginationPageSize?": "/** How many rows to load per page. If `paginationAutoPageSize` is specified, this property is ignored.\n     * @default 100\n     */",
      "paginationPageSizeSelector?": "/** Determines if the page size selector is shown in the pagination panel or not.\n     * Set to an array of values to show the page size selector with custom list of possible page sizes.\n     * Set to `true` to show the page size selector with the default page sizes `[20, 50, 100]`.\n     * Set to `false` to hide the page size selector.\n     * @default true\n     * @initial\n     */",
      "paginationAutoPageSize?": "/** Set to `true` so that the number of rows to load per page is automatically adjusted by the grid so each page shows enough rows to just fill the area designated for the grid. If `false`, `paginationPageSize` is used.\n     * @default false\n     */",
      "paginateChildRows?": "/** Set to `true` to have pages split children of groups when using Row Grouping or detail rows with Master Detail.\n     * @default false\n     * @initial\n     */",
      "suppressPaginationPanel?": "/** If `true`, the default grid controls for navigation are hidden.\n     * This is useful if `pagination=true` and you want to provide your own pagination controls.\n     * Otherwise, when `pagination=true` the grid automatically shows the necessary controls at the bottom so that the user can navigate through the different pages.\n     * @default false\n     */",
      "pivotMode?": "/** Set to `true` to enable pivot mode.\n     * @default false\n     */",
      "pivotPanelShow?": "/** When to show the 'pivot panel' (where you drag rows to pivot) at the top. Note that the pivot panel will never show if `pivotMode` is off.\n     * @default 'never'\n     * @initial\n     */",
      "pivotMaxGeneratedColumns?": "/** The maximum number of generated columns before the grid halts execution. Upon reaching this number, the grid halts generation of columns\n     * and triggers a `pivotMaxColumnsExceeded` event. `-1` for no limit.\n     * @default -1\n     */",
      "pivotDefaultExpanded?": "/** If pivoting, set to the number of column group levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "pivotColumnGroupTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear within the Pivot Column Groups, in the position specified.\n     */",
      "pivotRowTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear for each value column in the position specified.\n     */",
      "pivotSuppressAutoColumn?": "/** If `true`, the grid will not swap in the grouping column when pivoting. Useful if pivoting using Server Side Row Model or Viewport Row Model and you want full control of all columns including the group column.\n     * @default false\n     * @initial\n     */",
      "suppressExpandablePivotGroups?": "/** When enabled, pivot column groups will appear 'fixed', without the ability to expand and collapse the column groups.\n     * @default false\n     * @initial\n     */",
      "functionsReadOnly?": "/** If `true`, then row group, pivot and value aggregation will be read-only from the GUI. The grid will display what values are used for each, but will not allow the user to change the selection.\n     * @default false\n     */",
      "aggFuncs?": "/** A map of 'function name' to 'function' for custom aggregation functions.\n     * @initial\n     */",
      "suppressAggFuncInHeader?": "/** When `true`, column headers won't include the `aggFunc` name, e.g. `'sum(Bank Balance)`' will just be `'Bank Balance'`.\n     * @default false\n     * @initial\n     */",
      "alwaysAggregateAtRootLevel?": "/** When using aggregations, the grid will always calculate the root level aggregation value.\n     * @default false\n     */",
      "aggregateOnlyChangedColumns?": "/** When using change detection, only the updated column will be re-aggregated.\n     * @default false\n     */",
      "suppressAggFilteredOnly?": "/** Set to `true` so that aggregations are not impacted by filtering.\n     * @default false\n     */",
      "removePivotHeaderRowWhenSingleValueColumn?": "/** Set to `true` to omit the value Column header when there is only a single value column.\n     * @default false\n     * @initial\n     */",
      "animateRows?": "/** Set to `false` to disable Row Animation which is enabled by default.\n     * @default true\n     */",
      "enableCellChangeFlash?": "/** Set to `true` to have cells flash after data changes.\n     * @default false\n     * @deprecated 31.2 use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns.\n     */",
      "cellFlashDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long a cell should remain in its \"flashed\" state.\n     * @default 500\n     */",
      "cellFlashDelay?": "/** @deprecated v31.1 - use `cellFlashDuration` instead.\n     */",
      "cellFadeDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long the \"flashed\" state animation takes to fade away after the timer set by cellFlashDuration has completed.\n     * @default 1000\n     */",
      "cellFadeDelay?": "/** @deprecated v31.1 - use `cellFadeDuration` instead.\n     */",
      "allowShowChangeAfterFilter?": "/** Set to `true` to have cells flash after data changes even when the change is due to filtering.\n     * @default false\n     * @initial\n     */",
      "domLayout?": "/** Switch between layout options: `normal`, `autoHeight`, `print`.\n     * @default 'normal'\n     */",
      "ensureDomOrder?": "/** When `true`, the order of rows and columns in the DOM are consistent with what is on screen.\n     * Disables row animations.\n     * @default false\n     * @initial\n     */",
      "enableRtl?": "/** Set to `true` to operate the grid in RTL (Right to Left) mode.\n     * @default false\n     * @initial\n     */",
      "suppressColumnVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the columns. For example, if you have 100 columns, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "suppressMaxRenderedRowRestriction?": "/** By default the grid has a limit of rendering a maximum of 500 rows at once (remember the grid only renders rows you can see, so unless your display shows more than 500 rows without vertically scrolling this will never be an issue).\n     * <br />**This is only relevant if you are manually setting `rowBuffer` to a high value (rendering more rows than can be seen), or `suppressRowVirtualisation` is true, or if your grid height is able to display more than 500 rows at once.**\n     * @default false\n     * @initial\n     */",
      "suppressRowVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the rows. For example, if you have 100 rows, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "rowDragManaged?": "/** Set to `true` to enable Managed Row Dragging.\n     * @default false\n     */",
      "suppressRowDrag?": "/** Set to `true` to suppress row dragging.\n     * @default false\n     */",
      "suppressMoveWhenRowDragging?": "/** Set to `true` to suppress moving rows while dragging the `rowDrag` waffle. This option highlights the position where the row will be placed and it will only move the row on mouse up.\n     * @default false\n     */",
      "rowDragEntireRow?": "/** Set to `true` to enable clicking and dragging anywhere on the row without the need for a drag handle.\n     * @default false\n     */",
      "rowDragMultiRow?": "/** Set to `true` to enable dragging multiple rows at the same time.\n     * @default false\n     */",
      "rowDragText?": "/** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.\n     * If this callback is not set, the current cell value will be used.\n     * If the `rowDragText` callback is set in the ColDef it will take precedence over this, except when\n     * `rowDragEntireRow=true`.\n     * @initial\n     */",
      "fullWidthCellRenderer?": "/** Provide your own cell renderer component to use for full width rows.\n     * See [Full Width Rows](https://www.ag-grid.com/javascript-data-grid/full-width-rows/) for framework specific implementation details.\n     */",
      "fullWidthCellRendererParams?": "/** Customise the parameters provided to the `fullWidthCellRenderer` component.\n     */",
      "embedFullWidthRows?": "/** Set to `true` to have the Full Width Rows embedded in grid's main container so they can be scrolled horizontally.\n     */",
      "suppressGroupMaintainValueType?": "/** @deprecated v31\n     * When enabled, the grid will cast group values to string type.\n     * @default false\n     * @initial\n     */",
      "groupDisplayType?": "/** Specifies how the results of row grouping should be displayed.\n     *\n     *  The options are:\n     *\n     * - `'singleColumn'`: single group column automatically added by the grid.\n     * - `'multipleColumns'`: a group column per row group is added automatically.\n     * - `'groupRows'`: group rows are automatically added instead of group columns.\n     * - `'custom'`: informs the grid that group columns will be provided.\n     */",
      "groupDefaultExpanded?": "/** If grouping, set to the number of levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "autoGroupColumnDef?": "/** Allows specifying the group 'auto column' if you are not happy with the default. If grouping, this column definition is included as the first column in the grid. If not grouping, this column is not included.\n     */",
      "groupMaintainOrder?": "/** When `true`, preserves the current group order when sorting on non-group columns.\n     * @default false\n     */",
      "groupSelectsChildren?": "/** When `true`, if you select a group, the children of the group will also be selected.\n     * @default false\n     */",
      "groupLockGroupColumns?": "/** If grouping, locks the group settings of a number of columns, e.g. `0` for no group locking. `1` for first group column locked, `-1` for all group columns locked.\n     * @default 0\n     * @initial\n     */",
      "groupAggFiltering?": "/** Set to determine whether filters should be applied on aggregated group values.\n     * @default false\n     */",
      "groupIncludeFooter?": "/** If grouping, this controls whether to show a group footer when the group is expanded.\n     * If `true`, then by default, the footer will contain aggregate data (if any) when shown and the header will be blank.\n     * When closed, the header will contain the aggregate data regardless of this setting (as the footer is hidden anyway).\n     * This is handy for 'total' rows, that are displayed below the data when the group is open, and alongside the group when it is closed.\n     * If a callback function is provided, it can used to select which groups will have a footer added.\n     * @default false\n     *\n     * @deprecated v31.3 - use `groupTotalRow` instead.\n     */",
      "groupIncludeTotalFooter?": "/** Set to `true` to show a 'grand total' group footer across all groups.\n     * @default false\n     *\n     * @deprecated v31.3 - use `grandTotalRow` instead.\n     */",
      "groupTotalRow?": "/** When provided, an extra row group total row will be inserted into row groups at the specified position, to display\n     * when the group is expanded. This row will contain the aggregate values for the group. If a callback function is\n     * provided, it can be used to selectively determine which groups will have a total row added.\n     */",
      "grandTotalRow?": "/** When provided, an extra grand total row will be inserted into the grid at the specified position.\n     * This row displays the aggregate totals of all rows in the grid.\n     */",
      "suppressStickyTotalRow?": "/** Suppress the sticky behaviour of the total rows, can be suppressed individually by passing `'grand'` or `'group'`.\n     */",
      "groupSuppressBlankHeader?": "/** If `true`, and showing footer, aggregate data will always be displayed at both the header and footer levels. This stops the possibly undesirable behaviour of the header details 'jumping' to the footer on expand.\n     * @default false\n     */",
      "groupSelectsFiltered?": "/** If using `groupSelectsChildren`, then only the children that pass the current filter will get selected.\n     * @default false\n     */",
      "showOpenedGroup?": "/** Shows the open group in the group column for non-group rows.\n     * @default false\n     */",
      "groupRemoveSingleChildren?": "/** Set to `true` to collapse groups that only have one child.\n     * @default false\n     */",
      "groupRemoveLowestSingleChildren?": "/** Set to `true` to collapse lowest level groups that only have one child.\n     * @default false\n     */",
      "groupHideOpenParents?": "/** Set to `true` to hide parents that are open. When used with multiple columns for showing groups, it can give a more pleasing user experience.\n     * @default false\n     */",
      "groupAllowUnbalanced?": "/** Set to `true` to prevent the grid from creating a '(Blanks)' group for nodes which do not belong to a group, and display the unbalanced nodes alongside group nodes.\n     * @default false\n     */",
      "rowGroupPanelShow?": "/** When to show the 'row group panel' (where you drag rows to group) at the top.\n     * @default 'never'\n     */",
      "groupRowRenderer?": "/** Provide the Cell Renderer to use when `groupDisplayType = 'groupRows'`.\n     * See [Group Row Cell Renderer](https://www.ag-grid.com/javascript-data-grid/grouping-group-rows/#providing-cell-renderer) for framework specific implementation details.\n     */",
      "groupRowRendererParams?": "/** Customise the parameters provided to the `groupRowRenderer` component.\n     */",
      "suppressMakeColumnVisibleAfterUnGroup?": "/** By default, when a column is un-grouped, i.e. using the Row Group Panel, it is made visible in the grid. This property stops the column becoming visible again when un-grouping.\n     * @default false\n     */",
      "treeData?": "/** Set to `true` to enable the Grid to work with Tree Data. You must also implement the `getDataPath(data)` callback.\n     * @default false\n     */",
      "rowGroupPanelSuppressSort?": "/** Set to `true` to suppress sort indicators and actions from the row group panel.\n     * @default false\n     * @initial\n     */",
      "suppressGroupRowsSticky?": "/** Set to `true` prevent Group Rows from sticking to the top of the grid.\n     * @default false\n     * @initial\n     */",
      "pinnedTopRowData?": "/** Data to be displayed as pinned top rows in the grid.\n     */",
      "pinnedBottomRowData?": "/** Data to be displayed as pinned bottom rows in the grid.\n     */",
      "rowModelType?": "/** Sets the row model type.\n     * @default 'clientSide'\n     * @initial\n     */",
      "rowData?": "/** Set the data to be displayed as rows in the grid.\n     */",
      "asyncTransactionWaitMillis?": "/** How many milliseconds to wait before executing a batch of async transactions.\n     */",
      "suppressModelUpdateAfterUpdateTransaction?": "/** Prevents Transactions changing sort, filter, group or pivot state when transaction only contains updates.\n     * @default false\n     */",
      "datasource?": "/** Provide the datasource for infinite scrolling.\n     */",
      "cacheOverflowSize?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "infiniteInitialRowCount?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "serverSideInitialRowCount?": "/** Set how many loading rows to display to the user for the root level group.\n     * @default 1\n     * @initial\n     */",
      "suppressServerSideInfiniteScroll?": "/** When `true`, the Server-side Row Model will suppress Infinite Scrolling and load all the data at the current level.\n     * @default false\n     * @initial\n     * @deprecated v31.1\n     */",
      "suppressServerSideFullWidthLoadingRow?": "/** When `true`, the Server-side Row Model will not use a full width loading renderer, instead using the colDef `loadingCellRenderer` if present.\n     */",
      "cacheBlockSize?": "/** How many rows for each block in the store, i.e. how many rows returned from the server at a time.\n     * @default 100\n     */",
      "maxBlocksInCache?": "/** How many blocks to keep in the store. Default is no limit, so every requested block is kept. Use this if you have memory concerns, and blocks that were least recently viewed will be purged when the limit is hit. The grid will additionally make sure it has all the blocks needed to display what is currently visible, in case this property is set to a low value.\n     * @initial\n     */",
      "maxConcurrentDatasourceRequests?": "/** How many requests to hit the server with concurrently. If the max is reached, requests are queued.\n     * Set to `-1` for no maximum restriction on requests.\n     * @default 2\n     * @initial\n     */",
      "blockLoadDebounceMillis?": "/** How many milliseconds to wait before loading a block. Useful when scrolling over many blocks, as it prevents blocks loading until scrolling has settled.\n     * @initial\n     */",
      "purgeClosedRowNodes?": "/** When enabled, closing group rows will remove children of that row. Next time the row is opened, child rows will be read from the datasource again. This property only applies when there is Row Grouping or Tree Data.\n     * @default false\n     */",
      "serverSideDatasource?": "/** Provide the `serverSideDatasource` for server side row model.\n     */",
      "serverSideSortAllLevels?": "/** When enabled, always refreshes top level groups regardless of which column was sorted. This property only applies when there is Row Grouping & sorting is handled on the server.\n     * @default false\n     */",
      "serverSideEnableClientSideSort?": "/** When enabled, sorts fully loaded groups in the browser instead of requesting from the server.\n     * @default false\n     */",
      "serverSideOnlyRefreshFilteredGroups?": "/** When enabled, only refresh groups directly impacted by a filter. This property only applies when there is Row Grouping & filtering is handled on the server.\n     * @default false\n     * @initial\n     */",
      "serverSideSortOnServer?": "/** When enabled, Sorting will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSideFilterOnServer?": "/** When enabled, Filtering will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSidePivotResultFieldSeparator?": "/** Used to split pivot field strings for generating pivot result columns when `pivotResultFields` is provided as part of a `getRows` success.\n     * @default '_'\n     * @initial\n     */",
      "viewportDatasource?": "/** To use the viewport row model you need to provide the grid with a `viewportDatasource`.\n     */",
      "viewportRowModelPageSize?": "/** When using viewport row model, sets the page size for the viewport.\n     * @initial\n     */",
      "viewportRowModelBufferSize?": "/** When using viewport row model, sets the buffer size for the viewport.\n     * @initial\n     */",
      "alwaysShowHorizontalScroll?": "/** Set to `true` to always show the horizontal scrollbar.\n     * @default false\n     */",
      "alwaysShowVerticalScroll?": "/** Set to `true` to always show the vertical scrollbar.\n     * @default false\n     */",
      "debounceVerticalScrollbar?": "/** Set to `true` to debounce the vertical scrollbar. Can provide smoother scrolling on slow machines.\n     * @default false\n     * @initial\n     */",
      "suppressHorizontalScroll?": "/** Set to `true` to never show the horizontal scroll. This is useful if the grid is aligned with another grid and will scroll when the other grid scrolls. (Should not be used in combination with `alwaysShowHorizontalScroll`.)\n     * @default false\n     */",
      "suppressScrollOnNewData?": "/** When `true`, the grid will not scroll to the top when new row data is provided. Use this if you don't want the default behaviour of scrolling to the top every time you load new data.\n     * @default false\n     */",
      "suppressScrollWhenPopupsAreOpen?": "/** When `true`, the grid will not allow mousewheel / touchpad scroll when popup elements are present.\n     * @default false\n     */",
      "suppressAnimationFrame?": "/** When `true`, the grid will not use animation frames when drawing rows while scrolling. Use this if the grid is working fast enough that you don't need animation frames and you don't want the grid to flicker.\n     * @default false\n     * @initial\n     */",
      "suppressMiddleClickScrolls?": "/** If `true`, middle clicks will result in `click` events for cells and rows. Otherwise the browser will use middle click to scroll the grid.<br />**Note:** Not all browsers fire `click` events with the middle button. Most will fire only `mousedown` and `mouseup` events, which can be used to focus a cell, but will not work to call the `onCellClicked` function.\n     * @default false\n     */",
      "suppressPreventDefaultOnMouseWheel?": "/** If `true`, mouse wheel events will be passed to the browser. Useful if your grid has no vertical scrolls and you want the mouse to scroll the browser page.\n     * @default false\n     * @initial\n     */",
      "scrollbarWidth?": "/** Tell the grid how wide in pixels the scrollbar is, which is used in grid width calculations. Set only if using non-standard browser-provided scrollbars, so the grid can use the non-standard size in its calculations.\n     * @initial\n     */",
      "rowSelection?": "/** Type of Row Selection: `single`, `multiple`.\n     */",
      "rowMultiSelectWithClick?": "/** Set to `true` to allow multiple rows to be selected using single click.\n     * @default false\n     */",
      "suppressRowDeselection?": "/** If `true`, rows will not be deselected if you hold down `Ctrl` and click the row or press `Space`.\n     * @default false\n     */",
      "suppressRowClickSelection?": "/** If `true`, row selection won't happen when rows are clicked. Use when you only want checkbox selection.\n     * @default false\n     */",
      "suppressCellFocus?": "/** If `true`, cells won't be focusable. This means keyboard navigation will be disabled for grid cells, but remain enabled in other elements of the grid such as column headers, floating filters, tool panels.\n     * @default false\n     */",
      "suppressHeaderFocus?": "/** If `true`, header cells won't be focusable. This means keyboard navigation will be disabled for grid header cells, but remain enabled in other elements of the grid such as grid cells and tool panels.\n     * @default false\n     */",
      "suppressMultiRangeSelection?": "/** If `true`, only a single range can be selected.\n     * @default false\n     */",
      "enableCellTextSelection?": "/** Set to `true` to be able to select the text within cells.\n     *\n     * **Note:** When this is set to `true`, the clipboard service is disabled and only selected text is copied.\n     * @default false\n     */",
      "enableRangeSelection?": "/** Set to `true` to enable Range Selection.\n     * @default false\n     */",
      "enableRangeHandle?": "/** Set to `true` to enable the Range Handle.\n     * @default false\n     */",
      "enableFillHandle?": "/** Set to `true` to enable the Fill Handle.\n     * @default false\n     */",
      "fillHandleDirection?": "/** Set to `'x'` to force the fill handle direction to horizontal, or set to `'y'` to force the fill handle direction to vertical.\n     * @default 'xy'\n     */",
      "suppressClearOnFillReduction?": "/** Set this to `true` to prevent cell values from being cleared when the Range Selection is reduced by the Fill Handle.\n     * @default false\n     */",
      "sortingOrder?": "/** Array defining the order in which sorting occurs (if sorting is enabled). Values can be `'asc'`, `'desc'` or `null`. For example: `sortingOrder: ['asc', 'desc']`.\n     * @default [null, 'asc', 'desc']\n     */",
      "accentedSort?": "/** Set to `true` to specify that the sort should take accented characters into account. If this feature is turned on the sort will be slower.\n     * @default false\n     */",
      "unSortIcon?": "/** Set to `true` to show the 'no sort' icon.\n     * @default false\n     */",
      "suppressMultiSort?": "/** Set to `true` to suppress multi-sort when the user shift-clicks a column header.\n     * @default false\n     */",
      "alwaysMultiSort?": "/** Set to `true` to always multi-sort when the user clicks a column header, regardless of key presses.\n     * @default false\n     */",
      "multiSortKey?": "/** Set to `'ctrl'` to have multi sorting work using the `Ctrl` (or `Command ⌘` for Mac) key.\n     */",
      "suppressMaintainUnsortedOrder?": "/** Set to `true` to suppress sorting of un-sorted data to match original row data.\n     * @default false\n     */",
      "icons?": "/** Icons to use inside the grid instead of the grid's default icons.\n     * @initial\n     */",
      "rowHeight?": "/** Default row height in pixels.\n     * @default 25\n     */",
      "rowStyle?": "/** The style properties to apply to all rows. Set to an object of key (style names) and values (style values).\n     */",
      "rowClass?": "/** CSS class(es) for all rows. Provide either a string (class name) or array of strings (array of class names).\n     */",
      "rowClassRules?": "/** Rules which can be applied to include certain CSS classes.\n     */",
      "suppressRowHoverHighlight?": "/** Set to `true` to not highlight rows by adding the `ag-row-hover` CSS class.\n     * @default false\n     */",
      "suppressRowTransform?": "/** Uses CSS `top` instead of CSS `transform` for positioning rows. Useful if the transform function is causing issues such as used in row spanning.\n     * @default false\n     * @initial\n     */",
      "columnHoverHighlight?": "/** Set to `true` to highlight columns by adding the `ag-column-hover` CSS class.\n     * @default false\n     */",
      "gridId?": "/** Provide a custom `gridId` for this instance of the grid. Value will be set on the root DOM node using the attribute `grid-id` as well as being accessible via the `gridApi.getGridId()` method.\n     * @initial\n     */",
      "deltaSort?": "/** When enabled, sorts only the rows added/updated by a transaction.\n     * @default false\n     */",
      "treeDataDisplayType?": "/**/",
      "enableGroupEdit?": "/** @initial\n     */",
      "initialState?": "/** Initial state for the grid. Only read once on initialization. Can be used in conjunction with `api.getState()` to save and restore grid state.\n     * @initial\n     */",
      "reactiveCustomComponents?": "/** **React only**.\n     *\n     * @deprecated As of v32 custom components are created reactively by default.\n     * Set this property to `false` to switch to the legacy way of declaring custom components imperatively.\n     * @initial\n     * @default true\n     */",
      "getContextMenuItems?": "/** For customising the context menu.\n     */",
      "getMainMenuItems?": "/** For customising the main 'column header' menu.\n     * @initial\n     */",
      "postProcessPopup?": "/** Allows user to process popups after they are created. Applications can use this if they want to, for example, reposition the popup.\n     */",
      "processUnpinnedColumns?": "/** Allows the user to process the columns being removed from the pinned section because the viewport is too small to accommodate them.\n     * Returns an array of columns to be removed from the pinned areas.\n     * @initial\n     */",
      "processCellForClipboard?": "/** Allows you to process cells for the clipboard. Handy if for example you have `Date` objects that need to have a particular format if importing into Excel.\n     */",
      "processHeaderForClipboard?": "/** Allows you to process header values for the clipboard.\n     */",
      "processGroupHeaderForClipboard?": "/** Allows you to process group header values for the clipboard.\n     */",
      "processCellFromClipboard?": "/** Allows you to process cells from the clipboard. Handy if for example you have number fields, and want to block non-numbers from getting into the grid.\n     */",
      "sendToClipboard?": "/** Allows you to get the data that would otherwise go to the clipboard. To be used when you want to control the 'copy to clipboard' operation yourself.\n     */",
      "processDataFromClipboard?": "/** Allows complete control of the paste operation, including cancelling the operation (so nothing happens) or replacing the data with other data.\n     */",
      "isExternalFilterPresent?": "/** Grid calls this method to know if an external filter is present.\n     */",
      "doesExternalFilterPass?": "/** Should return `true` if external filter passes, otherwise `false`.\n     */",
      "getChartToolbarItems?": "/** Callback to be used to customise the chart toolbar items.\n     * @initial\n     */",
      "createChartContainer?": "/** Callback to enable displaying the chart in an alternative chart container.\n     * @initial\n     */",
      "focusGridInnerElement?": "/** Allows overriding the element that will be focused when the grid receives focus from outside elements (tabbing into the grid).\n     * @returns `True` if this function should override the grid's default behavior, `False` to allow the grid's default behavior.\n     */",
      "navigateToNextHeader?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a header is focused. Return the next Header position to navigate to or `null` to stay on current header.\n     */",
      "tabToNextHeader?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a header is focused.\n     * Return the next header position to navigate to, `true` to stay on the current header,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "navigateToNextCell?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a cell is focused. Return the next Cell position to navigate to or `null` to stay on current cell.\n     */",
      "tabToNextCell?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a cell is focused.\n     * Return the next cell position to navigate to, `true` to stay on the current cell,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "getLocaleText?": "/** A callback for localising text within the grid.\n     * @initial\n     */",
      "getDocument?": "/** Allows overriding what `document` is used. Currently used by Drag and Drop (may extend to other places in the future). Use this when you want the grid to use a different `document` than the one available on the global scope. This can happen if docking out components (something which Electron supports)\n     */",
      "paginationNumberFormatter?": "/** Allows user to format the numbers in the pagination panel, i.e. 'row count' and 'page number' labels. This is for pagination panel only, to format numbers inside the grid's cells (i.e. your data), then use `valueFormatter` in the column definitions.\n     * @initial\n     */",
      "getGroupRowAgg?": "/** Callback to use when you need access to more then the current column for aggregation.\n     */",
      "isGroupOpenByDefault?": "/** (Client-side Row Model only) Allows groups to be open by default.\n     */",
      "initialGroupOrderComparator?": "/** Allows default sorting of groups.\n     */",
      "processPivotResultColDef?": "/** Callback to be used with pivoting, to allow changing the second column definition.\n     */",
      "processPivotResultColGroupDef?": "/** Callback to be used with pivoting, to allow changing the second column group definition.\n     */",
      "getDataPath?": "/** Callback to be used when working with Tree Data when `treeData = true`.\n     */",
      "getChildCount?": "/** Allows setting the child count for a group row.\n     * @initial\n     */",
      "getServerSideGroupLevelParams?": "/** Allows providing different params for different levels of grouping.\n     * @initial\n     */",
      "isServerSideGroupOpenByDefault?": "/** Allows groups to be open by default.\n     */",
      "isApplyServerSideTransaction?": "/** Allows cancelling transactions.\n     */",
      "isServerSideGroup?": "/** SSRM Tree Data: Allows specifying which rows are expandable.\n     */",
      "getServerSideGroupKey?": "/** SSRM Tree Data: Allows specifying group keys.\n     */",
      "getBusinessKeyForNode?": "/** Return a business key for the node. If implemented, each row in the DOM will have an attribute `row-business-key='abc'` where `abc` is what you return as the business key.\n     * This is useful for automated testing, as it provides a way for your tool to identify rows based on unique business keys.\n     */",
      "getRowId?": "/** Allows setting the ID for a particular row node based on the data.\n     * @initial\n     */",
      "resetRowDataOnUpdate?": "/** When enabled, getRowId() callback is implemented and new Row Data is set, the grid will disregard all previous rows and treat the new Row Data as new data. As a consequence, all Row State (eg selection, rendered rows) will be reset.\n     * @default false\n     */",
      "processRowPostCreate?": "/** Callback fired after the row is rendered into the DOM. Should not be used to initiate side effects.\n     */",
      "isRowSelectable?": "/** Callback to be used to determine which rows are selectable. By default rows are selectable, so return `false` to make a row un-selectable.\n     */",
      "isRowMaster?": "/** Callback to be used with Master Detail to determine if a row should be a master row. If `false` is returned no detail row will exist for this row.\n     */",
      "fillOperation?": "/** Callback to fill values instead of simply copying values or increasing number values using linear progression.\n     */",
      "postSortRows?": "/** Callback to perform additional sorting after the grid has sorted the rows.\n     */",
      "getRowStyle?": "/** Callback version of property `rowStyle` to set style for each row individually. Function should return an object of CSS values or undefined for no styles.\n     */",
      "getRowClass?": "/** Callback version of property `rowClass` to set class(es) for each row individually. Function should return either a string (class name), array of strings (array of class names) or undefined for no class.\n     */",
      "getRowHeight?": "/** Callback version of property `rowHeight` to set height for each row individually. Function should return a positive number of pixels, or return `null`/`undefined` to use the default row height.\n     */",
      "isFullWidthRow?": "/** Tells the grid if this row should be rendered as full width.\n     */",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "/** The tool panel visibility has changed. Fires twice if switching between panels - once with the old panel and once with the new panel.\n     */",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "/** The tool panel size has been changed.\n     */",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "/** The column menu visibility has changed. Fires twice if switching between tabs - once with the old tab and once with the new tab.\n     */",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "/** The context menu visibility has changed (opened or closed).\n     */",
      "onCutStart?(event: CutStartEvent<TData>)": "/** Cut operation has started.\n     */",
      "onCutEnd?(event: CutEndEvent<TData>)": "/** Cut operation has ended.\n     */",
      "onPasteStart?(event: PasteStartEvent<TData>)": "/** Paste operation has started.\n     */",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "/** Paste operation has ended.\n     */",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "/** A column, or group of columns, was hidden / shown.\n     */",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "/** A column, or group of columns, was pinned / unpinned.\n     */",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "/** A column was resized.\n     */",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "/** A column was moved.\n     */",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "/** A value column was added or removed.\n     */",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "/** The pivot mode flag was changed.\n     */",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "/** A pivot column was added, removed or order changed.\n     */",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "/** A column group was opened / closed.\n     */",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "/** User set new columns.\n     */",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "/** The list of grid columns changed.\n     */",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "/** The list of displayed columns changed. This can result from columns open / close, column move, pivot, group, etc.\n     */",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "/** The list of rendered columns changed (only columns in the visible scrolled viewport are rendered by default).\n     */",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "/** Shotgun - gets called when either a) new columns are set or b) `api.applyColumnState()` is used, so everything has changed.\n     */",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "/** A mouse cursor is initially moved over a column header.\n     */",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "/** A mouse cursor is moved out of a column header.\n     */",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "/** A click is performed on a column header.\n     */",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "/** A context menu action, such as right-click or context menu key press, is performed on a column header.\n     */",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "/** Only used by Angular, React and VueJS AG Grid components (not used if doing plain JavaScript).\n     * If the grid receives changes due to bound properties, this event fires after the grid has finished processing the change.\n     */",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "/** Value has changed after editing (this event will not fire if editing was cancelled, eg ESC was pressed) or\n     *  if cell value has changed as a result of cut, paste, cell clear (pressing Delete key),\n     * fill handle, copy range down, undo and redo.\n     */",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "/** Value has changed after editing. Only fires when `readOnlyEdit=true`.\n     */",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "/** A cell's value within a row has changed. This event corresponds to Full Row Editing only.\n     */",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "/** Editing a cell has started.\n     */",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "/** Editing a cell has stopped.\n     */",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "/** Editing a row has started (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStarted` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "/** Editing a row has stopped (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStopped` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "/** Undo operation has started.\n     */",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "/** Undo operation has ended.\n     */",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "/** Redo operation has started.\n     */",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "/** Redo operation has ended.\n     */",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "/** Range delete operation (cell clear) has started.\n     */",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "/** Range delete operation (cell clear) has ended.\n     */",
      "onFillStart?(event: FillStartEvent<TData>)": "/** Fill operation has started.\n     */",
      "onFillEnd?(event: FillEndEvent<TData>)": "/** Fill operation has ended.\n     */",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "/** Filter has been opened.\n     */",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "/** Filter has been modified and applied.\n     */",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "/** Filter was modified but not applied. Used when filters have 'Apply' buttons.\n     */",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "/** Advanced Filter Builder visibility has changed (opened or closed).\n     */",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "/** A chart has been created.\n     */",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "/** The data range for the chart has been changed.\n     */",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "/** Formatting changes have been made by users through the Customize Panel.\n     */",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "/** A chart has been destroyed.\n     */",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "/** DOM event `keyDown` happened on a cell.\n     */",
      "onGridReady?(event: GridReadyEvent<TData>)": "/** The grid has initialised and is ready for most api calls, but may not be fully rendered yet  */",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "/** Invoked immediately before the grid is destroyed. This is useful for cleanup logic that needs to run before the grid is torn down.\n     */",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "/** Fired the first time data is rendered into the grid. Use this event if you want to auto resize columns based on their contents */",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "/** The size of the grid `div` has changed. In other words, the grid was resized.\n     */",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "/** Displayed rows have changed. Triggered after sort, filter or tree expand / collapse events.\n     */",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "/** A row was removed from the DOM, for any reason. Use to clean up resources (if any) used by the row.\n     */",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "/** Which rows are rendered in the DOM has changed.\n     */",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "/** The body was scrolled horizontally or vertically.\n     */",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "/** Main body of the grid has stopped scrolling, either horizontally or vertically.\n     */",
      "onDragStarted?(event: DragStartedEvent<TData>)": "/** When dragging starts. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "/** When dragging stops. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "/** Grid state has been updated.\n     */",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "/** Triggered every time the paging state changes. Some of the most common scenarios for this event to be triggered are:\n     *\n     *  - The page size changes.\n     *  - The current shown page is changed.\n     *  - New data is loaded onto the grid.\n     */",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "/** A drag has started, or dragging was already started and the mouse has re-entered the grid having previously left the grid.\n     */",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "/** The mouse has moved while dragging.\n     */",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "/** The mouse has left the grid while dragging.\n     */",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "/** The drag has finished over the grid.\n     */",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "/** A row group column was added, removed or reordered.\n     */",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "/** A row group was opened or closed.\n     */",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "/** Fired when calling either of the API methods `expandAll()` or `collapseAll()`.\n     */",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "/** Exceeded the `pivotMaxGeneratedColumns` limit when generating columns.\n     */",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "/** The client has set new pinned row data into the grid.\n     */",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "/** Client-Side Row Model only. The client has updated data for the grid by either a) setting new Row Data or b) Applying a Row Transaction.\n     */",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "/** Async transactions have been applied. Contains a list of all transaction results.\n     */",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "/** A server side store has finished refreshing.\n     */",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "/** Header is focused.\n     */",
      "onCellClicked?(event: CellClickedEvent<TData>)": "/** Cell is clicked.\n     */",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "/** Cell is double clicked.\n     */",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "/** Cell is focused.\n     */",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "/** Mouse entered cell.\n     */",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "/** Mouse left cell.\n     */",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "/** Mouse down on cell.\n     */",
      "onRowClicked?(event: RowClickedEvent<TData>)": "/** Row is clicked.\n     */",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "/** Row is double clicked.\n     */",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "/** Row is selected or deselected. The event contains the node in question, so call the node's `isSelected()` method to see if it was just selected or deselected.\n     */",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "/** Row selection is changed. Use the grid API `getSelectedNodes()` or `getSelectedRows()` to get the new list of selected nodes / row data.\n     */",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "/** Cell is right clicked.\n     */",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "/** A change to range selection has occurred.\n     */",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "/** A tooltip has been displayed */",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "/** A tooltip was hidden */",
      "onSortChanged?(event: SortChangedEvent<TData>)": "/** Sort has changed. The grid also listens for this and updates the model.\n     */",
      "api?": "/** @deprecated Since v31 api is no longer attached to GridOptions. See https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api for how to access the api in your framework.\n     */"
    }
  },
  "AgGridReactProps": {
    "meta": {
      "typeParams": [
        "TData = any"
      ]
    },
    "type": {
      "disableStaticMarkup?": "boolean",
      "legacyComponentRendering?": "boolean",
      "gridOptions?": "GridOptions<TData>",
      "modules?": "Module[]",
      "containerStyle?": "any",
      "className?": "string",
      "setGridApi?": "(gridApi: GridApi<TData>) => void",
      "componentWrappingElement?": "string",
      "maxComponentCreationTimeMs?": "number",
      "children?": "any",
      "statusBar?": "{ statusPanels: StatusPanelDef[]; }",
      "sideBar?": "SideBarDef | string | string[] | boolean | null",
      "suppressContextMenu?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "columnMenu?": "'legacy' | 'new'",
      "suppressMenuHide?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "tooltipTrigger?": "'hover' | 'focus'",
      "tooltipShowDelay?": "number",
      "tooltipHideDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "tooltipShowMode?": "'standard' | 'whenTruncated'",
      "tooltipInteraction?": "boolean",
      "popupParent?": "HTMLElement | null",
      "copyHeadersToClipboard?": "boolean",
      "copyGroupHeadersToClipboard?": "boolean",
      "clipboardDelimiter?": "string",
      "suppressCopyRowsToClipboard?": "boolean",
      "suppressCopySingleCellRanges?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "suppressCutToClipboard?": "boolean",
      "columnDefs?": "(ColDef<TData> | ColGroupDef<TData>)[] | null",
      "defaultColDef?": "ColDef<TData>",
      "defaultColGroupDef?": "Partial<ColGroupDef<TData>>",
      "columnTypes?": "{ [key: string]: ColTypeDef<TData>; }",
      "dataTypeDefinitions?": "{ [cellDataType: string]: DataTypeDefinition<TData>; }",
      "maintainColumnOrder?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "headerHeight?": "number",
      "groupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "pivotHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "suppressRowGroupHidesColumns?": "boolean",
      "colResizeDefault?": "'shift'",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "autoSizeStrategy?": "SizeColumnsToFitGridStrategy | SizeColumnsToFitProvidedWidthStrategy | SizeColumnsToContentStrategy",
      "components?": "{ [p: string]: any; }",
      "editType?": "'fullRow'",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "readOnlyEdit?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "enterNavigatesVertically?": "boolean",
      "enterNavigatesVerticallyAfterEdit?": "boolean",
      "enableCellEditingOnBackspace?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "defaultCsvExportParams?": "CsvExportParams",
      "suppressCsvExport?": "boolean",
      "defaultExcelExportParams?": "ExcelExportParams",
      "suppressExcelExport?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "includeHiddenColumnsInQuickFilter?": "boolean",
      "quickFilterParser?": "(quickFilter: string) => string[]",
      "quickFilterMatcher?": "(quickFilterParts: string[], rowQuickFilterAggregateText: string) => boolean",
      "applyQuickFilterBeforePivotOrAgg?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "enableAdvancedFilter?": "boolean",
      "advancedFilterModel?": "AdvancedFilterModel | null",
      "includeHiddenColumnsInAdvancedFilter?": "boolean",
      "advancedFilterParent?": "HTMLElement | null",
      "advancedFilterBuilderParams?": "IAdvancedFilterBuilderParams",
      "suppressAdvancedFilterEval?": "boolean",
      "enableCharts?": "boolean",
      "chartThemes?": "string[]",
      "customChartThemes?": "{ [name: string]: AgChartTheme; }",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "chartToolPanelsDef?": "ChartToolPanelsDef",
      "chartMenuItems?": "(string | MenuItemDef)[] | GetChartMenuItems<TData>",
      "loadingCellRenderer?": "any",
      "loadingCellRendererParams?": "any",
      "loadingCellRendererSelector?": "LoadingCellRendererSelectorFunc<TData>",
      "localeText?": "{ [key: string]: string; }",
      "masterDetail?": "boolean",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "detailCellRenderer?": "any",
      "detailCellRendererParams?": "any",
      "detailRowHeight?": "number",
      "detailRowAutoHeight?": "boolean",
      "context?": "any",
      "alignedGrids?": "AlignedGrid[] | (() => AlignedGrid[])",
      "tabIndex?": "number",
      "rowBuffer?": "number",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "enableCellExpressions?": "boolean",
      "suppressTouch?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "suppressBrowserResizeObserver?": "boolean",
      "suppressPropertyNamesCheck?": "boolean",
      "suppressChangeDetection?": "boolean",
      "debug?": "boolean",
      "loading?": "boolean",
      "overlayLoadingTemplate?": "string",
      "loadingOverlayComponent?": "any",
      "loadingOverlayComponentParams?": "any",
      "suppressLoadingOverlay?": "boolean",
      "overlayNoRowsTemplate?": "string",
      "noRowsOverlayComponent?": "any",
      "noRowsOverlayComponentParams?": "any",
      "suppressNoRowsOverlay?": "boolean",
      "pagination?": "boolean",
      "paginationPageSize?": "number",
      "paginationPageSizeSelector?": "number[] | boolean",
      "paginationAutoPageSize?": "boolean",
      "paginateChildRows?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pivotMode?": "boolean",
      "pivotPanelShow?": "'always' | 'onlyWhenPivoting' | 'never'",
      "pivotMaxGeneratedColumns?": "number",
      "pivotDefaultExpanded?": "number",
      "pivotColumnGroupTotals?": "'before' | 'after'",
      "pivotRowTotals?": "'before' | 'after'",
      "pivotSuppressAutoColumn?": "boolean",
      "suppressExpandablePivotGroups?": "boolean",
      "functionsReadOnly?": "boolean",
      "aggFuncs?": "{ [key: string]: IAggFunc<TData>; }",
      "suppressAggFuncInHeader?": "boolean",
      "alwaysAggregateAtRootLevel?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "removePivotHeaderRowWhenSingleValueColumn?": "boolean",
      "animateRows?": "boolean",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDuration?": "number",
      "cellFlashDelay?": "number",
      "cellFadeDuration?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "domLayout?": "DomLayoutType",
      "ensureDomOrder?": "boolean",
      "enableRtl?": "boolean",
      "suppressColumnVirtualisation?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "suppressRowVirtualisation?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "rowDragEntireRow?": "boolean",
      "rowDragMultiRow?": "boolean",
      "rowDragText?": "(params: IRowDragItem, dragItemCount: number) => string",
      "fullWidthCellRenderer?": "any",
      "fullWidthCellRendererParams?": "any",
      "embedFullWidthRows?": "boolean",
      "suppressGroupMaintainValueType?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupDefaultExpanded?": "number",
      "autoGroupColumnDef?": "ColDef<TData>",
      "groupMaintainOrder?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupLockGroupColumns?": "number",
      "groupAggFiltering?": "boolean | IsRowFilterable<TData>",
      "groupIncludeFooter?": "boolean | UseGroupFooter<TData>",
      "groupIncludeTotalFooter?": "boolean",
      "groupTotalRow?": "'top' | 'bottom' | UseGroupTotalRow<TData>",
      "grandTotalRow?": "'top' | 'bottom'",
      "suppressStickyTotalRow?": "boolean | 'grand' | 'group'",
      "groupSuppressBlankHeader?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "showOpenedGroup?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "groupAllowUnbalanced?": "boolean",
      "rowGroupPanelShow?": "'always' | 'onlyWhenGrouping' | 'never'",
      "groupRowRenderer?": "any",
      "groupRowRendererParams?": "any",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "treeData?": "boolean",
      "rowGroupPanelSuppressSort?": "boolean",
      "suppressGroupRowsSticky?": "boolean",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "rowModelType?": "RowModelType",
      "rowData?": "TData[] | null",
      "asyncTransactionWaitMillis?": "number",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "datasource?": "IDatasource",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "serverSideInitialRowCount?": "number",
      "suppressServerSideInfiniteScroll?": "boolean",
      "suppressServerSideFullWidthLoadingRow?": "boolean",
      "cacheBlockSize?": "number",
      "maxBlocksInCache?": "number",
      "maxConcurrentDatasourceRequests?": "number",
      "blockLoadDebounceMillis?": "number",
      "purgeClosedRowNodes?": "boolean",
      "serverSideDatasource?": "IServerSideDatasource",
      "serverSideSortAllLevels?": "boolean",
      "serverSideEnableClientSideSort?": "boolean",
      "serverSideOnlyRefreshFilteredGroups?": "boolean",
      "serverSideSortOnServer?": "boolean",
      "serverSideFilterOnServer?": "boolean",
      "serverSidePivotResultFieldSeparator?": "string",
      "viewportDatasource?": "IViewportDatasource",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressScrollWhenPopupsAreOpen?": "boolean",
      "suppressAnimationFrame?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "scrollbarWidth?": "number",
      "rowSelection?": "'single' | 'multiple'",
      "rowMultiSelectWithClick?": "boolean",
      "suppressRowDeselection?": "boolean",
      "suppressRowClickSelection?": "boolean",
      "suppressCellFocus?": "boolean",
      "suppressHeaderFocus?": "boolean",
      "suppressMultiRangeSelection?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "'x' | 'y' | 'xy'",
      "suppressClearOnFillReduction?": "boolean",
      "sortingOrder?": "SortDirection[]",
      "accentedSort?": "boolean",
      "unSortIcon?": "boolean",
      "suppressMultiSort?": "boolean",
      "alwaysMultiSort?": "boolean",
      "multiSortKey?": "'ctrl'",
      "suppressMaintainUnsortedOrder?": "boolean",
      "icons?": "{ [key: string]: ((...args: any[]) => any) | string; }",
      "rowHeight?": "number",
      "rowStyle?": "RowStyle",
      "rowClass?": "string | string[]",
      "rowClassRules?": "RowClassRules<TData>",
      "suppressRowHoverHighlight?": "boolean",
      "suppressRowTransform?": "boolean",
      "columnHoverHighlight?": "boolean",
      "gridId?": "string",
      "deltaSort?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "enableGroupEdit?": "boolean",
      "initialState?": "GridState",
      "reactiveCustomComponents?": "boolean",
      "getContextMenuItems?": "GetContextMenuItems<TData>",
      "getMainMenuItems?": "GetMainMenuItems<TData>",
      "postProcessPopup?": "(params: PostProcessPopupParams<TData>) => void",
      "processUnpinnedColumns?": "(params: ProcessUnpinnedColumnsParams<TData>) => Column[]",
      "processCellForClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "processHeaderForClipboard?": "(params: ProcessHeaderForExportParams<TData>) => any",
      "processGroupHeaderForClipboard?": "(params: ProcessGroupHeaderForExportParams<TData>) => any",
      "processCellFromClipboard?": "(params: ProcessCellForExportParams<TData>) => any",
      "sendToClipboard?": "(params: SendToClipboardParams<TData>) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams<TData>) => string[][] | null",
      "isExternalFilterPresent?": "(params: IsExternalFilterPresentParams<TData>) => boolean",
      "doesExternalFilterPass?": "(node: IRowNode<TData>) => boolean",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "createChartContainer?": "(params: ChartRefParams<TData>) => void",
      "focusGridInnerElement?": "(params: FocusGridInnerElementParams<TData>) => boolean",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams<TData>) => HeaderPosition | null",
      "tabToNextHeader?": "(params: TabToNextHeaderParams<TData>) => HeaderPosition | boolean | null",
      "navigateToNextCell?": "(params: NavigateToNextCellParams<TData>) => CellPosition | null",
      "tabToNextCell?": "(params: TabToNextCellParams<TData>) => CellPosition | boolean | null",
      "getLocaleText?": "(params: GetLocaleTextParams<TData>) => string",
      "getDocument?": "() => Document",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams<TData>) => string",
      "getGroupRowAgg?": "(params: GetGroupRowAggParams<TData>) => any",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams<TData>) => boolean",
      "initialGroupOrderComparator?": "(params: InitialGroupOrderComparatorParams<TData>) => number",
      "processPivotResultColDef?": "(colDef: ColDef<TData>) => void",
      "processPivotResultColGroupDef?": "(colGroupDef: ColGroupDef<TData>) => void",
      "getDataPath?": "GetDataPath<TData>",
      "getChildCount?": "(dataItem: any) => number",
      "getServerSideGroupLevelParams?": "(params: GetServerSideGroupLevelParamsParams) => ServerSideGroupLevelParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "isServerSideGroup?": "IsServerSideGroup",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getBusinessKeyForNode?": "(node: IRowNode<TData>) => string",
      "getRowId?": "GetRowIdFunc<TData>",
      "resetRowDataOnUpdate?": "boolean",
      "processRowPostCreate?": "(params: ProcessRowParams<TData>) => void",
      "isRowSelectable?": "IsRowSelectable<TData>",
      "isRowMaster?": "IsRowMaster<TData>",
      "fillOperation?": "(params: FillOperationParams<TData>) => any",
      "postSortRows?": "(params: PostSortRowsParams<TData>) => void",
      "getRowStyle?": "(params: RowClassParams<TData>) => RowStyle | undefined",
      "getRowClass?": "(params: RowClassParams<TData>) => string | string[] | undefined",
      "getRowHeight?": "(params: RowHeightParams<TData>) => number | undefined | null",
      "isFullWidthRow?": "(params: IsFullWidthRowParams<TData>) => boolean",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "void",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "void",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "void",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "void",
      "onCutStart?(event: CutStartEvent<TData>)": "void",
      "onCutEnd?(event: CutEndEvent<TData>)": "void",
      "onPasteStart?(event: PasteStartEvent<TData>)": "void",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "void",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "void",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "void",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "void",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "void",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "void",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "void",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "void",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "void",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "void",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "void",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "void",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "void",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "void",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "void",
      "onFillStart?(event: FillStartEvent<TData>)": "void",
      "onFillEnd?(event: FillEndEvent<TData>)": "void",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "void",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "void",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "void",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "void",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "void",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "void",
      "onGridReady?(event: GridReadyEvent<TData>)": "void",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "void",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "void",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "void",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "void",
      "onDragStarted?(event: DragStartedEvent<TData>)": "void",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "void",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "void",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "void",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "void",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "void",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "void",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "void",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "void",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "void",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "void",
      "onCellClicked?(event: CellClickedEvent<TData>)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "void",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "void",
      "onRowClicked?(event: RowClickedEvent<TData>)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "void",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "void",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "void",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "void",
      "onSortChanged?(event: SortChangedEvent<TData>)": "void",
      "api?": "never"
    },
    "docs": {
      "disableStaticMarkup?": "/** @deprecated v31.1 No longer used. */",
      "legacyComponentRendering?": "/** @deprecated v31.1 No longer used. */",
      "modules?": "/** Used to register AG Grid Modules directly with this instance of the grid.\n     * See [Providing Modules To Individual Grids](https://www.ag-grid.com/react-data-grid/modules/#providing-modules-to-individual-grids) for more information.\n     */",
      "statusBar?": "/** Specifies the status bar components to use in the status bar.\n     */",
      "sideBar?": "/** Specifies the side bar components.\n     */",
      "suppressContextMenu?": "/** Set to `true` to not show the context menu. Use if you don't want to use the default 'right click' context menu.\n     * @default false\n     */",
      "preventDefaultOnContextMenu?": "/** When using `suppressContextMenu`, you can use the `onCellContextMenu` function to provide your own code to handle cell `contextmenu` events.\n     * This flag is useful to prevent the browser from showing its default context menu.\n     * @default false\n     */",
      "allowContextMenuWithControlKey?": "/** Allows context menu to show, even when `Ctrl` key is held down.\n     * @default false\n     */",
      "columnMenu?": "/** Changes the display type of the column menu.\n     * `'new'` just displays the main list of menu items. `'legacy'` displays a tabbed menu.\n     * @default 'new'\n     * @initial\n     */",
      "suppressMenuHide?": "/** When `true`, the column menu button will always be shown.\n     * When `false, the column menu button will only show when the mouse is over the column header.\n     * If `columnMenu = 'legacy'`, this will default to `false` instead of `true`.\n     * @default true\n     */",
      "enableBrowserTooltips?": "/** Set to `true` to use the browser's default tooltip instead of using the grid's Tooltip Component.\n     * @default false\n     * @initial\n     */",
      "tooltipTrigger?": "/** The trigger that will cause tooltips to show and hide.\n     *  - `hover` - The tooltip will show/hide when a cell/header is hovered.\n     *  - `focus` - The tooltip will show/hide when a cell/header is focused.\n     * @default 'hover'\n     * @initial\n     */",
      "tooltipShowDelay?": "/** The delay in milliseconds that it takes for tooltips to show up once an element is hovered over.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true`.\n     * @default 2000\n     */",
      "tooltipHideDelay?": "/** The delay in milliseconds that it takes for tooltips to hide once they have been displayed.\n     * **Note:** This property does not work if `enableBrowserTooltips` is `true` and `tooltipHideTriggers` includes `timeout`.\n     * @default 10000\n     */",
      "tooltipMouseTrack?": "/** Set to `true` to have tooltips follow the cursor once they are displayed.\n     * @default false\n     * @initial\n     */",
      "tooltipShowMode?": "/** This defines when tooltip will show up for Cells, Headers and SetFilter Items.\n     *  - `standard` - The tooltip always shows up when the items configured with Tooltips are hovered.\n     * - `whenTruncated` - The tooltip will only be displayed when the items hovered have truncated (showing ellipsis) values. This property does not work when `enableBrowserTooltips={true}`.\n     * @default `standard`\n     */",
      "tooltipInteraction?": "/** Set to `true` to enable tooltip interaction. When this option is enabled, the tooltip will not hide while the\n     * tooltip itself it being hovered or has focus.\n     * @default false\n     * @initial\n     */",
      "popupParent?": "/** DOM element to use as the popup parent for grid popups (context menu, column menu etc).\n     */",
      "copyHeadersToClipboard?": "/** Set to `true` to also include headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "copyGroupHeadersToClipboard?": "/** Set to `true` to also include group headers when copying to clipboard using `Ctrl + C` clipboard.\n     * @default false\n     */",
      "clipboardDelimiter?": "/** Specify the delimiter to use when copying to clipboard.\n     * @default '\\t'\n     */",
      "suppressCopyRowsToClipboard?": "/** Set to `true` to copy the cell range or focused cell to the clipboard and never the selected rows.\n     * @default false\n     */",
      "suppressCopySingleCellRanges?": "/** Set to `true` to copy rows instead of ranges when a range with only a single cell is selected.\n     * @default false\n     */",
      "suppressLastEmptyLineOnPaste?": "/** Set to `true` to work around a bug with Excel (Windows) that adds an extra empty line at the end of ranges copied to the clipboard.\n     * @default false\n     */",
      "suppressClipboardPaste?": "/** Set to `true` to turn off paste operations within the grid.\n     * @default false\n     */",
      "suppressClipboardApi?": "/** Set to `true` to stop the grid trying to use the Clipboard API, if it is blocked, and immediately fallback to the workaround.\n     * @default false\n     */",
      "suppressCutToClipboard?": "/** Set to `true` to block **cut** operations within the grid.\n     * @default false\n     */",
      "columnDefs?": "/** Array of Column / Column Group definitions.\n     */",
      "defaultColDef?": "/** A default column definition. Items defined in the actual column definitions get precedence.\n     */",
      "defaultColGroupDef?": "/** A default column group definition. All column group definitions will use these properties. Items defined in the actual column group definition get precedence.\n     * @initial\n     */",
      "columnTypes?": "/** An object map of custom column types which contain groups of properties that column definitions can reuse by referencing in their `type` property.\n     */",
      "dataTypeDefinitions?": "/** An object map of cell data types to their definitions.\n     * Cell data types can either override/update the pre-defined data types\n     * (`'text'`, `'number'`,  `'boolean'`,  `'date'`,  `'dateString'` or  `'object'`),\n     * or can be custom data types.\n     */",
      "maintainColumnOrder?": "/** Keeps the order of Columns maintained after new Column Definitions are updated.\n     * @default false\n     */",
      "suppressFieldDotNotation?": "/** If `true`, then dots in field names (e.g. `'address.firstLine'`) are not treated as deep references. Allows you to use dots in your field name if you prefer.\n     * @default false\n     */",
      "headerHeight?": "/** The height in pixels for the row containing the column label header. If not specified, it uses the theme value of `header-height`.\n     */",
      "groupHeaderHeight?": "/** The height in pixels for the rows containing header column groups. If not specified, it uses `headerHeight`.\n     */",
      "floatingFiltersHeight?": "/** The height in pixels for the row containing the floating filters. If not specified, it uses the theme value of `header-height`.\n     */",
      "pivotHeaderHeight?": "/** The height in pixels for the row containing the columns when in pivot mode. If not specified, it uses `headerHeight`.\n     */",
      "pivotGroupHeaderHeight?": "/** The height in pixels for the row containing header column groups when in pivot mode. If not specified, it uses `groupHeaderHeight`.\n     */",
      "allowDragFromColumnsToolPanel?": "/** Allow reordering and pinning columns by dragging columns from the Columns Tool Panel to the grid.\n     * @default false\n     */",
      "suppressMovableColumns?": "/** Set to `true` to suppress column moving, i.e. to make the columns fixed position.\n     * @default false\n     */",
      "suppressColumnMoveAnimation?": "/** If `true`, the `ag-column-moving` class is not added to the grid while columns are moving. In the default themes, this results in no animation when moving columns.\n     * @default false\n     */",
      "suppressDragLeaveHidesColumns?": "/** If `true`, when you drag a column out of the grid (e.g. to the group zone) the column is not hidden.\n     * @default false\n     */",
      "suppressRowGroupHidesColumns?": "/** If `true`, when you drag a column into a row group panel the column is not hidden.\n     * @default false\n     */",
      "colResizeDefault?": "/** Set to `'shift'` to have shift-resize as the default resize operation (same as user holding down `Shift` while resizing).\n     */",
      "suppressAutoSize?": "/** Suppresses auto-sizing columns for columns. In other words, double clicking a column's header's edge will not auto-size.\n     * @default false\n     * @initial\n     */",
      "autoSizePadding?": "/** Number of pixels to add to a column width after the [auto-sizing](./column-sizing/#auto-size-columns-to-fit-cell-contents) calculation.\n     * Set this if you want to add extra room to accommodate (for example) sort icons, or some other dynamic nature of the header.\n     * @default 20\n     */",
      "skipHeaderOnAutoSize?": "/** Set this to `true` to skip the `headerName` when `autoSize` is called by default.\n     * @default false\n     * @initial\n     */",
      "autoSizeStrategy?": "/** Auto-size the columns when the grid is loaded. Can size to fit the grid width, fit a provided width, or fit the cell contents.\n     * @initial\n     */",
      "components?": "/** A map of component names to components.\n     * @initial\n     */",
      "editType?": "/** Set to `'fullRow'` to enable Full Row Editing. Otherwise leave blank to edit one cell at a time.\n     */",
      "singleClickEdit?": "/** Set to `true` to enable Single Click Editing for cells, to start editing with a single click.\n     * @default false\n     */",
      "suppressClickEdit?": "/** Set to `true` so that neither single nor double click starts editing.\n     * @default false\n     */",
      "readOnlyEdit?": "/** Set to `true` to stop the grid updating data after `Edit`, `Clipboard` and `Fill Handle` operations. When this is set, it is intended the application will update the data, eg in an external immutable store, and then pass the new dataset to the grid. <br />**Note:** `rowNode.setDataValue()` does not update the value of the cell when this is `True`, it fires `onCellEditRequest` instead.\n     * @default false\n     */",
      "stopEditingWhenCellsLoseFocus?": "/** Set this to `true` to stop cell editing when grid loses focus.\n     * The default is that the grid stays editing until focus goes onto another cell.\n     * @default false\n     * @initial\n     */",
      "enterNavigatesVertically?": "/** Set to `true` along with `enterNavigatesVerticallyAfterEdit` to have Excel-style behaviour for the `Enter` key.\n     * i.e. pressing the `Enter` key will move down to the cell beneath and `Shift+Enter` will move up to the cell above.\n     * @default false\n     */",
      "enterNavigatesVerticallyAfterEdit?": "/** Set to `true` along with `enterNavigatesVertically` to have Excel-style behaviour for the 'Enter' key.\n     * i.e. pressing the Enter key will move down to the cell beneath and Shift+Enter key will move up to the cell above.\n     * @default false\n     */",
      "enableCellEditingOnBackspace?": "/** Forces Cell Editing to start when backspace is pressed. This is only relevant for MacOS users.\n     */",
      "undoRedoCellEditing?": "/** Set to `true` to enable Undo / Redo while editing.\n     * @initial\n     */",
      "undoRedoCellEditingLimit?": "/** Set the size of the undo / redo stack.\n     * @default 10\n     * @initial\n     */",
      "defaultCsvExportParams?": "/** A default configuration object used to export to CSV.\n     */",
      "suppressCsvExport?": "/** Prevents the user from exporting the grid to CSV.\n     * @default false\n     */",
      "defaultExcelExportParams?": "/** A default configuration object used to export to Excel.\n     */",
      "suppressExcelExport?": "/** Prevents the user from exporting the grid to Excel.\n     * @default false\n     */",
      "excelStyles?": "/** A list (array) of Excel styles to be used when exporting to Excel with styles.\n     * @initial\n     */",
      "quickFilterText?": "/** Rows are filtered using this text as a Quick Filter.\n     */",
      "cacheQuickFilter?": "/** Set to `true` to turn on the Quick Filter cache, used to improve performance when using the Quick Filter.\n     * @default false\n     * @initial\n     */",
      "includeHiddenColumnsInQuickFilter?": "/** Hidden columns are excluded from the Quick Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "quickFilterParser?": "/** Changes how the Quick Filter splits the Quick Filter text into search terms.\n     */",
      "quickFilterMatcher?": "/** Changes the matching logic for whether a row passes the Quick Filter.\n     */",
      "applyQuickFilterBeforePivotOrAgg?": "/** When pivoting, Quick Filter is only applied on the pivoted data\n     * (or aggregated data if `groupAggFiltering = true`).\n     * Set to `true` to apply Quick Filter before pivoting (/aggregating) instead.\n     * @default false\n     */",
      "excludeChildrenWhenTreeDataFiltering?": "/** Set to `true` to override the default tree data filtering behaviour to instead exclude child nodes from filter results.\n     * @default false\n     */",
      "enableAdvancedFilter?": "/** Set to true to enable the Advanced Filter.\n     * @default false\n     */",
      "advancedFilterModel?": "/** @deprecated As of v31, use `initialState.filter.advancedFilterModel` instead.\n     * @initial\n     */",
      "includeHiddenColumnsInAdvancedFilter?": "/** Hidden columns are excluded from the Advanced Filter by default.\n     * To include hidden columns, set to `true`.\n     * @default false\n     */",
      "advancedFilterParent?": "/** DOM element to use as the parent for the Advanced Filter to allow it to appear outside of the grid.\n     * Set to `null` or `undefined` to appear inside the grid.\n     */",
      "advancedFilterBuilderParams?": "/** Customise the parameters passed to the Advanced Filter Builder.\n     */",
      "suppressAdvancedFilterEval?": "/** By default, Advanced Filter sanitises user input and passes it to `new Function()` to provide the best performance.\n     * Set to `true` to prevent this and use defined functions instead.\n     * This will result in slower filtering, but it enables Advanced Filter to work when `unsafe-eval` is disabled.\n     * @default false\n     */",
      "enableCharts?": "/** Set to `true` to Enable Charts.\n     * @default false\n     */",
      "chartThemes?": "/** The list of chart themes that a user can choose from in the chart panel.\n     * @default ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];\n     * @initial\n     */",
      "customChartThemes?": "/** A map containing custom chart themes.\n     * @initial\n     */",
      "chartThemeOverrides?": "/** Chart theme overrides applied to all themes.\n     * @initial\n     */",
      "chartToolPanelsDef?": "/** Allows customisation of the Chart Tool Panels, such as changing the tool panels visibility and order, as well as choosing which charts should be displayed in the chart panel.\n     * @initial\n     */",
      "chartMenuItems?": "/** Get chart menu items. Only applies when using AG Charts Enterprise.\n     */",
      "loadingCellRenderer?": "/** Provide your own loading cell renderer to use when data is loading via a DataSource.\n     * See [Loading Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-loading-cell-renderer/) for framework specific implementation details.\n     */",
      "loadingCellRendererParams?": "/** Params to be passed to the `loadingCellRenderer` component.\n     */",
      "loadingCellRendererSelector?": "/** Callback to select which loading cell renderer to be used when data is loading via a DataSource.\n     * @initial\n     */",
      "localeText?": "/** A map of key->value pairs for localising text within the grid.\n     * @initial\n     */",
      "masterDetail?": "/** Set to `true` to enable Master Detail.\n     * @default false\n     */",
      "keepDetailRows?": "/** Set to `true` to keep detail rows for when they are displayed again.\n     * @default false\n     * @initial\n     */",
      "keepDetailRowsCount?": "/** Sets the number of details rows to keep.\n     * @default 10\n     * @initial\n     */",
      "detailCellRenderer?": "/** Provide a custom `detailCellRenderer` to use when a master row is expanded.\n     * See [Detail Cell Renderer](https://www.ag-grid.com/javascript-data-grid/master-detail-custom-detail/) for framework specific implementation details.\n     */",
      "detailCellRendererParams?": "/** Specifies the params to be used by the Detail Cell Renderer. Can also be a function that provides the params to enable dynamic definitions of the params.\n     */",
      "detailRowHeight?": "/** Set fixed height in pixels for each detail row.\n     * @initial\n     */",
      "detailRowAutoHeight?": "/** Set to `true` to have the detail grid dynamically change it's height to fit it's rows.\n     * @initial\n     */",
      "context?": "/** Provides a context object that is provided to different callbacks the grid uses. Used for passing additional information to the callbacks by your application.\n     * @initial\n     */",
      "alignedGrids?": "/**\n     * A list of grids to treat as Aligned Grids.\n     * Provide a list if the grids / apis already exist or return via a callback to allow the aligned grids to be retrieved asynchronously.\n     * If grids are aligned then the columns and horizontal scrolling will be kept in sync.\n     */",
      "tabIndex?": "/** Change this value to set the tabIndex order of the Grid within your application.\n     * @default 0\n     * @initial\n     */",
      "rowBuffer?": "/** The number of rows rendered outside the viewable area the grid renders.\n     * Having a buffer means the grid will have rows ready to show as the user slowly scrolls vertically.\n     * @default 10\n     */",
      "valueCache?": "/** Set to `true` to turn on the value cache.\n     * @default false\n     * @initial\n     */",
      "valueCacheNeverExpires?": "/** Set to `true` to configure the value cache to not expire after data updates.\n     * @default false\n     * @initial\n     */",
      "enableCellExpressions?": "/** Set to `true` to allow cell expressions.\n     * @default false\n     * @initial\n     */",
      "suppressTouch?": "/** Disables touch support (but does not remove the browser's efforts to simulate mouse events on touch).\n     * @default false\n     * @initial\n     */",
      "suppressFocusAfterRefresh?": "/** Set to `true` to not set focus back on the grid after a refresh. This can avoid issues where you want to keep the focus on another part of the browser.\n     * @default false\n     */",
      "suppressAsyncEvents?": "/** Disables the asynchronous nature of the events introduced in v10, and makes them synchronous. This property only exists for the purpose of supporting legacy code which has a dependency on synchronous events from earlier versions (v9 or earlier) of AG Grid. **It is strongly recommended that you do not change this property unless you have legacy issues.**\n     * @deprecated v31 Events should be handled asynchronously.\n     * @default false\n     * @initial\n     */",
      "suppressBrowserResizeObserver?": "/** The grid will check for `ResizeObserver` and use it if it exists in the browser, otherwise it will use the grid's alternative implementation. Some users reported issues with Chrome's `ResizeObserver`. Use this property to always use the grid's alternative implementation should such problems exist.\n     * @default false\n     * @initial\n     */",
      "suppressPropertyNamesCheck?": "/** Disables showing a warning message in the console if using a `gridOptions` or `colDef` property that doesn't exist.\n     * @default false\n     * @initial\n     */",
      "suppressChangeDetection?": "/** Disables change detection.\n     * @default false\n     */",
      "debug?": "/** Set this to `true` to enable debug information from the grid and related components. Will result in additional logging being output, but very useful when investigating problems.\n     * @default false\n     * @initial\n     */",
      "loading?": "/** Show or hide the loading overlay.\n     */",
      "overlayLoadingTemplate?": "/** Provide a HTML string to override the default loading overlay.\n     */",
      "loadingOverlayComponent?": "/** Provide a custom loading overlay component.\n     * @initial\n     */",
      "loadingOverlayComponentParams?": "/** Customise the parameters provided to the loading overlay component.\n     */",
      "suppressLoadingOverlay?": "/** Disables the 'loading' overlay.\n     * @deprecated v32 - Deprecated. Use `loading=false` instead.\n     * @default false\n     * @initial\n     */",
      "overlayNoRowsTemplate?": "/** Provide a HTML string to override the default no-rows overlay.\n     */",
      "noRowsOverlayComponent?": "/** Provide a custom no-rows overlay component.\n     * @initial\n     */",
      "noRowsOverlayComponentParams?": "/** Customise the parameters provided to the no-rows overlay component.\n     */",
      "suppressNoRowsOverlay?": "/** Set to `true` to prevent the no-rows overlay being shown when there is no row data.\n     * @default false\n     * @initial\n     */",
      "pagination?": "/** Set whether pagination is enabled.\n     * @default false\n     */",
      "paginationPageSize?": "/** How many rows to load per page. If `paginationAutoPageSize` is specified, this property is ignored.\n     * @default 100\n     */",
      "paginationPageSizeSelector?": "/** Determines if the page size selector is shown in the pagination panel or not.\n     * Set to an array of values to show the page size selector with custom list of possible page sizes.\n     * Set to `true` to show the page size selector with the default page sizes `[20, 50, 100]`.\n     * Set to `false` to hide the page size selector.\n     * @default true\n     * @initial\n     */",
      "paginationAutoPageSize?": "/** Set to `true` so that the number of rows to load per page is automatically adjusted by the grid so each page shows enough rows to just fill the area designated for the grid. If `false`, `paginationPageSize` is used.\n     * @default false\n     */",
      "paginateChildRows?": "/** Set to `true` to have pages split children of groups when using Row Grouping or detail rows with Master Detail.\n     * @default false\n     * @initial\n     */",
      "suppressPaginationPanel?": "/** If `true`, the default grid controls for navigation are hidden.\n     * This is useful if `pagination=true` and you want to provide your own pagination controls.\n     * Otherwise, when `pagination=true` the grid automatically shows the necessary controls at the bottom so that the user can navigate through the different pages.\n     * @default false\n     */",
      "pivotMode?": "/** Set to `true` to enable pivot mode.\n     * @default false\n     */",
      "pivotPanelShow?": "/** When to show the 'pivot panel' (where you drag rows to pivot) at the top. Note that the pivot panel will never show if `pivotMode` is off.\n     * @default 'never'\n     * @initial\n     */",
      "pivotMaxGeneratedColumns?": "/** The maximum number of generated columns before the grid halts execution. Upon reaching this number, the grid halts generation of columns\n     * and triggers a `pivotMaxColumnsExceeded` event. `-1` for no limit.\n     * @default -1\n     */",
      "pivotDefaultExpanded?": "/** If pivoting, set to the number of column group levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "pivotColumnGroupTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear within the Pivot Column Groups, in the position specified.\n     */",
      "pivotRowTotals?": "/** When set and the grid is in pivot mode, automatically calculated totals will appear for each value column in the position specified.\n     */",
      "pivotSuppressAutoColumn?": "/** If `true`, the grid will not swap in the grouping column when pivoting. Useful if pivoting using Server Side Row Model or Viewport Row Model and you want full control of all columns including the group column.\n     * @default false\n     * @initial\n     */",
      "suppressExpandablePivotGroups?": "/** When enabled, pivot column groups will appear 'fixed', without the ability to expand and collapse the column groups.\n     * @default false\n     * @initial\n     */",
      "functionsReadOnly?": "/** If `true`, then row group, pivot and value aggregation will be read-only from the GUI. The grid will display what values are used for each, but will not allow the user to change the selection.\n     * @default false\n     */",
      "aggFuncs?": "/** A map of 'function name' to 'function' for custom aggregation functions.\n     * @initial\n     */",
      "suppressAggFuncInHeader?": "/** When `true`, column headers won't include the `aggFunc` name, e.g. `'sum(Bank Balance)`' will just be `'Bank Balance'`.\n     * @default false\n     * @initial\n     */",
      "alwaysAggregateAtRootLevel?": "/** When using aggregations, the grid will always calculate the root level aggregation value.\n     * @default false\n     */",
      "aggregateOnlyChangedColumns?": "/** When using change detection, only the updated column will be re-aggregated.\n     * @default false\n     */",
      "suppressAggFilteredOnly?": "/** Set to `true` so that aggregations are not impacted by filtering.\n     * @default false\n     */",
      "removePivotHeaderRowWhenSingleValueColumn?": "/** Set to `true` to omit the value Column header when there is only a single value column.\n     * @default false\n     * @initial\n     */",
      "animateRows?": "/** Set to `false` to disable Row Animation which is enabled by default.\n     * @default true\n     */",
      "enableCellChangeFlash?": "/** Set to `true` to have cells flash after data changes.\n     * @default false\n     * @deprecated 31.2 use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns.\n     */",
      "cellFlashDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long a cell should remain in its \"flashed\" state.\n     * @default 500\n     */",
      "cellFlashDelay?": "/** @deprecated v31.1 - use `cellFlashDuration` instead.\n     */",
      "cellFadeDuration?": "/** To be used when setting `enableCellChangeFlash` on column definitions. Sets the duration in milliseconds of how long the \"flashed\" state animation takes to fade away after the timer set by cellFlashDuration has completed.\n     * @default 1000\n     */",
      "cellFadeDelay?": "/** @deprecated v31.1 - use `cellFadeDuration` instead.\n     */",
      "allowShowChangeAfterFilter?": "/** Set to `true` to have cells flash after data changes even when the change is due to filtering.\n     * @default false\n     * @initial\n     */",
      "domLayout?": "/** Switch between layout options: `normal`, `autoHeight`, `print`.\n     * @default 'normal'\n     */",
      "ensureDomOrder?": "/** When `true`, the order of rows and columns in the DOM are consistent with what is on screen.\n     * Disables row animations.\n     * @default false\n     * @initial\n     */",
      "enableRtl?": "/** Set to `true` to operate the grid in RTL (Right to Left) mode.\n     * @default false\n     * @initial\n     */",
      "suppressColumnVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the columns. For example, if you have 100 columns, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "suppressMaxRenderedRowRestriction?": "/** By default the grid has a limit of rendering a maximum of 500 rows at once (remember the grid only renders rows you can see, so unless your display shows more than 500 rows without vertically scrolling this will never be an issue).\n     * <br />**This is only relevant if you are manually setting `rowBuffer` to a high value (rendering more rows than can be seen), or `suppressRowVirtualisation` is true, or if your grid height is able to display more than 500 rows at once.**\n     * @default false\n     * @initial\n     */",
      "suppressRowVirtualisation?": "/** Set to `true` so that the grid doesn't virtualise the rows. For example, if you have 100 rows, but only 10 visible due to scrolling, all 100 will always be rendered.\n     * @default false\n     * @initial\n     */",
      "rowDragManaged?": "/** Set to `true` to enable Managed Row Dragging.\n     * @default false\n     */",
      "suppressRowDrag?": "/** Set to `true` to suppress row dragging.\n     * @default false\n     */",
      "suppressMoveWhenRowDragging?": "/** Set to `true` to suppress moving rows while dragging the `rowDrag` waffle. This option highlights the position where the row will be placed and it will only move the row on mouse up.\n     * @default false\n     */",
      "rowDragEntireRow?": "/** Set to `true` to enable clicking and dragging anywhere on the row without the need for a drag handle.\n     * @default false\n     */",
      "rowDragMultiRow?": "/** Set to `true` to enable dragging multiple rows at the same time.\n     * @default false\n     */",
      "rowDragText?": "/** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.\n     * If this callback is not set, the current cell value will be used.\n     * If the `rowDragText` callback is set in the ColDef it will take precedence over this, except when\n     * `rowDragEntireRow=true`.\n     * @initial\n     */",
      "fullWidthCellRenderer?": "/** Provide your own cell renderer component to use for full width rows.\n     * See [Full Width Rows](https://www.ag-grid.com/javascript-data-grid/full-width-rows/) for framework specific implementation details.\n     */",
      "fullWidthCellRendererParams?": "/** Customise the parameters provided to the `fullWidthCellRenderer` component.\n     */",
      "embedFullWidthRows?": "/** Set to `true` to have the Full Width Rows embedded in grid's main container so they can be scrolled horizontally.\n     */",
      "suppressGroupMaintainValueType?": "/** @deprecated v31\n     * When enabled, the grid will cast group values to string type.\n     * @default false\n     * @initial\n     */",
      "groupDisplayType?": "/** Specifies how the results of row grouping should be displayed.\n     *\n     *  The options are:\n     *\n     * - `'singleColumn'`: single group column automatically added by the grid.\n     * - `'multipleColumns'`: a group column per row group is added automatically.\n     * - `'groupRows'`: group rows are automatically added instead of group columns.\n     * - `'custom'`: informs the grid that group columns will be provided.\n     */",
      "groupDefaultExpanded?": "/** If grouping, set to the number of levels to expand by default, e.g. `0` for none, `1` for first level only, etc. Set to `-1` to expand everything.\n     * @default 0\n     */",
      "autoGroupColumnDef?": "/** Allows specifying the group 'auto column' if you are not happy with the default. If grouping, this column definition is included as the first column in the grid. If not grouping, this column is not included.\n     */",
      "groupMaintainOrder?": "/** When `true`, preserves the current group order when sorting on non-group columns.\n     * @default false\n     */",
      "groupSelectsChildren?": "/** When `true`, if you select a group, the children of the group will also be selected.\n     * @default false\n     */",
      "groupLockGroupColumns?": "/** If grouping, locks the group settings of a number of columns, e.g. `0` for no group locking. `1` for first group column locked, `-1` for all group columns locked.\n     * @default 0\n     * @initial\n     */",
      "groupAggFiltering?": "/** Set to determine whether filters should be applied on aggregated group values.\n     * @default false\n     */",
      "groupIncludeFooter?": "/** If grouping, this controls whether to show a group footer when the group is expanded.\n     * If `true`, then by default, the footer will contain aggregate data (if any) when shown and the header will be blank.\n     * When closed, the header will contain the aggregate data regardless of this setting (as the footer is hidden anyway).\n     * This is handy for 'total' rows, that are displayed below the data when the group is open, and alongside the group when it is closed.\n     * If a callback function is provided, it can used to select which groups will have a footer added.\n     * @default false\n     *\n     * @deprecated v31.3 - use `groupTotalRow` instead.\n     */",
      "groupIncludeTotalFooter?": "/** Set to `true` to show a 'grand total' group footer across all groups.\n     * @default false\n     *\n     * @deprecated v31.3 - use `grandTotalRow` instead.\n     */",
      "groupTotalRow?": "/** When provided, an extra row group total row will be inserted into row groups at the specified position, to display\n     * when the group is expanded. This row will contain the aggregate values for the group. If a callback function is\n     * provided, it can be used to selectively determine which groups will have a total row added.\n     */",
      "grandTotalRow?": "/** When provided, an extra grand total row will be inserted into the grid at the specified position.\n     * This row displays the aggregate totals of all rows in the grid.\n     */",
      "suppressStickyTotalRow?": "/** Suppress the sticky behaviour of the total rows, can be suppressed individually by passing `'grand'` or `'group'`.\n     */",
      "groupSuppressBlankHeader?": "/** If `true`, and showing footer, aggregate data will always be displayed at both the header and footer levels. This stops the possibly undesirable behaviour of the header details 'jumping' to the footer on expand.\n     * @default false\n     */",
      "groupSelectsFiltered?": "/** If using `groupSelectsChildren`, then only the children that pass the current filter will get selected.\n     * @default false\n     */",
      "showOpenedGroup?": "/** Shows the open group in the group column for non-group rows.\n     * @default false\n     */",
      "groupRemoveSingleChildren?": "/** Set to `true` to collapse groups that only have one child.\n     * @default false\n     */",
      "groupRemoveLowestSingleChildren?": "/** Set to `true` to collapse lowest level groups that only have one child.\n     * @default false\n     */",
      "groupHideOpenParents?": "/** Set to `true` to hide parents that are open. When used with multiple columns for showing groups, it can give a more pleasing user experience.\n     * @default false\n     */",
      "groupAllowUnbalanced?": "/** Set to `true` to prevent the grid from creating a '(Blanks)' group for nodes which do not belong to a group, and display the unbalanced nodes alongside group nodes.\n     * @default false\n     */",
      "rowGroupPanelShow?": "/** When to show the 'row group panel' (where you drag rows to group) at the top.\n     * @default 'never'\n     */",
      "groupRowRenderer?": "/** Provide the Cell Renderer to use when `groupDisplayType = 'groupRows'`.\n     * See [Group Row Cell Renderer](https://www.ag-grid.com/javascript-data-grid/grouping-group-rows/#providing-cell-renderer) for framework specific implementation details.\n     */",
      "groupRowRendererParams?": "/** Customise the parameters provided to the `groupRowRenderer` component.\n     */",
      "suppressMakeColumnVisibleAfterUnGroup?": "/** By default, when a column is un-grouped, i.e. using the Row Group Panel, it is made visible in the grid. This property stops the column becoming visible again when un-grouping.\n     * @default false\n     */",
      "treeData?": "/** Set to `true` to enable the Grid to work with Tree Data. You must also implement the `getDataPath(data)` callback.\n     * @default false\n     */",
      "rowGroupPanelSuppressSort?": "/** Set to `true` to suppress sort indicators and actions from the row group panel.\n     * @default false\n     * @initial\n     */",
      "suppressGroupRowsSticky?": "/** Set to `true` prevent Group Rows from sticking to the top of the grid.\n     * @default false\n     * @initial\n     */",
      "pinnedTopRowData?": "/** Data to be displayed as pinned top rows in the grid.\n     */",
      "pinnedBottomRowData?": "/** Data to be displayed as pinned bottom rows in the grid.\n     */",
      "rowModelType?": "/** Sets the row model type.\n     * @default 'clientSide'\n     * @initial\n     */",
      "rowData?": "/** Set the data to be displayed as rows in the grid.\n     */",
      "asyncTransactionWaitMillis?": "/** How many milliseconds to wait before executing a batch of async transactions.\n     */",
      "suppressModelUpdateAfterUpdateTransaction?": "/** Prevents Transactions changing sort, filter, group or pivot state when transaction only contains updates.\n     * @default false\n     */",
      "datasource?": "/** Provide the datasource for infinite scrolling.\n     */",
      "cacheOverflowSize?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "infiniteInitialRowCount?": "/** How many extra blank rows to display to the user at the end of the dataset, which sets the vertical scroll and then allows the grid to request viewing more rows of data.\n     * @default 1\n     * @initial\n     */",
      "serverSideInitialRowCount?": "/** Set how many loading rows to display to the user for the root level group.\n     * @default 1\n     * @initial\n     */",
      "suppressServerSideInfiniteScroll?": "/** When `true`, the Server-side Row Model will suppress Infinite Scrolling and load all the data at the current level.\n     * @default false\n     * @initial\n     * @deprecated v31.1\n     */",
      "suppressServerSideFullWidthLoadingRow?": "/** When `true`, the Server-side Row Model will not use a full width loading renderer, instead using the colDef `loadingCellRenderer` if present.\n     */",
      "cacheBlockSize?": "/** How many rows for each block in the store, i.e. how many rows returned from the server at a time.\n     * @default 100\n     */",
      "maxBlocksInCache?": "/** How many blocks to keep in the store. Default is no limit, so every requested block is kept. Use this if you have memory concerns, and blocks that were least recently viewed will be purged when the limit is hit. The grid will additionally make sure it has all the blocks needed to display what is currently visible, in case this property is set to a low value.\n     * @initial\n     */",
      "maxConcurrentDatasourceRequests?": "/** How many requests to hit the server with concurrently. If the max is reached, requests are queued.\n     * Set to `-1` for no maximum restriction on requests.\n     * @default 2\n     * @initial\n     */",
      "blockLoadDebounceMillis?": "/** How many milliseconds to wait before loading a block. Useful when scrolling over many blocks, as it prevents blocks loading until scrolling has settled.\n     * @initial\n     */",
      "purgeClosedRowNodes?": "/** When enabled, closing group rows will remove children of that row. Next time the row is opened, child rows will be read from the datasource again. This property only applies when there is Row Grouping or Tree Data.\n     * @default false\n     */",
      "serverSideDatasource?": "/** Provide the `serverSideDatasource` for server side row model.\n     */",
      "serverSideSortAllLevels?": "/** When enabled, always refreshes top level groups regardless of which column was sorted. This property only applies when there is Row Grouping & sorting is handled on the server.\n     * @default false\n     */",
      "serverSideEnableClientSideSort?": "/** When enabled, sorts fully loaded groups in the browser instead of requesting from the server.\n     * @default false\n     */",
      "serverSideOnlyRefreshFilteredGroups?": "/** When enabled, only refresh groups directly impacted by a filter. This property only applies when there is Row Grouping & filtering is handled on the server.\n     * @default false\n     * @initial\n     */",
      "serverSideSortOnServer?": "/** When enabled, Sorting will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSideFilterOnServer?": "/** When enabled, Filtering will be done on the server. Only applicable when `suppressServerSideInfiniteScroll=true`.\n     * @default false\n     * @deprecated v31.1\n     */",
      "serverSidePivotResultFieldSeparator?": "/** Used to split pivot field strings for generating pivot result columns when `pivotResultFields` is provided as part of a `getRows` success.\n     * @default '_'\n     * @initial\n     */",
      "viewportDatasource?": "/** To use the viewport row model you need to provide the grid with a `viewportDatasource`.\n     */",
      "viewportRowModelPageSize?": "/** When using viewport row model, sets the page size for the viewport.\n     * @initial\n     */",
      "viewportRowModelBufferSize?": "/** When using viewport row model, sets the buffer size for the viewport.\n     * @initial\n     */",
      "alwaysShowHorizontalScroll?": "/** Set to `true` to always show the horizontal scrollbar.\n     * @default false\n     */",
      "alwaysShowVerticalScroll?": "/** Set to `true` to always show the vertical scrollbar.\n     * @default false\n     */",
      "debounceVerticalScrollbar?": "/** Set to `true` to debounce the vertical scrollbar. Can provide smoother scrolling on slow machines.\n     * @default false\n     * @initial\n     */",
      "suppressHorizontalScroll?": "/** Set to `true` to never show the horizontal scroll. This is useful if the grid is aligned with another grid and will scroll when the other grid scrolls. (Should not be used in combination with `alwaysShowHorizontalScroll`.)\n     * @default false\n     */",
      "suppressScrollOnNewData?": "/** When `true`, the grid will not scroll to the top when new row data is provided. Use this if you don't want the default behaviour of scrolling to the top every time you load new data.\n     * @default false\n     */",
      "suppressScrollWhenPopupsAreOpen?": "/** When `true`, the grid will not allow mousewheel / touchpad scroll when popup elements are present.\n     * @default false\n     */",
      "suppressAnimationFrame?": "/** When `true`, the grid will not use animation frames when drawing rows while scrolling. Use this if the grid is working fast enough that you don't need animation frames and you don't want the grid to flicker.\n     * @default false\n     * @initial\n     */",
      "suppressMiddleClickScrolls?": "/** If `true`, middle clicks will result in `click` events for cells and rows. Otherwise the browser will use middle click to scroll the grid.<br />**Note:** Not all browsers fire `click` events with the middle button. Most will fire only `mousedown` and `mouseup` events, which can be used to focus a cell, but will not work to call the `onCellClicked` function.\n     * @default false\n     */",
      "suppressPreventDefaultOnMouseWheel?": "/** If `true`, mouse wheel events will be passed to the browser. Useful if your grid has no vertical scrolls and you want the mouse to scroll the browser page.\n     * @default false\n     * @initial\n     */",
      "scrollbarWidth?": "/** Tell the grid how wide in pixels the scrollbar is, which is used in grid width calculations. Set only if using non-standard browser-provided scrollbars, so the grid can use the non-standard size in its calculations.\n     * @initial\n     */",
      "rowSelection?": "/** Type of Row Selection: `single`, `multiple`.\n     */",
      "rowMultiSelectWithClick?": "/** Set to `true` to allow multiple rows to be selected using single click.\n     * @default false\n     */",
      "suppressRowDeselection?": "/** If `true`, rows will not be deselected if you hold down `Ctrl` and click the row or press `Space`.\n     * @default false\n     */",
      "suppressRowClickSelection?": "/** If `true`, row selection won't happen when rows are clicked. Use when you only want checkbox selection.\n     * @default false\n     */",
      "suppressCellFocus?": "/** If `true`, cells won't be focusable. This means keyboard navigation will be disabled for grid cells, but remain enabled in other elements of the grid such as column headers, floating filters, tool panels.\n     * @default false\n     */",
      "suppressHeaderFocus?": "/** If `true`, header cells won't be focusable. This means keyboard navigation will be disabled for grid header cells, but remain enabled in other elements of the grid such as grid cells and tool panels.\n     * @default false\n     */",
      "suppressMultiRangeSelection?": "/** If `true`, only a single range can be selected.\n     * @default false\n     */",
      "enableCellTextSelection?": "/** Set to `true` to be able to select the text within cells.\n     *\n     * **Note:** When this is set to `true`, the clipboard service is disabled and only selected text is copied.\n     * @default false\n     */",
      "enableRangeSelection?": "/** Set to `true` to enable Range Selection.\n     * @default false\n     */",
      "enableRangeHandle?": "/** Set to `true` to enable the Range Handle.\n     * @default false\n     */",
      "enableFillHandle?": "/** Set to `true` to enable the Fill Handle.\n     * @default false\n     */",
      "fillHandleDirection?": "/** Set to `'x'` to force the fill handle direction to horizontal, or set to `'y'` to force the fill handle direction to vertical.\n     * @default 'xy'\n     */",
      "suppressClearOnFillReduction?": "/** Set this to `true` to prevent cell values from being cleared when the Range Selection is reduced by the Fill Handle.\n     * @default false\n     */",
      "sortingOrder?": "/** Array defining the order in which sorting occurs (if sorting is enabled). Values can be `'asc'`, `'desc'` or `null`. For example: `sortingOrder: ['asc', 'desc']`.\n     * @default [null, 'asc', 'desc']\n     */",
      "accentedSort?": "/** Set to `true` to specify that the sort should take accented characters into account. If this feature is turned on the sort will be slower.\n     * @default false\n     */",
      "unSortIcon?": "/** Set to `true` to show the 'no sort' icon.\n     * @default false\n     */",
      "suppressMultiSort?": "/** Set to `true` to suppress multi-sort when the user shift-clicks a column header.\n     * @default false\n     */",
      "alwaysMultiSort?": "/** Set to `true` to always multi-sort when the user clicks a column header, regardless of key presses.\n     * @default false\n     */",
      "multiSortKey?": "/** Set to `'ctrl'` to have multi sorting work using the `Ctrl` (or `Command ⌘` for Mac) key.\n     */",
      "suppressMaintainUnsortedOrder?": "/** Set to `true` to suppress sorting of un-sorted data to match original row data.\n     * @default false\n     */",
      "icons?": "/** Icons to use inside the grid instead of the grid's default icons.\n     * @initial\n     */",
      "rowHeight?": "/** Default row height in pixels.\n     * @default 25\n     */",
      "rowStyle?": "/** The style properties to apply to all rows. Set to an object of key (style names) and values (style values).\n     */",
      "rowClass?": "/** CSS class(es) for all rows. Provide either a string (class name) or array of strings (array of class names).\n     */",
      "rowClassRules?": "/** Rules which can be applied to include certain CSS classes.\n     */",
      "suppressRowHoverHighlight?": "/** Set to `true` to not highlight rows by adding the `ag-row-hover` CSS class.\n     * @default false\n     */",
      "suppressRowTransform?": "/** Uses CSS `top` instead of CSS `transform` for positioning rows. Useful if the transform function is causing issues such as used in row spanning.\n     * @default false\n     * @initial\n     */",
      "columnHoverHighlight?": "/** Set to `true` to highlight columns by adding the `ag-column-hover` CSS class.\n     * @default false\n     */",
      "gridId?": "/** Provide a custom `gridId` for this instance of the grid. Value will be set on the root DOM node using the attribute `grid-id` as well as being accessible via the `gridApi.getGridId()` method.\n     * @initial\n     */",
      "deltaSort?": "/** When enabled, sorts only the rows added/updated by a transaction.\n     * @default false\n     */",
      "treeDataDisplayType?": "/**/",
      "enableGroupEdit?": "/** @initial\n     */",
      "initialState?": "/** Initial state for the grid. Only read once on initialization. Can be used in conjunction with `api.getState()` to save and restore grid state.\n     * @initial\n     */",
      "reactiveCustomComponents?": "/** **React only**.\n     *\n     * @deprecated As of v32 custom components are created reactively by default.\n     * Set this property to `false` to switch to the legacy way of declaring custom components imperatively.\n     * @initial\n     * @default true\n     */",
      "getContextMenuItems?": "/** For customising the context menu.\n     */",
      "getMainMenuItems?": "/** For customising the main 'column header' menu.\n     * @initial\n     */",
      "postProcessPopup?": "/** Allows user to process popups after they are created. Applications can use this if they want to, for example, reposition the popup.\n     */",
      "processUnpinnedColumns?": "/** Allows the user to process the columns being removed from the pinned section because the viewport is too small to accommodate them.\n     * Returns an array of columns to be removed from the pinned areas.\n     * @initial\n     */",
      "processCellForClipboard?": "/** Allows you to process cells for the clipboard. Handy if for example you have `Date` objects that need to have a particular format if importing into Excel.\n     */",
      "processHeaderForClipboard?": "/** Allows you to process header values for the clipboard.\n     */",
      "processGroupHeaderForClipboard?": "/** Allows you to process group header values for the clipboard.\n     */",
      "processCellFromClipboard?": "/** Allows you to process cells from the clipboard. Handy if for example you have number fields, and want to block non-numbers from getting into the grid.\n     */",
      "sendToClipboard?": "/** Allows you to get the data that would otherwise go to the clipboard. To be used when you want to control the 'copy to clipboard' operation yourself.\n     */",
      "processDataFromClipboard?": "/** Allows complete control of the paste operation, including cancelling the operation (so nothing happens) or replacing the data with other data.\n     */",
      "isExternalFilterPresent?": "/** Grid calls this method to know if an external filter is present.\n     */",
      "doesExternalFilterPass?": "/** Should return `true` if external filter passes, otherwise `false`.\n     */",
      "getChartToolbarItems?": "/** Callback to be used to customise the chart toolbar items.\n     * @initial\n     */",
      "createChartContainer?": "/** Callback to enable displaying the chart in an alternative chart container.\n     * @initial\n     */",
      "focusGridInnerElement?": "/** Allows overriding the element that will be focused when the grid receives focus from outside elements (tabbing into the grid).\n     * @returns `True` if this function should override the grid's default behavior, `False` to allow the grid's default behavior.\n     */",
      "navigateToNextHeader?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a header is focused. Return the next Header position to navigate to or `null` to stay on current header.\n     */",
      "tabToNextHeader?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a header is focused.\n     * Return the next header position to navigate to, `true` to stay on the current header,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "navigateToNextCell?": "/** Allows overriding the default behaviour for when user hits navigation (arrow) key when a cell is focused. Return the next Cell position to navigate to or `null` to stay on current cell.\n     */",
      "tabToNextCell?": "/** Allows overriding the default behaviour for when user hits `Tab` key when a cell is focused.\n     * Return the next cell position to navigate to, `true` to stay on the current cell,\n     * or `false` to let the browser handle the tab behaviour.\n     * As of v31.3, returning `null` is deprecated.\n     */",
      "getLocaleText?": "/** A callback for localising text within the grid.\n     * @initial\n     */",
      "getDocument?": "/** Allows overriding what `document` is used. Currently used by Drag and Drop (may extend to other places in the future). Use this when you want the grid to use a different `document` than the one available on the global scope. This can happen if docking out components (something which Electron supports)\n     */",
      "paginationNumberFormatter?": "/** Allows user to format the numbers in the pagination panel, i.e. 'row count' and 'page number' labels. This is for pagination panel only, to format numbers inside the grid's cells (i.e. your data), then use `valueFormatter` in the column definitions.\n     * @initial\n     */",
      "getGroupRowAgg?": "/** Callback to use when you need access to more then the current column for aggregation.\n     */",
      "isGroupOpenByDefault?": "/** (Client-side Row Model only) Allows groups to be open by default.\n     */",
      "initialGroupOrderComparator?": "/** Allows default sorting of groups.\n     */",
      "processPivotResultColDef?": "/** Callback to be used with pivoting, to allow changing the second column definition.\n     */",
      "processPivotResultColGroupDef?": "/** Callback to be used with pivoting, to allow changing the second column group definition.\n     */",
      "getDataPath?": "/** Callback to be used when working with Tree Data when `treeData = true`.\n     */",
      "getChildCount?": "/** Allows setting the child count for a group row.\n     * @initial\n     */",
      "getServerSideGroupLevelParams?": "/** Allows providing different params for different levels of grouping.\n     * @initial\n     */",
      "isServerSideGroupOpenByDefault?": "/** Allows groups to be open by default.\n     */",
      "isApplyServerSideTransaction?": "/** Allows cancelling transactions.\n     */",
      "isServerSideGroup?": "/** SSRM Tree Data: Allows specifying which rows are expandable.\n     */",
      "getServerSideGroupKey?": "/** SSRM Tree Data: Allows specifying group keys.\n     */",
      "getBusinessKeyForNode?": "/** Return a business key for the node. If implemented, each row in the DOM will have an attribute `row-business-key='abc'` where `abc` is what you return as the business key.\n     * This is useful for automated testing, as it provides a way for your tool to identify rows based on unique business keys.\n     */",
      "getRowId?": "/** Allows setting the ID for a particular row node based on the data.\n     * @initial\n     */",
      "resetRowDataOnUpdate?": "/** When enabled, getRowId() callback is implemented and new Row Data is set, the grid will disregard all previous rows and treat the new Row Data as new data. As a consequence, all Row State (eg selection, rendered rows) will be reset.\n     * @default false\n     */",
      "processRowPostCreate?": "/** Callback fired after the row is rendered into the DOM. Should not be used to initiate side effects.\n     */",
      "isRowSelectable?": "/** Callback to be used to determine which rows are selectable. By default rows are selectable, so return `false` to make a row un-selectable.\n     */",
      "isRowMaster?": "/** Callback to be used with Master Detail to determine if a row should be a master row. If `false` is returned no detail row will exist for this row.\n     */",
      "fillOperation?": "/** Callback to fill values instead of simply copying values or increasing number values using linear progression.\n     */",
      "postSortRows?": "/** Callback to perform additional sorting after the grid has sorted the rows.\n     */",
      "getRowStyle?": "/** Callback version of property `rowStyle` to set style for each row individually. Function should return an object of CSS values or undefined for no styles.\n     */",
      "getRowClass?": "/** Callback version of property `rowClass` to set class(es) for each row individually. Function should return either a string (class name), array of strings (array of class names) or undefined for no class.\n     */",
      "getRowHeight?": "/** Callback version of property `rowHeight` to set height for each row individually. Function should return a positive number of pixels, or return `null`/`undefined` to use the default row height.\n     */",
      "isFullWidthRow?": "/** Tells the grid if this row should be rendered as full width.\n     */",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent<TData>)": "/** The tool panel visibility has changed. Fires twice if switching between panels - once with the old panel and once with the new panel.\n     */",
      "onToolPanelSizeChanged?(event: ToolPanelSizeChangedEvent<TData>)": "/** The tool panel size has been changed.\n     */",
      "onColumnMenuVisibleChanged?(event: ColumnMenuVisibleChangedEvent<TData>)": "/** The column menu visibility has changed. Fires twice if switching between tabs - once with the old tab and once with the new tab.\n     */",
      "onContextMenuVisibleChanged?(event: ContextMenuVisibleChangedEvent<TData>)": "/** The context menu visibility has changed (opened or closed).\n     */",
      "onCutStart?(event: CutStartEvent<TData>)": "/** Cut operation has started.\n     */",
      "onCutEnd?(event: CutEndEvent<TData>)": "/** Cut operation has ended.\n     */",
      "onPasteStart?(event: PasteStartEvent<TData>)": "/** Paste operation has started.\n     */",
      "onPasteEnd?(event: PasteEndEvent<TData>)": "/** Paste operation has ended.\n     */",
      "onColumnVisible?(event: ColumnVisibleEvent<TData>)": "/** A column, or group of columns, was hidden / shown.\n     */",
      "onColumnPinned?(event: ColumnPinnedEvent<TData>)": "/** A column, or group of columns, was pinned / unpinned.\n     */",
      "onColumnResized?(event: ColumnResizedEvent<TData>)": "/** A column was resized.\n     */",
      "onColumnMoved?(event: ColumnMovedEvent<TData>)": "/** A column was moved.\n     */",
      "onColumnValueChanged?(event: ColumnValueChangedEvent<TData>)": "/** A value column was added or removed.\n     */",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent<TData>)": "/** The pivot mode flag was changed.\n     */",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent<TData>)": "/** A pivot column was added, removed or order changed.\n     */",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent<TData>)": "/** A column group was opened / closed.\n     */",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent<TData>)": "/** User set new columns.\n     */",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent<TData>)": "/** The list of grid columns changed.\n     */",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent<TData>)": "/** The list of displayed columns changed. This can result from columns open / close, column move, pivot, group, etc.\n     */",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent<TData>)": "/** The list of rendered columns changed (only columns in the visible scrolled viewport are rendered by default).\n     */",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent<TData>)": "/** Shotgun - gets called when either a) new columns are set or b) `api.applyColumnState()` is used, so everything has changed.\n     */",
      "onColumnHeaderMouseOver?(event: ColumnHeaderMouseOverEvent<TData>)": "/** A mouse cursor is initially moved over a column header.\n     */",
      "onColumnHeaderMouseLeave?(event: ColumnHeaderMouseLeaveEvent<TData>)": "/** A mouse cursor is moved out of a column header.\n     */",
      "onColumnHeaderClicked?(event: ColumnHeaderClickedEvent<TData>)": "/** A click is performed on a column header.\n     */",
      "onColumnHeaderContextMenu?(event: ColumnHeaderContextMenuEvent<TData>)": "/** A context menu action, such as right-click or context menu key press, is performed on a column header.\n     */",
      "onComponentStateChanged?(event: ComponentStateChangedEvent<TData>)": "/** Only used by Angular, React and VueJS AG Grid components (not used if doing plain JavaScript).\n     * If the grid receives changes due to bound properties, this event fires after the grid has finished processing the change.\n     */",
      "onCellValueChanged?(event: CellValueChangedEvent<TData>)": "/** Value has changed after editing (this event will not fire if editing was cancelled, eg ESC was pressed) or\n     *  if cell value has changed as a result of cut, paste, cell clear (pressing Delete key),\n     * fill handle, copy range down, undo and redo.\n     */",
      "onCellEditRequest?(event: CellEditRequestEvent<TData>)": "/** Value has changed after editing. Only fires when `readOnlyEdit=true`.\n     */",
      "onRowValueChanged?(event: RowValueChangedEvent<TData>)": "/** A cell's value within a row has changed. This event corresponds to Full Row Editing only.\n     */",
      "onCellEditingStarted?(event: CellEditingStartedEvent<TData>)": "/** Editing a cell has started.\n     */",
      "onCellEditingStopped?(event: CellEditingStoppedEvent<TData>)": "/** Editing a cell has stopped.\n     */",
      "onRowEditingStarted?(event: RowEditingStartedEvent<TData>)": "/** Editing a row has started (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStarted` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onRowEditingStopped?(event: RowEditingStoppedEvent<TData>)": "/** Editing a row has stopped (when row editing is enabled). When row editing, this event will be fired once and `cellEditingStopped` will be fired for each individual cell. Only fires when doing Full Row Editing.\n     */",
      "onUndoStarted?(event: UndoStartedEvent<TData>)": "/** Undo operation has started.\n     */",
      "onUndoEnded?(event: UndoEndedEvent<TData>)": "/** Undo operation has ended.\n     */",
      "onRedoStarted?(event: RedoStartedEvent<TData>)": "/** Redo operation has started.\n     */",
      "onRedoEnded?(event: RedoEndedEvent<TData>)": "/** Redo operation has ended.\n     */",
      "onRangeDeleteStart?(event: RangeDeleteStartEvent<TData>)": "/** Range delete operation (cell clear) has started.\n     */",
      "onRangeDeleteEnd?(event: RangeDeleteEndEvent<TData>)": "/** Range delete operation (cell clear) has ended.\n     */",
      "onFillStart?(event: FillStartEvent<TData>)": "/** Fill operation has started.\n     */",
      "onFillEnd?(event: FillEndEvent<TData>)": "/** Fill operation has ended.\n     */",
      "onFilterOpened?(event: FilterOpenedEvent<TData>)": "/** Filter has been opened.\n     */",
      "onFilterChanged?(event: FilterChangedEvent<TData>)": "/** Filter has been modified and applied.\n     */",
      "onFilterModified?(event: FilterModifiedEvent<TData>)": "/** Filter was modified but not applied. Used when filters have 'Apply' buttons.\n     */",
      "onAdvancedFilterBuilderVisibleChanged?(event: AdvancedFilterBuilderVisibleChangedEvent<TData>)": "/** Advanced Filter Builder visibility has changed (opened or closed).\n     */",
      "onChartCreated?(event: ChartCreatedEvent<TData>)": "/** A chart has been created.\n     */",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChangedEvent<TData>)": "/** The data range for the chart has been changed.\n     */",
      "onChartOptionsChanged?(event: ChartOptionsChangedEvent<TData>)": "/** Formatting changes have been made by users through the Customize Panel.\n     */",
      "onChartDestroyed?(event: ChartDestroyedEvent<TData>)": "/** A chart has been destroyed.\n     */",
      "onCellKeyDown?(event: CellKeyDownEvent<TData> | FullWidthCellKeyDownEvent<TData>)": "/** DOM event `keyDown` happened on a cell.\n     */",
      "onGridReady?(event: GridReadyEvent<TData>)": "/** The grid has initialised and is ready for most api calls, but may not be fully rendered yet  */",
      "onGridPreDestroyed?(event: GridPreDestroyedEvent<TData>)": "/** Invoked immediately before the grid is destroyed. This is useful for cleanup logic that needs to run before the grid is torn down.\n     */",
      "onFirstDataRendered?(event: FirstDataRenderedEvent<TData>)": "/** Fired the first time data is rendered into the grid. Use this event if you want to auto resize columns based on their contents */",
      "onGridSizeChanged?(event: GridSizeChangedEvent<TData>)": "/** The size of the grid `div` has changed. In other words, the grid was resized.\n     */",
      "onModelUpdated?(event: ModelUpdatedEvent<TData>)": "/** Displayed rows have changed. Triggered after sort, filter or tree expand / collapse events.\n     */",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent<TData>)": "/** A row was removed from the DOM, for any reason. Use to clean up resources (if any) used by the row.\n     */",
      "onViewportChanged?(event: ViewportChangedEvent<TData>)": "/** Which rows are rendered in the DOM has changed.\n     */",
      "onBodyScroll?(event: BodyScrollEvent<TData>)": "/** The body was scrolled horizontally or vertically.\n     */",
      "onBodyScrollEnd?(event: BodyScrollEndEvent<TData>)": "/** Main body of the grid has stopped scrolling, either horizontally or vertically.\n     */",
      "onDragStarted?(event: DragStartedEvent<TData>)": "/** When dragging starts. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onDragStopped?(event: DragStoppedEvent<TData>)": "/** When dragging stops. This could be any action that uses the grid's Drag and Drop service, e.g. Column Moving, Column Resizing, Range Selection, Fill Handle, etc.\n     */",
      "onStateUpdated?(event: StateUpdatedEvent<TData>)": "/** Grid state has been updated.\n     */",
      "onPaginationChanged?(event: PaginationChangedEvent<TData>)": "/** Triggered every time the paging state changes. Some of the most common scenarios for this event to be triggered are:\n     *\n     *  - The page size changes.\n     *  - The current shown page is changed.\n     *  - New data is loaded onto the grid.\n     */",
      "onRowDragEnter?(event: RowDragEnterEvent<TData>)": "/** A drag has started, or dragging was already started and the mouse has re-entered the grid having previously left the grid.\n     */",
      "onRowDragMove?(event: RowDragMoveEvent<TData>)": "/** The mouse has moved while dragging.\n     */",
      "onRowDragLeave?(event: RowDragLeaveEvent<TData>)": "/** The mouse has left the grid while dragging.\n     */",
      "onRowDragEnd?(event: RowDragEndEvent<TData>)": "/** The drag has finished over the grid.\n     */",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent<TData>)": "/** A row group column was added, removed or reordered.\n     */",
      "onRowGroupOpened?(event: RowGroupOpenedEvent<TData>)": "/** A row group was opened or closed.\n     */",
      "onExpandOrCollapseAll?(event: ExpandOrCollapseAllEvent<TData>)": "/** Fired when calling either of the API methods `expandAll()` or `collapseAll()`.\n     */",
      "onPivotMaxColumnsExceeded?(event: PivotMaxColumnsExceededEvent<TData>)": "/** Exceeded the `pivotMaxGeneratedColumns` limit when generating columns.\n     */",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent<TData>)": "/** The client has set new pinned row data into the grid.\n     */",
      "onRowDataUpdated?(event: RowDataUpdatedEvent<TData>)": "/** Client-Side Row Model only. The client has updated data for the grid by either a) setting new Row Data or b) Applying a Row Transaction.\n     */",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed<TData>)": "/** Async transactions have been applied. Contains a list of all transaction results.\n     */",
      "onStoreRefreshed?(event: StoreRefreshedEvent<TData>)": "/** A server side store has finished refreshing.\n     */",
      "onHeaderFocused?(event: HeaderFocusedEvent<TData>)": "/** Header is focused.\n     */",
      "onCellClicked?(event: CellClickedEvent<TData>)": "/** Cell is clicked.\n     */",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent<TData>)": "/** Cell is double clicked.\n     */",
      "onCellFocused?(event: CellFocusedEvent<TData>)": "/** Cell is focused.\n     */",
      "onCellMouseOver?(event: CellMouseOverEvent<TData>)": "/** Mouse entered cell.\n     */",
      "onCellMouseOut?(event: CellMouseOutEvent<TData>)": "/** Mouse left cell.\n     */",
      "onCellMouseDown?(event: CellMouseDownEvent<TData>)": "/** Mouse down on cell.\n     */",
      "onRowClicked?(event: RowClickedEvent<TData>)": "/** Row is clicked.\n     */",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent<TData>)": "/** Row is double clicked.\n     */",
      "onRowSelected?(event: RowSelectedEvent<TData>)": "/** Row is selected or deselected. The event contains the node in question, so call the node's `isSelected()` method to see if it was just selected or deselected.\n     */",
      "onSelectionChanged?(event: SelectionChangedEvent<TData>)": "/** Row selection is changed. Use the grid API `getSelectedNodes()` or `getSelectedRows()` to get the new list of selected nodes / row data.\n     */",
      "onCellContextMenu?(event: CellContextMenuEvent<TData>)": "/** Cell is right clicked.\n     */",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent<TData>)": "/** A change to range selection has occurred.\n     */",
      "onTooltipShow?(event?: TooltipShowEvent<TData>)": "/** A tooltip has been displayed */",
      "onTooltipHide?(event?: TooltipHideEvent<TData>)": "/** A tooltip was hidden */",
      "onSortChanged?(event: SortChangedEvent<TData>)": "/** Sort has changed. The grid also listens for this and updates the model.\n     */",
      "api?": "/** @deprecated Since v31 api is no longer attached to GridOptions. See https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api for how to access the api in your framework.\n     */"
    }
  },
  "AgReactComponent": {
    "meta": {},
    "type": {
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IHeaderGroupReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IHeaderGroup` instead. */"
    },
    "type": {
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IHeaderReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IHeader` instead. */"
    },
    "type": {
      "refresh(params: IHeaderParams)": "boolean",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "refresh(params: IHeaderParams)": "/** Get the header to refresh. Gets called whenever Column Defs are updated. */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IDateReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IDate` instead. */"
    },
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "onParamsUpdated?(params: IDateParams)": "void",
      "refresh?(params: IDateParams)": "void",
      "setDisabled?(disabled: boolean)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getDate()": "/** Returns the current date represented by this component */",
      "setDate(date: Date | null)": "/** Sets the date represented by this component */",
      "onParamsUpdated?(params: IDateParams)": "/** @deprecated v31.1 - Use `refresh` instead. */",
      "refresh?(params: IDateParams)": "/** When used in a floating filter, a hook to perform any necessary operations\n     * when the column definition is updated.\n     */",
      "setDisabled?(disabled: boolean)": "/** Optional: Sets the disabled state of this component */",
      "setInputPlaceholder?(placeholder: string)": "/** Optional: Sets the current input placeholder */",
      "setInputAriaLabel?(placeholder: string)": "/** Optional: Sets the current input aria label */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after\n     * the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters),\n     * this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing,\n     * such as putting focus on a particular DOM element.\n     */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IFilterReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IFilter` instead. */"
    },
    "type": {
      "isFilterActive()": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "refresh?(newParams: IFilterParams)": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getModelAsString?(model: any)": "string",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "afterGuiDetached?()": "void",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "isFilterActive()": "/** Returns `true` if the filter is currently active, otherwise `false`.\n     * If active then 1) the grid will show the filter icon in the column header\n     * and 2) the filter will be included in the filtering of the data.\n     */",
      "getModel()": "/** Returns a model representing the current state of the filter, or `null` if the filter is\n     * not active. The grid calls `getModel()` on all active filters when `gridApi.getFilterModel()` is called.\n     */",
      "setModel(model: any)": "/** Sets the state of the filter using the supplied model. Providing `null` as the model will\n     * de-activate the filter.\n     */",
      "refresh?(newParams: IFilterParams)": "/** This method is called when the filter parameters change.\n     * The result returned by this method will determine if the filter should be refreshed and reused,\n     * or if a new filter instance should be created.\n     *\n     * This method should return `true` if the filter should be refreshed and reused instead of being destroyed.\n     * This is useful if the new params passed are compatible with the existing filter instance.\n     *\n     * When `false` is returned, the existing filter will be destroyed and a new filter will be created.\n     * This should be done if the new params passed are not compatible with the existing filter instance.\n     *\n     * @param newParams {IFilterParams} - New filter params.\n     *\n     * @returns {boolean} - `true` means that the filter should be refreshed and kept.\n     * `false` means that the filter will be destroyed and a new filter instance will be created.\n     */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n     * filter fails, then the row will be excluded from the final set. The method is provided a\n     * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n     * (the data object that you provided to the grid for that row). Note that this is only called for the\n     * Client-Side Row Model, and can just return `true` if being used exclusively with other row models.\n     */",
      "onNewRowsLoaded?()": "/** Optional: Gets called when new rows are inserted into the grid. If the filter needs to change its\n     * state after rows are loaded, it can do it here. For example the set filters uses this\n     * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n     * Country filter). To get the list of available values from within this method from the\n     * Client Side Row Model, use `gridApi.forEachLeafNode(callback)`.\n     */",
      "onAnyFilterChanged?()": "/** Optional: Called whenever any filter is changed. */",
      "getModelAsString?(model: any)": "/** Optional: Used by AG Grid when rendering floating filters and there isn't a floating filter\n     * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n     * filter.\n     */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "afterGuiDetached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been removed from the screen.\n     * If a parent popup is opened and closed (e.g. for filters), this method is called each time the component is hidden.\n     * This is useful for any logic to reset the UI state back to the model before the component is reopened.\n     */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IFloatingFilterReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IFloatingFilter` instead. */"
    },
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "void",
      "refresh?(params: IFloatingFilterParams<P>)": "void",
      "afterGuiAttached?()": "void",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "/** Gets called every time the parent filter changes.\n     * Your floating filter would typically refresh its UI to reflect the new filter state.\n     * The provided parentModel is what the parent filter returns from its getModel() method.\n     * The event is the FilterChangedEvent that the grid fires.\n     */",
      "onParamsUpdated?(params: IFloatingFilterParams<P>)": "/** @deprecated v31.1 - Use `refresh` instead */",
      "refresh?(params: IFloatingFilterParams<P>)": "/** A hook to perform any necessary operations when the column definition is updated. */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "ICellRendererReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `ICellRenderer` instead. */"
    },
    "type": {
      "refresh(params: ICellRendererParams<TData>)": "boolean",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "refresh(params: ICellRendererParams<TData>)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n     * then the grid will refresh the cell for you.\n     */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "ICellEditorReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `ICellEditor` instead. */"
    },
    "type": {
      "getValue()": "TValue | null | undefined",
      "refresh?(params: ICellEditorParams<any, TValue>)": "void",
      "afterGuiAttached?()": "void",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "'over' | 'under' | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getValue()": "/** Return the final value - called by the grid once after editing is complete\n     */",
      "refresh?(params: ICellEditorParams<any, TValue>)": "/** Optional: Gets called with the latest cell editor params every time they update\n     */",
      "afterGuiAttached?()": "/** Optional: A hook to perform any necessary operation just after the GUI for this component has been rendered on the screen.\n     * This method is called each time the edit component is activated.\n     * This is useful for any logic that requires attachment before executing, such as putting focus on a particular DOM element.\n     */",
      "isPopup?()": "/** Optional: Gets called once after initialised. If you return true, the editor will\n     * appear in a popup, so is not constrained to the boundaries of the cell.\n     * This is great if you want to, for example, provide you own custom dropdown list\n     * for selection. Default is false (ie if you don't provide the method).\n     */",
      "getPopupPosition?()": "/** Optional: Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n     * should cover the cell, or \"under\" if it should be positioned below leaving the\n     * cell value visible. If this method is not present, the default is \"over\".\n     */",
      "isCancelBeforeStart?()": "/** Optional: Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */",
      "isCancelAfterEnd?()": "/** Optional: Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */",
      "focusIn?()": "/** Optional: If doing full line edit, then gets called when focus should be put into the editor\n     */",
      "focusOut?()": "/** Optional: If doing full line edit, then gets called when focus is leaving the editor\n     */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "ILoadingCellRendererReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 No interface required. */"
    },
    "type": {
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "ILoadingOverlayReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `ILoadingOverlay` instead. */"
    },
    "type": {
      "refresh?(params: TParams)": "void",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "INoRowsOverlayReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `INoRowsOverlay` instead. */"
    },
    "type": {
      "refresh?(params: TParams)": "void",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IStatusPanelReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IStatusPanel` instead. */"
    },
    "type": {
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "boolean",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "refresh?(params: IStatusPanelParams<TData, TContext>)": "/** Called when the `statusBar` grid option is updated.\n     * If this method returns `true`,\n     * the grid assumes that the status panel has updated with the latest params,\n     * and takes no further action.\n     * If this method returns `false`, or is not implemented,\n     * the grid will destroy and recreate the status panel.\n     */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "IToolPanelReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 Use `IToolPanel` instead. */"
    },
    "type": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "boolean | void",
      "getState?()": "TState | undefined",
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "refresh(params: IToolPanelParams<TData, TContext, TState>)": "/** Called when `api.refreshToolPanel()` is called (with the current params).\n     * Also called when the `sideBar` grid option is updated (with the updated params).\n     * When `sideBar` is updated, if this method returns `true`,\n     * then the grid will take no further action.\n     * Otherwise, the tool panel will be destroyed and recreated.\n     */",
      "getState?()": "/** If saving and restoring state, this should return the current state */",
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  },
  "ITooltipReactComp": {
    "meta": {
      "doc": "/** @deprecated v31.1 No interface required. */"
    },
    "type": {
      "getReactContainerStyle?": "() => object",
      "getReactContainerClasses?": "() => string[]"
    },
    "docs": {
      "getReactContainerStyle?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */",
      "getReactContainerClasses?": "/** @deprecated v31.1 Apply styling directly to `.ag-react-container` if needed */"
    }
  }
}