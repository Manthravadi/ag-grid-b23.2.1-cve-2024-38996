import type { Part } from '@ag-grid-community/theming';
import * as themes from '@ag-grid-community/theming';
import { atom, useAtom } from 'jotai';

import type { PersistentAtom } from './JSONStorage';
import { atomWithJSONStorage } from './JSONStorage';
import { memoize, titleCase } from './utils';

const variantsByPartId: Record<string, Part<any>[] | undefined> = {
    colorScheme: [
        themes.colorSchemeLightCold,
        themes.colorSchemeLightNeutral,
        themes.colorSchemeLightWarm,
        themes.colorSchemeDarkBlue,
        themes.colorSchemeDarkNeutral,
        themes.colorSchemeDarkWarm,
    ],
    iconSet: [
        themes.iconSetAlpine,
        themes.iconSetMaterial,
        themes.iconSetQuartzLight,
        themes.iconSetQuartzRegular,
        themes.iconSetQuartzBold,
    ],
    tabStyle: [themes.tabStyleQuartz, themes.tabStyleAlpine, themes.tabStyleMaterial, themes.tabStyleRolodex],
    inputStyle: [themes.inputStyleBordered, themes.inputStyleUnderlined],
};

export const getVariantsByPartId = (partId: string) => variantsByPartId[partId];

const featureModels: Record<string, PartModel> = {};

const partDocs: Record<string, string | undefined> = {
    tabStyle: 'The appearance of tabs in chart settings and legacy column menu',
    inputStyle: 'The appearance of text input fields',
};

const defaultVariantIds = new Set(themes.themeQuartz.dependencies.map((dep) => dep.id));

export class PartModel {
    readonly label: string;
    readonly docs: string | null;
    readonly variants: VariantModel[];
    readonly defaultVariant: VariantModel;
    readonly variantAtom: PersistentAtom<VariantModel>;

    private constructor(readonly partId: string) {
        this.label = titleCase(partId);
        this.docs = partDocs[partId] || null;
        const variants = variantsByPartId[partId];
        if (!variants) throw new Error(`Invalid partId "${partId}"`);
        this.variants = variants.map((part) => new VariantModel(this, part));
        this.defaultVariant = this.variants.find((v) => defaultVariantIds.has(v.id)) || this.variants[0];
        this.variantAtom = createFeatureAtom(this);
    }

    static for(partID: string) {
        return featureModels[partID] || (featureModels[partID] = new PartModel(partID));
    }
}

export const useSelectedVariant = (part: PartModel) => useAtom(part.variantAtom);

const createFeatureAtom = (part: PartModel) => {
    const backingAtom = atomWithJSONStorage<string | null>(`part-variant.${part.partId}`, null);
    return atom(
        (get) => {
            const variantId = get(backingAtom);
            return part.variants.find((v) => v.id === variantId) || part.defaultVariant;
        },
        (_get, set, newVariant: VariantModel) => set(backingAtom, newVariant.id)
    );
};

export class VariantModel {
    readonly label: string;
    readonly id: string;
    readonly variant: string;

    constructor(
        readonly part: PartModel,
        // TODO once PartModel is renamed GroupModel, name this `part`
        readonly _part: Part<any>
    ) {
        this.label = titleCase(_part.variant);
        this.variant = _part.variant;
        this.id = _part.id;
    }
}

const allPartIds = ['colorScheme', 'iconSet', 'tabStyle', 'inputStyle'];

export const allPartModels = memoize(() => allPartIds.map((partId) => PartModel.for(partId)));
