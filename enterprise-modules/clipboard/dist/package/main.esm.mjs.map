{
  "version": 3,
  "sources": ["../../src/clipboardModule.ts", "../../src/clipboard/clipboardApi.ts", "../../src/clipboard/clipboardService.ts", "../../src/version.ts"],
  "sourcesContent": ["import type { Module } from '@ag-grid-community/core';\nimport { ModuleNames } from '@ag-grid-community/core';\nimport { CsvExportModule } from '@ag-grid-community/csv-export';\nimport { EnterpriseCoreModule } from '@ag-grid-enterprise/core';\n\nimport {\n    copySelectedRangeDown,\n    copySelectedRangeToClipboard,\n    copySelectedRowsToClipboard,\n    copyToClipboard,\n    cutToClipboard,\n    pasteFromClipboard,\n} from './clipboard/clipboardApi';\nimport { ClipboardService } from './clipboard/clipboardService';\nimport { VERSION } from './version';\n\nexport const ClipboardCoreModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.ClipboardModule}-core`,\n    beans: [ClipboardService],\n    dependantModules: [EnterpriseCoreModule, CsvExportModule],\n};\n\nexport const ClipboardApiModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.ClipboardModule}-api`,\n    apiFunctions: {\n        copyToClipboard,\n        cutToClipboard,\n        copySelectedRowsToClipboard,\n        copySelectedRangeToClipboard,\n        copySelectedRangeDown,\n        pasteFromClipboard,\n    },\n    dependantModules: [ClipboardCoreModule],\n};\n\nexport const ClipboardModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.ClipboardModule,\n    dependantModules: [ClipboardCoreModule, ClipboardApiModule],\n};\n", "import type { BeanCollection, IClipboardCopyParams, IClipboardCopyRowsParams } from '@ag-grid-community/core';\n\nexport function copyToClipboard(beans: BeanCollection, params?: IClipboardCopyParams) {\n    beans.clipboardService?.copyToClipboard(params);\n}\n\nexport function cutToClipboard(beans: BeanCollection, params?: IClipboardCopyParams) {\n    beans.clipboardService?.cutToClipboard(params);\n}\n\nexport function copySelectedRowsToClipboard(beans: BeanCollection, params?: IClipboardCopyRowsParams): void {\n    beans.clipboardService?.copySelectedRowsToClipboard(params);\n}\n\nexport function copySelectedRangeToClipboard(beans: BeanCollection, params?: IClipboardCopyParams): void {\n    beans.clipboardService?.copySelectedRangeToClipboard(params);\n}\n\nexport function copySelectedRangeDown(beans: BeanCollection): void {\n    beans.clipboardService?.copyRangeDown();\n}\n\nexport function pasteFromClipboard(beans: BeanCollection): void {\n    beans.clipboardService?.pasteFromClipboard();\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    CellNavigationService,\n    CellPosition,\n    CellPositionUtils,\n    CellRange,\n    CsvExportParams,\n    CtrlsService,\n    CutEndEvent,\n    CutStartEvent,\n    FlashCellsEvent,\n    FocusService,\n    FuncColsService,\n    GridCtrl,\n    IClientSideRowModel,\n    IClipboardCopyParams,\n    IClipboardCopyRowsParams,\n    IClipboardService,\n    ICsvCreator,\n    IRangeService,\n    IRowModel,\n    ISelectionService,\n    NamedBean,\n    PasteEndEvent,\n    PasteStartEvent,\n    ProcessCellForExportParams,\n    ProcessRowGroupForExportParams,\n    RowNode,\n    RowPosition,\n    RowPositionUtils,\n    RowRenderer,\n    RowValueChangedEvent,\n    ValueService,\n    VisibleColsService,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, ChangedPath, _exists, _last, _removeFromArray, _warnOnce } from '@ag-grid-community/core';\n\ninterface RowCallback {\n    (\n        gridRow: RowPosition,\n        rowNode: RowNode | undefined,\n        columns: AgColumn[],\n        rangeIndex: number,\n        isLastRow?: boolean\n    ): void;\n}\n\ninterface ColumnCallback {\n    (columns: AgColumn[]): void;\n}\n\ntype CellsToFlashType = { [key: string]: boolean };\ntype DataForCellRangesType = { data: string; cellsToFlash: CellsToFlashType };\n\n// Matches value in changeDetectionService\nconst SOURCE_PASTE = 'paste';\nconst EXPORT_TYPE_DRAG_COPY = 'dragCopy';\nconst EXPORT_TYPE_CLIPBOARD = 'clipboard';\n\nenum CellClearType {\n    CellRange,\n    SelectedRows,\n    FocusedCell,\n}\n\nconst apiError = (method: string) =>\n    `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). ` +\n    'The reason why it could not be used has been logged in the previous line. ' +\n    \"For this reason the grid has defaulted to using a workaround which doesn't perform as well. \" +\n    'Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid ' +\n    'property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.';\n\nexport class ClipboardService extends BeanStub implements NamedBean, IClipboardService {\n    beanName = 'clipboardService' as const;\n\n    private csvCreator: ICsvCreator;\n    private selectionService: ISelectionService;\n    private rowModel: IRowModel;\n    private ctrlsService: CtrlsService;\n    private valueService: ValueService;\n    private focusService: FocusService;\n    private rowRenderer: RowRenderer;\n    private visibleColsService: VisibleColsService;\n    private funcColsService: FuncColsService;\n    private cellNavigationService: CellNavigationService;\n    private cellPositionUtils: CellPositionUtils;\n    public rowPositionUtils: RowPositionUtils;\n    private rangeService?: IRangeService;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.csvCreator = beans.csvCreator!;\n        this.selectionService = beans.selectionService;\n        this.rowModel = beans.rowModel;\n        this.ctrlsService = beans.ctrlsService;\n        this.valueService = beans.valueService;\n        this.focusService = beans.focusService;\n        this.rowRenderer = beans.rowRenderer;\n        this.visibleColsService = beans.visibleColsService;\n        this.funcColsService = beans.funcColsService;\n        this.cellNavigationService = beans.cellNavigationService;\n        this.cellPositionUtils = beans.cellPositionUtils;\n        this.rowPositionUtils = beans.rowPositionUtils;\n        this.rangeService = beans.rangeService;\n    }\n\n    private clientSideRowModel: IClientSideRowModel;\n    private gridCtrl: GridCtrl;\n    private lastPasteOperationTime: number = 0;\n\n    private navigatorApiFailed = false;\n\n    public postConstruct(): void {\n        if (this.rowModel.getType() === 'clientSide') {\n            this.clientSideRowModel = this.rowModel as IClientSideRowModel;\n        }\n\n        this.ctrlsService.whenReady((p) => {\n            this.gridCtrl = p.gridCtrl;\n        });\n    }\n\n    public pasteFromClipboard(): void {\n        // Method 1 - native clipboard API, available in modern chrome browsers\n        const allowNavigator = !this.gos.get('suppressClipboardApi');\n        // Some browsers (Firefox) do not allow Web Applications to read from\n        // the clipboard so verify if not only the ClipboardAPI is available,\n        // but also if the `readText` method is public.\n        if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {\n            navigator.clipboard\n                .readText()\n                .then(this.processClipboardData.bind(this))\n                .catch((e) => {\n                    _warnOnce(`${e}\\n${apiError('readText')}`);\n                    this.navigatorApiFailed = true;\n                    this.pasteFromClipboardLegacy();\n                });\n        } else {\n            this.pasteFromClipboardLegacy();\n        }\n    }\n\n    private pasteFromClipboardLegacy(): void {\n        // Method 2 - if modern API fails, the old school hack\n        let defaultPrevented = false;\n        const handlePasteEvent = (e: ClipboardEvent) => {\n            const currentPastOperationTime = new Date().getTime();\n            if (currentPastOperationTime - this.lastPasteOperationTime < 50) {\n                defaultPrevented = true;\n                e.preventDefault();\n            }\n            this.lastPasteOperationTime = currentPastOperationTime;\n        };\n\n        this.executeOnTempElement(\n            (textArea: HTMLTextAreaElement) => {\n                textArea.addEventListener('paste', handlePasteEvent);\n                textArea.focus({ preventScroll: true });\n            },\n            (element: HTMLTextAreaElement) => {\n                const data = element.value;\n                if (!defaultPrevented) {\n                    this.processClipboardData(data);\n                } else {\n                    this.refocusLastFocusedCell();\n                }\n                element.removeEventListener('paste', handlePasteEvent);\n            }\n        );\n    }\n\n    private refocusLastFocusedCell(): void {\n        const focusedCell = this.focusService.getFocusedCell();\n\n        if (focusedCell) {\n            this.focusService.setFocusedCell({\n                rowIndex: focusedCell.rowIndex,\n                column: focusedCell.column,\n                rowPinned: focusedCell.rowPinned,\n                forceBrowserFocus: true,\n            });\n        }\n    }\n\n    private getClipboardDelimiter() {\n        const delimiter = this.gos.get('clipboardDelimiter');\n        return _exists(delimiter) ? delimiter : '\\t';\n    }\n\n    private processClipboardData(data: string): void {\n        if (data == null) {\n            return;\n        }\n\n        let parsedData: string[][] | null = ClipboardService.stringToArray(data, this.getClipboardDelimiter());\n\n        const userFunc = this.gos.getCallback('processDataFromClipboard');\n\n        if (userFunc) {\n            parsedData = userFunc({ data: parsedData });\n        }\n\n        if (parsedData == null) {\n            return;\n        }\n\n        if (this.gos.get('suppressLastEmptyLineOnPaste')) {\n            this.removeLastLineIfBlank(parsedData!);\n        }\n\n        const pasteOperation = (\n            cellsToFlash: any,\n            updatedRowNodes: RowNode[],\n            focusedCell: CellPosition,\n            changedPath: ChangedPath | undefined\n        ) => {\n            const rangeActive = this.rangeService?.isMoreThanOneCell();\n            const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData!);\n\n            if (pasteIntoRange) {\n                this.pasteIntoActiveRange(this.rangeService!, parsedData!, cellsToFlash, updatedRowNodes, changedPath);\n            } else {\n                this.pasteStartingFromFocusedCell(parsedData!, cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n            }\n        };\n\n        this.doPasteOperation(pasteOperation);\n    }\n\n    // This will parse a delimited string into an array of arrays.\n    static stringToArray(strData: string, delimiter = ','): string[][] {\n        const data: any[][] = [];\n        const isNewline = (char: string) => char === '\\r' || char === '\\n';\n\n        let insideQuotedField = false;\n\n        if (strData === '') {\n            return [['']];\n        }\n\n        // iterate over each character, keep track of current row and column (of the returned array)\n        for (let row = 0, column = 0, position = 0; position < strData.length; position++) {\n            const previousChar = strData[position - 1];\n            const currentChar = strData[position];\n            const nextChar = strData[position + 1];\n            const ensureDataExists = () => {\n                if (!data[row]) {\n                    // create row if it doesn't exist\n                    data[row] = [];\n                }\n\n                if (!data[row][column]) {\n                    // create column if it doesn't exist\n                    data[row][column] = '';\n                }\n            };\n\n            ensureDataExists();\n\n            if (currentChar === '\"') {\n                if (insideQuotedField) {\n                    if (nextChar === '\"') {\n                        // unescape double quote\n                        data[row][column] += '\"';\n                        position++;\n                    } else {\n                        // exit quoted field\n                        insideQuotedField = false;\n                    }\n\n                    // continue;\n                } else if (previousChar === undefined || previousChar === delimiter || isNewline(previousChar)) {\n                    // enter quoted field\n                    insideQuotedField = true;\n                    // continue;\n                }\n            }\n\n            if (!insideQuotedField && currentChar !== '\"') {\n                if (currentChar === delimiter) {\n                    // move to next column\n                    column++;\n                    ensureDataExists();\n\n                    continue;\n                } else if (isNewline(currentChar)) {\n                    // move to next row\n                    column = 0;\n                    row++;\n                    ensureDataExists();\n\n                    if (currentChar === '\\r' && nextChar === '\\n') {\n                        // skip over second newline character if it exists\n                        position++;\n                    }\n\n                    continue;\n                }\n            }\n\n            // add current character to current column\n            data[row][column] += currentChar;\n        }\n\n        return data;\n    }\n\n    // common code to paste operations, e.g. paste to cell, paste to range, and copy range down\n    private doPasteOperation(\n        pasteOperationFunc: (\n            cellsToFlash: any,\n            updatedRowNodes: RowNode[],\n            focusedCell: CellPosition | null,\n            changedPath: ChangedPath | undefined\n        ) => void\n    ): void {\n        const source = 'clipboard';\n\n        this.eventService.dispatchEvent({\n            type: 'pasteStart',\n            source,\n        } as WithoutGridCommon<PasteStartEvent>);\n\n        let changedPath: ChangedPath | undefined;\n\n        if (this.clientSideRowModel) {\n            const onlyChangedColumns = this.gos.get('aggregateOnlyChangedColumns');\n            changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n        }\n\n        const cellsToFlash = {} as any;\n        const updatedRowNodes: RowNode[] = [];\n        const focusedCell = this.focusService.getFocusedCell();\n\n        pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n\n        const nodesToRefresh: RowNode[] = [...updatedRowNodes];\n        if (changedPath) {\n            this.clientSideRowModel.doAggregate(changedPath);\n\n            // add all nodes impacted by aggregation, as they need refreshed also.\n            changedPath.forEachChangedNodeDepthFirst((rowNode) => {\n                nodesToRefresh.push(rowNode);\n            });\n        }\n\n        // clipboardService has to do changeDetection itself, to prevent repeat logic in favour of batching.\n        // changeDetectionService is disabled for this action.\n        this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });\n\n        this.dispatchFlashCells(cellsToFlash);\n        this.fireRowChanged(updatedRowNodes);\n\n        // if using the clipboard hack with a temp element, then the focus has been lost,\n        // so need to put it back. otherwise paste operation loosed focus on cell and keyboard\n        // navigation stops.\n        this.refocusLastFocusedCell();\n        const event: WithoutGridCommon<PasteEndEvent> = {\n            type: 'pasteEnd',\n            source,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private pasteIntoActiveRange(\n        rangeService: IRangeService,\n        clipboardData: string[][],\n        cellsToFlash: any,\n        updatedRowNodes: RowNode[],\n        changedPath: ChangedPath | undefined\n    ) {\n        // true if clipboard data can be evenly pasted into range, otherwise false\n        const abortRepeatingPasteIntoRows = this.getRangeSize(rangeService) % clipboardData.length != 0;\n\n        let indexOffset = 0;\n        let dataRowIndex = 0;\n\n        const rowCallback: RowCallback = (\n            currentRow: RowPosition,\n            rowNode: RowNode,\n            columns: AgColumn[],\n            index: number\n        ) => {\n            const atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n\n            if (atEndOfClipboardData) {\n                if (abortRepeatingPasteIntoRows) {\n                    return;\n                }\n\n                // increment offset and reset data index to repeat paste of data\n                indexOffset += dataRowIndex;\n                dataRowIndex = 0;\n            }\n\n            const currentRowData = clipboardData[index - indexOffset];\n\n            // otherwise we are not the first row, so copy\n            updatedRowNodes.push(rowNode);\n\n            const processCellFromClipboardFunc = this.gos.getCallback('processCellFromClipboard');\n\n            columns.forEach((column, idx) => {\n                if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n                    return;\n                }\n\n                // repeat data for columns we don't have data for - happens when to range is bigger than copied data range\n                if (idx >= currentRowData.length) {\n                    idx = idx % currentRowData.length;\n                }\n\n                const newValue = this.processCell(\n                    rowNode,\n                    column,\n                    currentRowData[idx],\n                    EXPORT_TYPE_DRAG_COPY,\n                    processCellFromClipboardFunc,\n                    true\n                );\n\n                rowNode.setDataValue(column, newValue, SOURCE_PASTE);\n\n                if (changedPath) {\n                    changedPath.addParentNode(rowNode.parent, [column]);\n                }\n\n                const { rowIndex, rowPinned } = currentRow;\n                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                cellsToFlash[cellId] = true;\n            });\n\n            dataRowIndex++;\n        };\n\n        this.iterateActiveRanges(false, rowCallback);\n    }\n\n    private getDisplayedColumnsStartingAt(column: AgColumn): AgColumn[] {\n        let currentColumn: AgColumn | null = column;\n        const columns: AgColumn[] = [];\n\n        while (currentColumn != null) {\n            columns.push(currentColumn);\n            currentColumn = this.visibleColsService.getColAfter(currentColumn);\n        }\n\n        return columns;\n    }\n\n    private pasteStartingFromFocusedCell(\n        parsedData: string[][],\n        cellsToFlash: any,\n        updatedRowNodes: RowNode[],\n        focusedCell: CellPosition,\n        changedPath: ChangedPath | undefined\n    ) {\n        if (!focusedCell) {\n            return;\n        }\n\n        const currentRow: RowPosition = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };\n        const columnsToPasteInto = this.getDisplayedColumnsStartingAt(focusedCell.column as AgColumn);\n\n        if (this.isPasteSingleValueIntoRange(parsedData)) {\n            this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);\n        } else {\n            this.pasteMultipleValues(\n                parsedData,\n                currentRow,\n                updatedRowNodes,\n                columnsToPasteInto,\n                cellsToFlash,\n                EXPORT_TYPE_CLIPBOARD,\n                changedPath\n            );\n        }\n    }\n\n    // if range is active, and only one cell, then we paste this cell into all cells in the active range.\n    private isPasteSingleValueIntoRange(parsedData: string[][]): boolean {\n        return this.hasOnlyOneValueToPaste(parsedData) && this.rangeService != null && !this.rangeService.isEmpty();\n    }\n\n    private pasteSingleValueIntoRange(\n        parsedData: string[][],\n        updatedRowNodes: RowNode[],\n        cellsToFlash: any,\n        changedPath: ChangedPath | undefined\n    ) {\n        const value = parsedData[0][0];\n\n        const rowCallback: RowCallback = (currentRow: RowPosition, rowNode: RowNode, columns: AgColumn[]) => {\n            updatedRowNodes.push(rowNode);\n            columns.forEach((column) =>\n                this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath)\n            );\n        };\n\n        this.iterateActiveRanges(false, rowCallback);\n    }\n\n    private hasOnlyOneValueToPaste(parsedData: string[][]) {\n        return parsedData.length === 1 && parsedData[0].length === 1;\n    }\n\n    public copyRangeDown(): void {\n        if (!this.rangeService || this.rangeService.isEmpty()) {\n            return;\n        }\n\n        const firstRowValues: any[] = [];\n\n        const pasteOperation = (\n            cellsToFlash: any,\n            updatedRowNodes: RowNode[],\n            focusedCell: CellPosition,\n            changedPath: ChangedPath | undefined\n        ) => {\n            const processCellForClipboardFunc = this.gos.getCallback('processCellForClipboard');\n            const processCellFromClipboardFunc = this.gos.getCallback('processCellFromClipboard');\n\n            const rowCallback: RowCallback = (currentRow: RowPosition, rowNode: RowNode, columns: AgColumn[]) => {\n                // take reference of first row, this is the one we will be using to copy from\n                if (!firstRowValues.length) {\n                    // two reasons for looping through columns\n                    columns.forEach((column) => {\n                        // get the initial values to copy down\n                        const value = this.processCell(\n                            rowNode,\n                            column,\n                            this.valueService.getValue(column, rowNode),\n                            EXPORT_TYPE_DRAG_COPY,\n                            processCellForClipboardFunc,\n                            false,\n                            true\n                        );\n\n                        firstRowValues.push(value);\n                    });\n                } else {\n                    // otherwise we are not the first row, so copy\n                    updatedRowNodes.push(rowNode);\n                    columns.forEach((column, index) => {\n                        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n                            return;\n                        }\n\n                        const firstRowValue = this.processCell(\n                            rowNode,\n                            column,\n                            firstRowValues[index],\n                            EXPORT_TYPE_DRAG_COPY,\n                            processCellFromClipboardFunc,\n                            true\n                        );\n\n                        rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);\n\n                        if (changedPath) {\n                            changedPath.addParentNode(rowNode.parent, [column]);\n                        }\n\n                        const { rowIndex, rowPinned } = currentRow;\n                        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                        cellsToFlash[cellId] = true;\n                    });\n                }\n            };\n\n            this.iterateActiveRanges(true, rowCallback);\n        };\n\n        this.doPasteOperation(pasteOperation);\n    }\n\n    private removeLastLineIfBlank(parsedData: string[][]): void {\n        // remove last row if empty, excel puts empty last row in\n        const lastLine = _last(parsedData);\n        const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === '';\n\n        if (lastLineIsBlank) {\n            // do not remove the last empty line when that is the only line pasted\n            if (parsedData.length === 1) {\n                return;\n            }\n            _removeFromArray(parsedData, lastLine);\n        }\n    }\n\n    private fireRowChanged(rowNodes: RowNode[]): void {\n        if (this.gos.get('editType') !== 'fullRow') {\n            return;\n        }\n\n        rowNodes.forEach((rowNode) => {\n            const event: WithoutGridCommon<RowValueChangedEvent> = {\n                type: 'rowValueChanged',\n                node: rowNode,\n                data: rowNode.data,\n                rowIndex: rowNode.rowIndex!,\n                rowPinned: rowNode.rowPinned,\n            };\n\n            this.eventService.dispatchEvent(event);\n        });\n    }\n\n    private pasteMultipleValues(\n        clipboardGridData: string[][],\n        currentRow: RowPosition | null,\n        updatedRowNodes: RowNode[],\n        columnsToPasteInto: AgColumn[],\n        cellsToFlash: any,\n        type: string,\n        changedPath: ChangedPath | undefined\n    ): void {\n        let rowPointer = currentRow;\n\n        // if doing CSRM and NOT tree data, then it means groups are aggregates, which are read only,\n        // so we should skip them when doing paste operations.\n        const skipGroupRows =\n            this.clientSideRowModel != null && !this.gos.get('enableGroupEdit') && !this.gos.get('treeData');\n\n        const getNextGoodRowNode = () => {\n            while (true) {\n                if (!rowPointer) {\n                    return null;\n                }\n                const res = this.rowPositionUtils.getRowNode(rowPointer);\n                // move to next row down for next set of values\n                rowPointer = this.cellNavigationService.getRowBelow({\n                    rowPinned: rowPointer.rowPinned,\n                    rowIndex: rowPointer.rowIndex,\n                });\n\n                // if no more rows, return null\n                if (res == null) {\n                    return null;\n                }\n\n                // skip details rows and footer rows, never paste into them as they don't hold data\n                const skipRow = res.detail || res.footer || (skipGroupRows && res.group);\n\n                // skipping row means we go into the next iteration of the while loop\n                if (!skipRow) {\n                    return res;\n                }\n            }\n        };\n\n        clipboardGridData.forEach((clipboardRowData) => {\n            const rowNode = getNextGoodRowNode();\n\n            // if we have come to end of rows in grid, then skip\n            if (!rowNode) {\n                return;\n            }\n\n            clipboardRowData.forEach((value, index) =>\n                this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath)\n            );\n\n            updatedRowNodes.push(rowNode);\n        });\n    }\n\n    private updateCellValue(\n        rowNode: RowNode | null,\n        column: AgColumn,\n        value: string,\n        cellsToFlash: any,\n        type: string,\n        changedPath: ChangedPath | undefined\n    ) {\n        if (!rowNode || !column || !column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n            return;\n        }\n\n        // if the cell is a group and the col is an aggregation, skip the cell.\n        if (rowNode.group && column.isValueActive()) {\n            return;\n        }\n\n        const processedValue = this.processCell(\n            rowNode,\n            column,\n            value,\n            type,\n            this.gos.getCallback('processCellFromClipboard'),\n            true\n        );\n        rowNode.setDataValue(column, processedValue, SOURCE_PASTE);\n\n        const { rowIndex, rowPinned } = rowNode;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex: rowIndex!, column, rowPinned });\n        cellsToFlash[cellId] = true;\n\n        if (changedPath) {\n            changedPath.addParentNode(rowNode.parent, [column]);\n        }\n    }\n\n    public copyToClipboard(params: IClipboardCopyParams = {}): void {\n        this.copyOrCutToClipboard(params);\n    }\n\n    public cutToClipboard(params: IClipboardCopyParams = {}, source: 'api' | 'ui' | 'contextMenu' = 'api'): void {\n        if (this.gos.get('suppressCutToClipboard')) {\n            return;\n        }\n\n        const startEvent: WithoutGridCommon<CutStartEvent> = {\n            type: 'cutStart',\n            source,\n        };\n        this.eventService.dispatchEvent(startEvent);\n\n        this.copyOrCutToClipboard(params, true);\n\n        const endEvent: WithoutGridCommon<CutEndEvent> = {\n            type: 'cutEnd',\n            source,\n        };\n        this.eventService.dispatchEvent(endEvent);\n    }\n\n    private copyOrCutToClipboard(params: IClipboardCopyParams, cut?: boolean): void {\n        let { includeHeaders, includeGroupHeaders } = params;\n\n        // don't override 'includeHeaders' if it has been explicitly set to 'false'\n        if (includeHeaders == null) {\n            includeHeaders = this.gos.get('copyHeadersToClipboard');\n        }\n\n        if (includeGroupHeaders == null) {\n            includeGroupHeaders = this.gos.get('copyGroupHeadersToClipboard');\n        }\n\n        const copyParams = { includeHeaders, includeGroupHeaders };\n        const shouldCopyRows = !this.gos.get('suppressCopyRowsToClipboard');\n\n        let cellClearType: CellClearType | null = null;\n        // Copy priority is Range > Row > Focus\n        if (this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange(this.rangeService)) {\n            this.copySelectedRangeToClipboard(copyParams);\n            cellClearType = CellClearType.CellRange;\n        } else if (shouldCopyRows && !this.selectionService.isEmpty()) {\n            this.copySelectedRowsToClipboard(copyParams);\n            cellClearType = CellClearType.SelectedRows;\n        } else if (this.focusService.isAnyCellFocused()) {\n            this.copyFocusedCellToClipboard(copyParams);\n            cellClearType = CellClearType.FocusedCell;\n        }\n\n        if (cut && cellClearType !== null) {\n            this.clearCellsAfterCopy(cellClearType);\n        }\n    }\n\n    private clearCellsAfterCopy(type: CellClearType) {\n        this.eventService.dispatchEvent({ type: 'keyShortcutChangedCellStart' });\n        if (type === CellClearType.CellRange) {\n            this.rangeService!.clearCellRangeCellValues({ cellEventSource: 'clipboardService' });\n        } else if (type === CellClearType.SelectedRows) {\n            this.clearSelectedRows();\n        } else {\n            const focusedCell = this.focusService.getFocusedCell();\n            if (focusedCell == null) {\n                return;\n            }\n\n            const rowNode = this.rowPositionUtils.getRowNode(focusedCell);\n            if (rowNode) {\n                this.clearCellValue(rowNode, focusedCell.column as AgColumn);\n            }\n        }\n        this.eventService.dispatchEvent({ type: 'keyShortcutChangedCellEnd' });\n    }\n\n    private clearSelectedRows(): void {\n        const selected = this.selectionService.getSelectedNodes();\n        const columns = this.visibleColsService.getAllCols();\n\n        for (const row of selected) {\n            for (const col of columns) {\n                this.clearCellValue(row, col);\n            }\n        }\n    }\n\n    private clearCellValue(rowNode: RowNode, column: AgColumn): void {\n        if (!column.isCellEditable(rowNode)) {\n            return;\n        }\n        const emptyValue =\n            this.valueService.parseValue(column, rowNode, '', rowNode.getValueFromValueService(column)) ?? null;\n        rowNode.setDataValue(column, emptyValue, 'clipboardService');\n    }\n\n    private shouldSkipSingleCellRange(rangeService: IRangeService): boolean {\n        return this.gos.get('suppressCopySingleCellRanges') && !rangeService.isMoreThanOneCell();\n    }\n\n    private iterateActiveRanges(onlyFirst: boolean, rowCallback: RowCallback, columnCallback?: ColumnCallback): void {\n        if (!this.rangeService || this.rangeService.isEmpty()) {\n            return;\n        }\n\n        const cellRanges = this.rangeService.getCellRanges();\n\n        if (onlyFirst) {\n            this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);\n        } else {\n            cellRanges.forEach((range, idx) =>\n                this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1)\n            );\n        }\n    }\n\n    private iterateActiveRange(\n        range: CellRange,\n        rowCallback: RowCallback,\n        columnCallback?: ColumnCallback,\n        isLastRange?: boolean\n    ): void {\n        if (!this.rangeService) {\n            return;\n        }\n\n        let currentRow: RowPosition | null = this.rangeService.getRangeStartRow(range);\n        const lastRow = this.rangeService.getRangeEndRow(range);\n\n        if (columnCallback && range.columns) {\n            columnCallback(range.columns as AgColumn[]);\n        }\n\n        let rangeIndex = 0;\n        let isLastRow = false;\n\n        // the currentRow could be missing if the user sets the active range manually, and sets a range\n        // that is outside of the grid (eg. sets range rows 0 to 100, but grid has only 20 rows).\n        while (!isLastRow && currentRow != null) {\n            const rowNode = this.rowPositionUtils.getRowNode(currentRow);\n            isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);\n\n            rowCallback(currentRow, rowNode, range.columns as AgColumn[], rangeIndex++, isLastRow && isLastRange);\n\n            currentRow = this.cellNavigationService.getRowBelow(currentRow);\n        }\n    }\n\n    public copySelectedRangeToClipboard(params: IClipboardCopyParams = {}): void {\n        if (!this.rangeService || this.rangeService.isEmpty()) {\n            return;\n        }\n\n        const allRangesMerge = this.rangeService.areAllRangesAbleToMerge();\n        const { data, cellsToFlash } = allRangesMerge\n            ? this.buildDataFromMergedRanges(this.rangeService, params)\n            : this.buildDataFromRanges(this.rangeService, params);\n\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells(cellsToFlash);\n    }\n\n    private buildDataFromMergedRanges(\n        rangeService: IRangeService,\n        params: IClipboardCopyParams\n    ): DataForCellRangesType {\n        const columnsSet: Set<AgColumn> = new Set();\n        const ranges = rangeService.getCellRanges();\n        const rowPositionsMap: Map<string, boolean> = new Map();\n        const allRowPositions: RowPosition[] = [];\n        const allCellsToFlash: CellsToFlashType = {};\n\n        ranges.forEach((range) => {\n            range.columns.forEach((col: AgColumn) => columnsSet.add(col));\n            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeService, range);\n            rowPositions.forEach((rowPosition) => {\n                const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || 'null'}`;\n                if (!rowPositionsMap.get(rowPositionAsString)) {\n                    rowPositionsMap.set(rowPositionAsString, true);\n                    allRowPositions.push(rowPosition);\n                }\n            });\n            Object.assign(allCellsToFlash, cellsToFlash);\n        });\n\n        const allColumns = this.visibleColsService.getAllCols();\n        const exportedColumns = Array.from(columnsSet) as AgColumn[];\n\n        exportedColumns.sort((a, b) => {\n            const posA = allColumns.indexOf(a);\n            const posB = allColumns.indexOf(b);\n\n            return posA - posB;\n        });\n\n        const data = this.buildExportParams({\n            columns: exportedColumns,\n            rowPositions: allRowPositions,\n            includeHeaders: params.includeHeaders,\n            includeGroupHeaders: params.includeGroupHeaders,\n        });\n\n        return { data, cellsToFlash: allCellsToFlash };\n    }\n\n    private buildDataFromRanges(rangeService: IRangeService, params: IClipboardCopyParams): DataForCellRangesType {\n        const ranges = rangeService.getCellRanges();\n        const data: string[] = [];\n        const allCellsToFlash: CellsToFlashType = {};\n\n        ranges.forEach((range) => {\n            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeService, range);\n            Object.assign(allCellsToFlash, cellsToFlash);\n            data.push(\n                this.buildExportParams({\n                    columns: range.columns as AgColumn[],\n                    rowPositions: rowPositions,\n                    includeHeaders: params.includeHeaders,\n                    includeGroupHeaders: params.includeGroupHeaders,\n                })\n            );\n        });\n\n        return { data: data.join('\\n'), cellsToFlash: allCellsToFlash };\n    }\n\n    private getRangeRowPositionsAndCellsToFlash(\n        rangeService: IRangeService,\n        range: CellRange\n    ): { rowPositions: RowPosition[]; cellsToFlash: CellsToFlashType } {\n        const rowPositions: RowPosition[] = [];\n        const cellsToFlash: CellsToFlashType = {};\n        const startRow = rangeService.getRangeStartRow(range);\n        const lastRow = rangeService.getRangeEndRow(range);\n\n        let node: RowPosition | null = startRow;\n\n        while (node) {\n            rowPositions.push(node);\n            range.columns.forEach((column) => {\n                const { rowIndex, rowPinned } = node!;\n                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                cellsToFlash[cellId] = true;\n            });\n            if (this.rowPositionUtils.sameRow(node, lastRow)) {\n                break;\n            }\n            node = this.cellNavigationService.getRowBelow(node);\n        }\n\n        return { rowPositions, cellsToFlash };\n    }\n\n    private getCellsToFlashFromRowNodes(rowNodes: RowNode[]): CellsToFlashType {\n        const allDisplayedColumns = this.visibleColsService.getAllCols();\n        const cellsToFlash: CellsToFlashType = {};\n        for (let i = 0; i < rowNodes.length; i++) {\n            const { rowIndex, rowPinned } = rowNodes[i];\n            if (rowIndex == null) {\n                continue;\n            }\n            for (let j = 0; j < allDisplayedColumns.length; j++) {\n                const column = allDisplayedColumns[j];\n                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                cellsToFlash[cellId] = true;\n            }\n        }\n\n        return cellsToFlash;\n    }\n\n    private copyFocusedCellToClipboard(params: IClipboardCopyParams = {}): void {\n        const focusedCell = this.focusService.getFocusedCell();\n\n        if (focusedCell == null) {\n            return;\n        }\n\n        const cellId = this.cellPositionUtils.createId(focusedCell);\n        const currentRow: RowPosition = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };\n        const column = focusedCell.column as AgColumn;\n\n        const data = this.buildExportParams({\n            columns: [column],\n            rowPositions: [currentRow],\n            includeHeaders: params.includeHeaders,\n            includeGroupHeaders: params.includeGroupHeaders,\n        });\n\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells({ [cellId]: true });\n    }\n\n    public copySelectedRowsToClipboard(params: IClipboardCopyRowsParams = {}): void {\n        const { columnKeys, includeHeaders, includeGroupHeaders } = params;\n\n        const data = this.buildExportParams({\n            columns: columnKeys as (string | AgColumn)[] | undefined,\n            includeHeaders,\n            includeGroupHeaders,\n        });\n\n        this.copyDataToClipboard(data);\n        const rowNodes = this.selectionService.getSelectedNodes() || [];\n        this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));\n    }\n\n    private buildExportParams(params: {\n        columns?: (string | AgColumn)[];\n        rowPositions?: RowPosition[];\n        includeHeaders?: boolean;\n        includeGroupHeaders?: boolean;\n    }): string {\n        const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;\n\n        const exportParams: CsvExportParams = {\n            columnKeys: columns,\n            rowPositions,\n            skipColumnHeaders: !includeHeaders,\n            skipColumnGroupHeaders: !includeGroupHeaders,\n            suppressQuotes: true,\n            columnSeparator: this.getClipboardDelimiter(),\n            onlySelected: !rowPositions,\n            processCellCallback: this.gos.getCallback('processCellForClipboard'),\n            processRowGroupCallback: (params) => this.processRowGroupCallback(params),\n            processHeaderCallback: this.gos.getCallback('processHeaderForClipboard'),\n            processGroupHeaderCallback: this.gos.getCallback('processGroupHeaderForClipboard'),\n        };\n\n        return this.csvCreator.getDataAsCsv(exportParams, true);\n    }\n\n    private processRowGroupCallback(params: ProcessRowGroupForExportParams) {\n        const { node, column } = params;\n\n        const isTreeData = this.gos.get('treeData');\n        const isSuppressGroupMaintainValueType = this.gos.get('suppressGroupMaintainValueType');\n\n        // if not tree data and not suppressGroupMaintainValueType then we get the value from the group data\n        const getValueFromNode = () => {\n            if (isTreeData || isSuppressGroupMaintainValueType || !column) {\n                return node.key;\n            }\n            const value = node.groupData?.[column.getId()];\n            if (\n                !value ||\n                !node.rowGroupColumn ||\n                node.rowGroupColumn.getColDef().useValueFormatterForExport === false\n            ) {\n                return value;\n            }\n            return this.valueService.formatValue(node.rowGroupColumn as AgColumn, node, value) ?? value;\n        };\n        let value = getValueFromNode();\n\n        if (params.node.footer) {\n            let suffix = '';\n            if (value && value.length) {\n                suffix = ` ${value}`;\n            }\n            value = `Total${suffix}`;\n        }\n        const processCellForClipboard = this.gos.getCallback('processCellForClipboard');\n\n        if (processCellForClipboard) {\n            let column = node.rowGroupColumn as AgColumn;\n\n            if (!column && node.footer && node.level === -1) {\n                column = this.funcColsService.getRowGroupColumns()[0];\n            }\n            return processCellForClipboard({\n                value,\n                node,\n                column,\n                type: 'clipboard',\n                formatValue: (valueToFormat: any) =>\n                    this.valueService.formatValue(column, node, valueToFormat) ?? valueToFormat,\n                parseValue: (valueToParse: string) =>\n                    this.valueService.parseValue(column, node, valueToParse, this.valueService.getValue(column, node)),\n            });\n        }\n        return value;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private dispatchFlashCells(cellsToFlash: {}): void {\n        window.setTimeout(() => {\n            const event: WithoutGridCommon<FlashCellsEvent> = {\n                type: 'flashCells',\n                cells: cellsToFlash,\n            };\n\n            this.eventService.dispatchEvent(event);\n        }, 0);\n    }\n\n    private processCell<T>(\n        rowNode: RowNode | undefined,\n        column: AgColumn,\n        value: T,\n        type: string,\n        func?: (params: WithoutGridCommon<ProcessCellForExportParams>) => T,\n        canParse?: boolean,\n        canFormat?: boolean\n    ): T {\n        if (func) {\n            const params: WithoutGridCommon<ProcessCellForExportParams> = {\n                column,\n                node: rowNode,\n                value,\n                type,\n                formatValue: (valueToFormat: any) =>\n                    this.valueService.formatValue(column, rowNode ?? null, valueToFormat) ?? valueToFormat,\n                parseValue: (valueToParse: string) =>\n                    this.valueService.parseValue(\n                        column,\n                        rowNode ?? null,\n                        valueToParse,\n                        this.valueService.getValue(column, rowNode)\n                    ),\n            };\n\n            return func(params);\n        }\n\n        if (canParse && column.getColDef().useValueParserForImport !== false) {\n            return this.valueService.parseValue(\n                column,\n                rowNode ?? null,\n                value,\n                this.valueService.getValue(column, rowNode)\n            );\n        }\n\n        if (canFormat && column.getColDef().useValueFormatterForExport !== false) {\n            return this.valueService.formatValue(column, rowNode ?? null, value) ?? (value as any);\n        }\n\n        return value;\n    }\n\n    private copyDataToClipboard(data: string): void {\n        const userProvidedFunc = this.gos.getCallback('sendToClipboard');\n\n        // method 1 - user provided func\n        if (userProvidedFunc) {\n            userProvidedFunc({ data });\n            return;\n        }\n\n        // method 2 - native clipboard API, available in modern chrome browsers\n        const allowNavigator = !this.gos.get('suppressClipboardApi');\n        if (allowNavigator && navigator.clipboard) {\n            navigator.clipboard.writeText(data).catch((e) => {\n                _warnOnce(`${e}\\n${apiError('writeText')}`);\n                this.copyDataToClipboardLegacy(data);\n            });\n            return;\n        }\n\n        this.copyDataToClipboardLegacy(data);\n    }\n\n    private copyDataToClipboardLegacy(data: string): void {\n        // method 3 - if all else fails, the old school hack\n        this.executeOnTempElement((element) => {\n            const eDocument = this.gos.getDocument();\n            const focusedElementBefore = this.gos.getActiveDomElement() as HTMLElement;\n\n            element.value = data || ' '; // has to be non-empty value or execCommand will not do anything\n            element.select();\n            element.focus({ preventScroll: true });\n\n            const result = eDocument.execCommand('copy');\n\n            if (!result) {\n                _warnOnce(\n                    \"Browser did not allow document.execCommand('copy'). Ensure \" +\n                        'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise ' +\n                        'the browser will prevent it for security reasons.'\n                );\n            }\n\n            if (focusedElementBefore != null && focusedElementBefore.focus != null) {\n                focusedElementBefore.focus({ preventScroll: true });\n            }\n        });\n    }\n\n    private executeOnTempElement(\n        callbackNow: (element: HTMLTextAreaElement) => void,\n        callbackAfter?: (element: HTMLTextAreaElement) => void\n    ): void {\n        const eDoc = this.gos.getDocument();\n        const eTempInput = eDoc.createElement('textarea');\n        eTempInput.style.width = '1px';\n        eTempInput.style.height = '1px';\n\n        // removing items from the DOM causes the document element to scroll to the\n        // position where the element was positioned. Here we set scrollTop / scrollLeft\n        // to prevent the document element from scrolling when we remove it from the DOM.\n        eTempInput.style.top = eDoc.documentElement.scrollTop + 'px';\n        eTempInput.style.left = eDoc.documentElement.scrollLeft + 'px';\n\n        eTempInput.style.position = 'absolute';\n        eTempInput.style.opacity = '0';\n\n        const guiRoot = this.gridCtrl.getGui();\n\n        guiRoot.appendChild(eTempInput);\n\n        try {\n            callbackNow(eTempInput);\n        } catch (err) {\n            _warnOnce(\"Browser does not support document.execCommand('copy') for clipboard operations\");\n        }\n\n        //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...\n        if (callbackAfter) {\n            window.setTimeout(() => {\n                callbackAfter(eTempInput);\n                guiRoot.removeChild(eTempInput);\n            }, 100);\n        } else {\n            guiRoot.removeChild(eTempInput);\n        }\n    }\n\n    private getRangeSize(rangeService: IRangeService): number {\n        const ranges = rangeService.getCellRanges();\n        let startRangeIndex = 0;\n        let endRangeIndex = 0;\n\n        if (ranges.length > 0) {\n            startRangeIndex = rangeService.getRangeStartRow(ranges[0]).rowIndex;\n            endRangeIndex = rangeService.getRangeEndRow(ranges[0]).rowIndex;\n        }\n\n        return startRangeIndex - endRangeIndex + 1;\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.3.1';\n"],
  "mappings": "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",
  "names": ["params", "value", "column"]
}
