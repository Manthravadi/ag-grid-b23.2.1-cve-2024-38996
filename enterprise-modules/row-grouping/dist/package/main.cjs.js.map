{
  "version": 3,
  "sources": ["../../src/main.ts", "../../src/rowGroupingModule.ts", "../../src/rowGrouping/aggFuncService.ts", "../../src/rowGrouping/aggregationStage.ts", "../../src/rowGrouping/autoColService.ts", "../../src/rowGrouping/columnDropZones/columnDropZoneService.ts", "../../src/rowGrouping/columnDropZones/agGridHeaderDropZones.ts", "../../src/rowGrouping/columnDropZones/pivotDropZonePanel.ts", "../../src/rowGrouping/columnDropZones/baseDropZonePanel.ts", "../../src/rowGrouping/columnDropZones/dropZoneColumnComp.ts", "../../src/rowGrouping/columnDropZones/rowGroupDropZonePanel.ts", "../../src/rowGrouping/filterAggregatesStage.ts", "../../src/rowGrouping/groupFilter/groupFilter.ts", "../../src/rowGrouping/groupFilter/groupFloatingFilter.ts", "../../src/rowGrouping/groupStage.ts", "../../src/rowGrouping/batchRemover.ts", "../../src/rowGrouping/pivotColDefService.ts", "../../src/rowGrouping/pivotStage.ts", "../../src/rowGrouping/rowGroupingApi.ts", "../../src/rowGrouping/showRowGroupColsService.ts", "../../src/version.ts", "../../src/rowGrouping/columnDropZones/valueDropZonePanel.ts"],
  "sourcesContent": ["export { RowGroupingModule } from './rowGroupingModule';\nexport { RowGroupDropZonePanel } from './rowGrouping/columnDropZones/rowGroupDropZonePanel';\nexport { ValuesDropZonePanel } from './rowGrouping/columnDropZones/valueDropZonePanel';\nexport { PivotDropZonePanel } from './rowGrouping/columnDropZones/pivotDropZonePanel';\n", "import type { Module } from '@ag-grid-community/core';\nimport { ModuleNames, _ColumnFilterModule, _FloatingFilterModule } from '@ag-grid-community/core';\nimport { EnterpriseCoreModule, GroupCellRenderer, GroupCellRendererCtrl } from '@ag-grid-enterprise/core';\n\nimport { AggFuncService } from './rowGrouping/aggFuncService';\nimport { AggregationStage } from './rowGrouping/aggregationStage';\nimport { AutoColService } from './rowGrouping/autoColService';\nimport { ColumnDropZoneService } from './rowGrouping/columnDropZones/columnDropZoneService';\nimport { FilterAggregatesStage } from './rowGrouping/filterAggregatesStage';\nimport { GroupFilter } from './rowGrouping/groupFilter/groupFilter';\nimport { GroupFloatingFilterComp } from './rowGrouping/groupFilter/groupFloatingFilter';\nimport { GroupStage } from './rowGrouping/groupStage';\nimport { PivotColDefService } from './rowGrouping/pivotColDefService';\nimport { PivotStage } from './rowGrouping/pivotStage';\nimport {\n    addAggFunc,\n    addAggFuncs,\n    addPivotColumn,\n    addPivotColumns,\n    addRowGroupColumn,\n    addRowGroupColumns,\n    addValueColumn,\n    addValueColumns,\n    clearAggFuncs,\n    getPivotColumns,\n    getPivotResultColumn,\n    getPivotResultColumns,\n    getRowGroupColumns,\n    getValueColumns,\n    isPivotMode,\n    moveRowGroupColumn,\n    removePivotColumn,\n    removePivotColumns,\n    removeRowGroupColumn,\n    removeRowGroupColumns,\n    removeValueColumn,\n    removeValueColumns,\n    setColumnAggFunc,\n    setPivotColumns,\n    setPivotResultColumns,\n    setRowGroupColumns,\n    setValueColumns,\n} from './rowGrouping/rowGroupingApi';\nimport { ShowRowGroupColsService } from './rowGrouping/showRowGroupColsService';\nimport { VERSION } from './version';\n\nexport const RowGroupingCoreModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.RowGroupingModule}-core`,\n    beans: [\n        AggregationStage,\n        FilterAggregatesStage,\n        GroupStage,\n        PivotColDefService,\n        PivotStage,\n        AggFuncService,\n        AutoColService,\n        ShowRowGroupColsService,\n        ColumnDropZoneService,\n    ],\n    userComponents: [\n        {\n            name: 'agGroupRowRenderer',\n            classImp: GroupCellRenderer,\n        },\n        {\n            name: 'agGroupCellRenderer',\n            classImp: GroupCellRenderer,\n        },\n    ],\n    controllers: [{ name: 'groupCellRendererCtrl', classImp: GroupCellRendererCtrl }],\n    dependantModules: [EnterpriseCoreModule],\n};\n\nexport const RowGroupingApiModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.RowGroupingModule}-api`,\n    apiFunctions: {\n        addAggFunc,\n        addAggFuncs,\n        clearAggFuncs,\n        setColumnAggFunc,\n        isPivotMode,\n        getPivotResultColumn,\n        setValueColumns,\n        getValueColumns,\n        removeValueColumn,\n        removeValueColumns,\n        addValueColumn,\n        addValueColumns,\n        setRowGroupColumns,\n        removeRowGroupColumn,\n        removeRowGroupColumns,\n        addRowGroupColumn,\n        addRowGroupColumns,\n        getRowGroupColumns,\n        moveRowGroupColumn,\n        setPivotColumns,\n        removePivotColumn,\n        removePivotColumns,\n        addPivotColumn,\n        addPivotColumns,\n        getPivotColumns,\n        setPivotResultColumns,\n        getPivotResultColumns,\n    },\n    dependantModules: [RowGroupingCoreModule],\n};\n\nexport const GroupFilterModule: Module = {\n    version: VERSION,\n    moduleName: '@ag-grid-enterprise/group-filter',\n    userComponents: [{ name: 'agGroupColumnFilter', classImp: GroupFilter }],\n    dependantModules: [RowGroupingCoreModule, _ColumnFilterModule],\n};\n\nexport const GroupFloatingFilterModule: Module = {\n    version: VERSION,\n    moduleName: '@ag-grid-enterprise/group-floating-filter',\n    userComponents: [{ name: 'agGroupColumnFloatingFilter', classImp: GroupFloatingFilterComp }],\n    dependantModules: [GroupFilterModule, _FloatingFilterModule],\n};\n\nexport const RowGroupingModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.RowGroupingModule,\n    dependantModules: [RowGroupingCoreModule, RowGroupingApiModule, GroupFilterModule, GroupFloatingFilterModule],\n};\n", "import type { AgColumn, IAggFunc, IAggFuncParams, IAggFuncService, NamedBean } from '@ag-grid-community/core';\nimport { BeanStub, _exists, _existsAndNotEmpty, _includes, _iterateObject, _last } from '@ag-grid-community/core';\n\nconst defaultAggFuncNames = {\n    sum: 'Sum',\n    first: 'First',\n    last: 'Last',\n    min: 'Min',\n    max: 'Max',\n    count: 'Count',\n    avg: 'Average',\n} as const;\ntype DefaultAggFuncName = keyof typeof defaultAggFuncNames;\n\nexport class AggFuncService extends BeanStub implements NamedBean, IAggFuncService {\n    beanName = 'aggFuncService' as const;\n\n    private aggFuncsMap: { [key in string]: IAggFunc } = {};\n    private initialised = false;\n\n    public postConstruct(): void {\n        this.init();\n    }\n\n    private init() {\n        if (this.initialised) {\n            return;\n        }\n\n        this.initialiseWithDefaultAggregations();\n        this.addAggFuncs(this.gos.get('aggFuncs'));\n    }\n\n    private initialiseWithDefaultAggregations(): void {\n        const aggMap = this.aggFuncsMap as { [key in DefaultAggFuncName]: IAggFunc };\n        aggMap['sum'] = aggSum;\n        aggMap['first'] = aggFirst;\n        aggMap['last'] = aggLast;\n        aggMap['min'] = aggMin;\n        aggMap['max'] = aggMax;\n        aggMap['count'] = aggCount;\n        aggMap['avg'] = aggAvg;\n        this.initialised = true;\n    }\n\n    private isAggFuncPossible(column: AgColumn, func: string): boolean {\n        const allKeys = this.getFuncNames(column);\n        const allowed = _includes(allKeys, func);\n        const funcExists = _exists(this.aggFuncsMap[func]);\n        return allowed && funcExists;\n    }\n\n    public getDefaultFuncLabel(fctName: DefaultAggFuncName): string {\n        return defaultAggFuncNames[fctName] ?? fctName;\n    }\n\n    public getDefaultAggFunc(column: AgColumn): string | null {\n        const defaultAgg = column.getColDef().defaultAggFunc;\n\n        if (_exists(defaultAgg) && this.isAggFuncPossible(column, defaultAgg)) {\n            return defaultAgg;\n        }\n\n        if (this.isAggFuncPossible(column, 'sum')) {\n            return 'sum';\n        }\n\n        const allKeys = this.getFuncNames(column);\n        return _existsAndNotEmpty(allKeys) ? allKeys[0] : null;\n    }\n\n    public addAggFuncs(aggFuncs?: { [key: string]: IAggFunc }): void {\n        this.init();\n        _iterateObject(aggFuncs, (key: string, aggFunc: IAggFunc) => {\n            this.aggFuncsMap[key] = aggFunc;\n        });\n    }\n\n    public getAggFunc(name: string): IAggFunc {\n        this.init();\n        return this.aggFuncsMap[name];\n    }\n\n    public getFuncNames(column: AgColumn): string[] {\n        const userAllowedFuncs = column.getColDef().allowedAggFuncs;\n\n        return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;\n    }\n\n    public clear(): void {\n        this.aggFuncsMap = {};\n    }\n}\n\nfunction aggSum(params: IAggFuncParams): number | bigint {\n    const { values } = params;\n    let result: any = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        if (typeof value === 'number') {\n            if (result === null) {\n                result = value;\n            } else {\n                result += typeof result === 'number' ? value : BigInt(value);\n            }\n        } else if (typeof value === 'bigint') {\n            if (result === null) {\n                result = value;\n            } else {\n                result = (typeof result === 'bigint' ? result : BigInt(result)) + value;\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction aggFirst(params: IAggFuncParams): any {\n    return params.values.length > 0 ? params.values[0] : null;\n}\n\nfunction aggLast(params: IAggFuncParams): any {\n    return params.values.length > 0 ? _last(params.values) : null;\n}\n\nfunction aggMin(params: IAggFuncParams): number | bigint | null {\n    const { values } = params;\n    let result: number | bigint | null = null;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {\n            result = value;\n        }\n    }\n\n    return result;\n}\n\nfunction aggMax(params: IAggFuncParams): number | bigint | null {\n    const { values } = params;\n    let result: number | bigint | null = null;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {\n            result = value;\n        }\n    }\n\n    return result;\n}\n\nfunction aggCount(params: IAggFuncParams) {\n    const { values } = params;\n    let result = 0;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        // check if the value is from a group, in which case use the group's count\n        result += value != null && typeof value.value === 'number' ? value.value : 1;\n    }\n\n    // the previous aggregation data\n    const existingAggData = params.rowNode?.aggData?.[params.column.getColId()];\n    if (existingAggData && existingAggData.value === result) {\n        // the underlying values haven't changed, return the old object to avoid triggering change detection\n        return existingAggData;\n    }\n\n    // it's important to wrap it in the object so we can determine if this is a group level\n    return {\n        value: result,\n        toString: function () {\n            return this.value.toString();\n        },\n        // used for sorting\n        toNumber: function () {\n            return this.value;\n        },\n    };\n}\n\n// the average function is tricky as the multiple levels require weighted averages\n// for the non-leaf node aggregations.\nfunction aggAvg(params: IAggFuncParams): {\n    value: number | bigint | null;\n    count: number;\n    toString(): string;\n    toNumber(): number;\n} {\n    const { values } = params;\n    let sum: any = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n    let count = 0;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const currentValue = values[i];\n        let valueToAdd = null;\n\n        if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {\n            valueToAdd = currentValue;\n            count++;\n        } else if (\n            currentValue != null &&\n            (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') &&\n            typeof currentValue.count === 'number'\n        ) {\n            // we are aggregating groups, so we take the aggregated values to calculated a weighted average\n            valueToAdd =\n                currentValue.value *\n                (typeof currentValue.value === 'number' ? currentValue.count : BigInt(currentValue.count));\n            count += currentValue.count;\n        }\n\n        if (typeof valueToAdd === 'number') {\n            sum += typeof sum === 'number' ? valueToAdd : BigInt(valueToAdd);\n        } else if (typeof valueToAdd === 'bigint') {\n            sum = (typeof sum === 'bigint' ? sum : BigInt(sum)) + valueToAdd;\n        }\n    }\n\n    let value = null;\n\n    // avoid divide by zero error\n    if (count > 0) {\n        value = sum / ((typeof sum === 'number' ? count : BigInt(count)) as any);\n    }\n\n    // the previous aggregation data\n    const existingAggData = params.rowNode?.aggData?.[params.column?.getColId()];\n    if (existingAggData && existingAggData.count === count && existingAggData.value === value) {\n        // the underlying values haven't changed, return the old object to avoid triggering change detection\n        return existingAggData;\n    }\n\n    // the result will be an object. when this cell is rendered, only the avg is shown.\n    // however when this cell is part of another aggregation, the count is also needed\n    // to create a weighted average for the next level.\n    return {\n        count,\n        value,\n        // the grid by default uses toString to render values for an object, so this\n        // is a trick to get the default cellRenderer to display the avg value\n        toString: function () {\n            return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';\n        },\n        // used for sorting\n        toNumber: function () {\n            return this.value;\n        },\n    };\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ChangedPath,\n    ColumnModel,\n    FuncColsService,\n    GetGroupRowAggParams,\n    IAggFunc,\n    IAggFuncParams,\n    IRowNodeStage,\n    NamedBean,\n    PivotResultColsService,\n    RowNode,\n    StageExecuteParams,\n    ValueService,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, _errorOnce, _missingOrEmpty } from '@ag-grid-community/core';\n\nimport type { AggFuncService } from './aggFuncService';\n\ninterface AggregationDetails {\n    alwaysAggregateAtRootLevel: boolean;\n    groupIncludeTotalFooter: boolean;\n    changedPath: ChangedPath;\n    valueColumns: AgColumn[];\n    pivotColumns: AgColumn[];\n    filteredOnly: boolean;\n    userAggFunc: ((params: WithoutGridCommon<GetGroupRowAggParams<any, any>>) => any) | undefined;\n}\n\nexport class AggregationStage extends BeanStub implements NamedBean, IRowNodeStage {\n    beanName = 'aggregationStage' as const;\n\n    private columnModel: ColumnModel;\n    private valueService: ValueService;\n    private aggFuncService: AggFuncService;\n    private funcColsService: FuncColsService;\n    private pivotResultColsService: PivotResultColsService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.columnModel = beans.columnModel;\n        this.aggFuncService = beans.aggFuncService as AggFuncService;\n        this.funcColsService = beans.funcColsService;\n        this.pivotResultColsService = beans.pivotResultColsService;\n        this.valueService = beans.valueService;\n    }\n\n    // it's possible to recompute the aggregate without doing the other parts\n    // + api.refreshClientSideRowModel('aggregate')\n    public execute(params: StageExecuteParams): any {\n        // if changed path is active, it means we came from a) change detection or b) transaction update.\n        // for both of these, if no value columns are present, it means there is nothing to aggregate now\n        // and there is no cleanup to be done (as value columns don't change between transactions or change\n        // detections). if no value columns and no changed path, means we have to go through all nodes in\n        // case we need to clean up agg data from before.\n        const noValueColumns = _missingOrEmpty(this.funcColsService.getValueColumns());\n        const noUserAgg = !this.gos.getCallback('getGroupRowAgg');\n        const changedPathActive = params.changedPath && params.changedPath.isActive();\n        if (noValueColumns && noUserAgg && changedPathActive) {\n            return;\n        }\n\n        const aggDetails = this.createAggDetails(params);\n\n        this.recursivelyCreateAggData(aggDetails);\n    }\n\n    private createAggDetails(params: StageExecuteParams): AggregationDetails {\n        const pivotActive = this.columnModel.isPivotActive();\n\n        const measureColumns = this.funcColsService.getValueColumns();\n        const pivotColumns = pivotActive ? this.funcColsService.getPivotColumns() : [];\n\n        const aggDetails: AggregationDetails = {\n            alwaysAggregateAtRootLevel: this.gos.get('alwaysAggregateAtRootLevel'),\n            groupIncludeTotalFooter: !!this.gos.getGrandTotalRow(),\n            changedPath: params.changedPath!,\n            valueColumns: measureColumns,\n            pivotColumns: pivotColumns,\n            filteredOnly: !this.isSuppressAggFilteredOnly(),\n            userAggFunc: this.gos.getCallback('getGroupRowAgg') as any,\n        };\n\n        return aggDetails;\n    }\n\n    private isSuppressAggFilteredOnly() {\n        const isGroupAggFiltering = this.gos.getGroupAggFiltering() !== undefined;\n        return isGroupAggFiltering || this.gos.get('suppressAggFilteredOnly');\n    }\n\n    private recursivelyCreateAggData(aggDetails: AggregationDetails) {\n        const callback = (rowNode: RowNode) => {\n            const hasNoChildren = !rowNode.hasChildren();\n            if (hasNoChildren) {\n                // this check is needed for TreeData, in case the node is no longer a child,\n                // but it was a child previously.\n                if (rowNode.aggData) {\n                    rowNode.setAggData(null);\n                }\n                // never agg data for leaf nodes\n                return;\n            }\n\n            //Optionally enable the aggregation at the root Node\n            const isRootNode = rowNode.level === -1;\n            // if total footer is displayed, the value is in use\n            if (isRootNode && !aggDetails.groupIncludeTotalFooter) {\n                const notPivoting = !this.columnModel.isPivotMode();\n                if (!aggDetails.alwaysAggregateAtRootLevel && notPivoting) {\n                    rowNode.setAggData(null);\n                    return;\n                }\n            }\n\n            this.aggregateRowNode(rowNode, aggDetails);\n        };\n\n        aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);\n    }\n\n    private aggregateRowNode(rowNode: RowNode, aggDetails: AggregationDetails): void {\n        const measureColumnsMissing = aggDetails.valueColumns.length === 0;\n        const pivotColumnsMissing = aggDetails.pivotColumns.length === 0;\n\n        let aggResult: any;\n        if (aggDetails.userAggFunc) {\n            aggResult = aggDetails.userAggFunc({ nodes: rowNode.childrenAfterFilter! });\n        } else if (measureColumnsMissing) {\n            aggResult = null;\n        } else if (pivotColumnsMissing) {\n            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);\n        } else {\n            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);\n        }\n\n        rowNode.setAggData(aggResult);\n\n        // if we are grouping, then it's possible there is a sibling footer\n        // to the group, so update the data here also if there is one\n        if (rowNode.sibling) {\n            rowNode.sibling.setAggData(aggResult);\n        }\n    }\n\n    private aggregateRowNodeUsingValuesAndPivot(rowNode: RowNode): any {\n        const result: any = {};\n\n        const secondaryColumns = this.pivotResultColsService.getPivotResultCols()?.list ?? [];\n        let canSkipTotalColumns = true;\n        for (let i = 0; i < secondaryColumns.length; i++) {\n            const secondaryCol = secondaryColumns[i];\n            const colDef = secondaryCol.getColDef();\n\n            if (colDef.pivotTotalColumnIds != null) {\n                canSkipTotalColumns = false;\n                continue;\n            }\n\n            const keys: string[] = colDef.pivotKeys ?? [];\n            let values: any[];\n\n            if (rowNode.leafGroup) {\n                // lowest level group, get the values from the mapped set\n                values = this.getValuesFromMappedSet(rowNode.childrenMapped, keys, colDef.pivotValueColumn as AgColumn);\n            } else {\n                // value columns and pivot columns, non-leaf group\n                values = this.getValuesPivotNonLeaf(rowNode, colDef.colId!);\n            }\n\n            // bit of a memory drain storing null/undefined, but seems to speed up performance.\n            result[colDef.colId!] = this.aggregateValues(\n                values,\n                colDef.pivotValueColumn!.getAggFunc()!,\n                colDef.pivotValueColumn as AgColumn,\n                rowNode,\n                secondaryCol\n            );\n        }\n\n        if (!canSkipTotalColumns) {\n            for (let i = 0; i < secondaryColumns.length; i++) {\n                const secondaryCol = secondaryColumns[i];\n                const colDef = secondaryCol.getColDef();\n\n                if (colDef.pivotTotalColumnIds == null || !colDef.pivotTotalColumnIds.length) {\n                    continue;\n                }\n\n                const aggResults: any[] = colDef.pivotTotalColumnIds.map(\n                    (currentColId: string) => result[currentColId]\n                );\n                // bit of a memory drain storing null/undefined, but seems to speed up performance.\n                result[colDef.colId!] = this.aggregateValues(\n                    aggResults,\n                    colDef.pivotValueColumn!.getAggFunc()!,\n                    colDef.pivotValueColumn as AgColumn,\n                    rowNode,\n                    secondaryCol\n                );\n            }\n        }\n\n        return result;\n    }\n\n    private aggregateRowNodeUsingValuesOnly(rowNode: RowNode, aggDetails: AggregationDetails): any {\n        const result: any = {};\n\n        const changedValueColumns = aggDetails.changedPath.isActive()\n            ? aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : aggDetails.valueColumns;\n\n        const notChangedValueColumns = aggDetails.changedPath.isActive()\n            ? aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : null;\n\n        const values2d = this.getValuesNormal(rowNode, changedValueColumns, aggDetails.filteredOnly);\n        const oldValues = rowNode.aggData;\n\n        changedValueColumns.forEach((valueColumn, index) => {\n            result[valueColumn.getId()] = this.aggregateValues(\n                values2d[index],\n                valueColumn.getAggFunc()!,\n                valueColumn,\n                rowNode\n            );\n        });\n\n        if (notChangedValueColumns && oldValues) {\n            notChangedValueColumns.forEach((valueColumn) => {\n                result[valueColumn.getId()] = oldValues[valueColumn.getId()];\n            });\n        }\n\n        return result;\n    }\n\n    private getValuesPivotNonLeaf(rowNode: RowNode, colId: string): any[] {\n        return rowNode.childrenAfterFilter!.map((childNode: RowNode) => childNode.aggData[colId]);\n    }\n\n    private getValuesFromMappedSet(mappedSet: any, keys: string[], valueColumn: AgColumn): any[] {\n        let mapPointer = mappedSet;\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            mapPointer = mapPointer ? mapPointer[key] : null;\n        }\n\n        if (!mapPointer) {\n            return [];\n        }\n\n        return mapPointer.map((rowNode: RowNode) => this.valueService.getValue(valueColumn, rowNode));\n    }\n\n    private getValuesNormal(rowNode: RowNode, valueColumns: AgColumn[], filteredOnly: boolean): any[][] {\n        // create 2d array, of all values for all valueColumns\n        const values: any[][] = [];\n        valueColumns.forEach(() => values.push([]));\n\n        const valueColumnCount = valueColumns.length;\n\n        const nodeList = filteredOnly ? rowNode.childrenAfterFilter : rowNode.childrenAfterGroup;\n        const rowCount = nodeList!.length;\n\n        for (let i = 0; i < rowCount; i++) {\n            const childNode = nodeList![i];\n            for (let j = 0; j < valueColumnCount; j++) {\n                const valueColumn = valueColumns[j];\n                // if the row is a group, then it will only have an agg result value,\n                // which means valueGetter is never used.\n                const value = this.valueService.getValue(valueColumn, childNode);\n                values[j].push(value);\n            }\n        }\n\n        return values;\n    }\n\n    public aggregateValues(\n        values: any[],\n        aggFuncOrString: string | IAggFunc,\n        column?: AgColumn,\n        rowNode?: RowNode,\n        pivotResultColumn?: AgColumn\n    ): any {\n        const aggFunc =\n            typeof aggFuncOrString === 'string' ? this.aggFuncService.getAggFunc(aggFuncOrString) : aggFuncOrString;\n\n        if (typeof aggFunc !== 'function') {\n            _errorOnce(`unrecognised aggregation function ${aggFuncOrString}`);\n            return null;\n        }\n\n        const aggFuncAny = aggFunc;\n        const params: IAggFuncParams = this.gos.addGridCommonParams({\n            values: values,\n            column: column,\n            colDef: column ? column.getColDef() : undefined,\n            pivotResultColumn: pivotResultColumn,\n            rowNode: rowNode,\n            data: rowNode ? rowNode.data : undefined,\n        } as any); // the \"as any\" is needed to allow the deprecation warning messages\n\n        return aggFuncAny(params);\n    }\n}\n", "import { AgColumn, BeanStub, GROUP_AUTO_COLUMN_ID, _mergeDeep, _missing, _warnOnce } from '@ag-grid-community/core';\nimport type {\n    BeanCollection,\n    ColDef,\n    ColumnEventType,\n    ColumnFactory,\n    ColumnModel,\n    ColumnNameService,\n    IAutoColService,\n    NamedBean,\n} from '@ag-grid-community/core';\n\nexport class AutoColService extends BeanStub implements NamedBean, IAutoColService {\n    beanName = 'autoColService' as const;\n\n    private columnModel: ColumnModel;\n    private columnNameService: ColumnNameService;\n    private columnFactory: ColumnFactory;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.columnModel = beans.columnModel;\n        this.columnNameService = beans.columnNameService;\n        this.columnFactory = beans.columnFactory;\n    }\n\n    public createAutoCols(rowGroupCols: AgColumn[]): AgColumn[] {\n        const autoCols: AgColumn[] = [];\n\n        const doingTreeData = this.gos.get('treeData');\n        let doingMultiAutoColumn = this.gos.isGroupMultiAutoColumn();\n\n        if (doingTreeData && doingMultiAutoColumn) {\n            _warnOnce(\n                'you cannot mix groupDisplayType = \"multipleColumns\" with treeData, only one column can be used to display groups when doing tree data'\n            );\n            doingMultiAutoColumn = false;\n        }\n\n        // if doing groupDisplayType = \"multipleColumns\", then we call the method multiple times, once\n        // for each column we are grouping by\n        if (doingMultiAutoColumn) {\n            rowGroupCols.forEach((rowGroupCol: AgColumn, index: number) => {\n                autoCols.push(this.createOneAutoCol(rowGroupCol, index));\n            });\n        } else {\n            autoCols.push(this.createOneAutoCol());\n        }\n\n        return autoCols;\n    }\n\n    public updateAutoCols(autoGroupCols: AgColumn[], source: ColumnEventType) {\n        autoGroupCols.forEach((col: AgColumn, index: number) => this.updateOneAutoCol(col, index, source));\n    }\n\n    // rowGroupCol and index are missing if groupDisplayType != \"multipleColumns\"\n    private createOneAutoCol(rowGroupCol?: AgColumn, index?: number): AgColumn {\n        // if doing multi, set the field\n        let colId: string;\n        if (rowGroupCol) {\n            colId = `${GROUP_AUTO_COLUMN_ID}-${rowGroupCol.getId()}`;\n        } else {\n            colId = GROUP_AUTO_COLUMN_ID;\n        }\n\n        const colDef = this.createAutoColDef(colId, rowGroupCol, index);\n        colDef.colId = colId;\n\n        const newCol = new AgColumn(colDef, null, colId, true);\n        this.createBean(newCol);\n        return newCol;\n    }\n\n    /**\n     * Refreshes an auto group col to load changes from defaultColDef or autoGroupColDef\n     */\n    private updateOneAutoCol(colToUpdate: AgColumn, index: number, source: ColumnEventType) {\n        const oldColDef = colToUpdate.getColDef();\n        const underlyingColId = typeof oldColDef.showRowGroup == 'string' ? oldColDef.showRowGroup : undefined;\n        const underlyingColumn = underlyingColId != null ? this.columnModel.getColDefCol(underlyingColId) : undefined;\n        const colDef = this.createAutoColDef(colToUpdate.getId(), underlyingColumn ?? undefined, index);\n\n        colToUpdate.setColDef(colDef, null, source);\n        this.columnFactory.applyColumnState(colToUpdate, colDef, source);\n    }\n\n    private createAutoColDef(colId: string, underlyingColumn?: AgColumn, index?: number): ColDef {\n        // if one provided by user, use it, otherwise create one\n        let res: ColDef = this.createBaseColDef(underlyingColumn);\n\n        const autoGroupColumnDef = this.gos.get('autoGroupColumnDef');\n        _mergeDeep(res, autoGroupColumnDef);\n\n        res = this.columnFactory.addColumnDefaultAndTypes(res, colId);\n\n        // For tree data the filter is always allowed\n        if (!this.gos.get('treeData')) {\n            // we would only allow filter if the user has provided field or value getter. otherwise the filter\n            // would not be able to work.\n            const noFieldOrValueGetter =\n                _missing(res.field) &&\n                _missing(res.valueGetter) &&\n                _missing(res.filterValueGetter) &&\n                res.filter !== 'agGroupColumnFilter';\n            if (noFieldOrValueGetter) {\n                res.filter = false;\n            }\n        }\n\n        // if showing many cols, we don't want to show more than one with a checkbox for selection\n        if (index && index > 0) {\n            res.headerCheckboxSelection = false;\n        }\n\n        const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();\n        const hasOwnData = res.valueGetter || res.field != null;\n        if (isSortingCoupled && !hasOwnData) {\n            // if col is coupled sorting, and has sort attribute, we want to ignore this\n            // because we only accept the sort on creation of the col\n            res.sortIndex = undefined;\n            res.initialSort = undefined;\n        }\n\n        return res;\n    }\n\n    private createBaseColDef(rowGroupCol?: AgColumn): ColDef {\n        const userDef = this.gos.get('autoGroupColumnDef');\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n\n        const res: ColDef = {\n            headerName: localeTextFunc('group', 'Group'),\n        };\n\n        const userHasProvidedGroupCellRenderer = userDef && (userDef.cellRenderer || userDef.cellRendererSelector);\n\n        // only add the default group cell renderer if user hasn't provided one\n        if (!userHasProvidedGroupCellRenderer) {\n            res.cellRenderer = 'agGroupCellRenderer';\n        }\n\n        // we never allow moving the group column\n        // defaultAutoColDef.suppressMovable = true;\n        if (rowGroupCol) {\n            const colDef = rowGroupCol.getColDef();\n            Object.assign(res, {\n                // cellRendererParams.groupKey: colDefToCopy.field;\n                headerName: this.columnNameService.getDisplayNameForColumn(rowGroupCol, 'header'),\n                headerValueGetter: colDef.headerValueGetter,\n            });\n\n            if (colDef.cellRenderer) {\n                Object.assign(res, {\n                    cellRendererParams: {\n                        innerRenderer: colDef.cellRenderer,\n                        innerRendererParams: colDef.cellRendererParams,\n                    },\n                });\n            }\n            res.showRowGroup = rowGroupCol.getColId();\n        } else {\n            res.showRowGroup = true;\n        }\n\n        return res;\n    }\n}\n", "import type { ComponentSelector, IColumnDropZonesService, NamedBean } from '@ag-grid-community/core';\nimport { BeanStub } from '@ag-grid-community/core';\n\nimport { AgGridHeaderDropZonesSelector } from './agGridHeaderDropZones';\n\nexport class ColumnDropZoneService extends BeanStub implements NamedBean, IColumnDropZonesService {\n    beanName = 'columnDropZonesService' as const;\n\n    getDropZoneSelector(): ComponentSelector {\n        return AgGridHeaderDropZonesSelector;\n    }\n}\n", "import type { BeanCollection, ColumnModel, ComponentSelector, FuncColsService } from '@ag-grid-community/core';\nimport { Component, _setAriaRole } from '@ag-grid-community/core';\n\nimport { PivotDropZonePanel } from './pivotDropZonePanel';\nimport { RowGroupDropZonePanel } from './rowGroupDropZonePanel';\n\nexport class AgGridHeaderDropZones extends Component {\n    private columnModel: ColumnModel;\n    private funcColsService: FuncColsService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n    }\n\n    private rowGroupComp: Component;\n    private pivotComp: Component;\n\n    constructor() {\n        super();\n    }\n\n    public postConstruct(): void {\n        this.setGui(this.createNorthPanel());\n        const onRowGroupChanged = this.onRowGroupChanged.bind(this);\n        this.addManagedEventListeners({\n            columnRowGroupChanged: onRowGroupChanged,\n            newColumnsLoaded: onRowGroupChanged,\n        });\n        this.addManagedPropertyListener('rowGroupPanelShow', onRowGroupChanged);\n        this.addManagedPropertyListener('pivotPanelShow', () => this.onPivotPanelShow());\n\n        this.onRowGroupChanged();\n    }\n\n    private createNorthPanel(): HTMLElement {\n        const topPanelGui = document.createElement('div');\n\n        topPanelGui.classList.add('ag-column-drop-wrapper');\n        _setAriaRole(topPanelGui, 'presentation');\n\n        this.rowGroupComp = new RowGroupDropZonePanel(true);\n        this.createManagedBean(this.rowGroupComp);\n\n        this.pivotComp = new PivotDropZonePanel(true);\n        this.createManagedBean(this.pivotComp);\n\n        topPanelGui.appendChild(this.rowGroupComp.getGui());\n        topPanelGui.appendChild(this.pivotComp.getGui());\n\n        const listener = this.onDropPanelVisible.bind(this);\n        this.addManagedListeners(this.rowGroupComp, {\n            displayChanged: listener,\n        });\n        this.addManagedListeners(this.pivotComp, {\n            displayChanged: listener,\n        });\n\n        this.onDropPanelVisible();\n\n        return topPanelGui;\n    }\n\n    private onDropPanelVisible(): void {\n        const bothDisplayed = this.rowGroupComp.isDisplayed() && this.pivotComp.isDisplayed();\n        const classStr = 'ag-column-drop-horizontal-half-width';\n        this.rowGroupComp.addOrRemoveCssClass(classStr, bothDisplayed);\n        this.pivotComp.addOrRemoveCssClass(classStr, bothDisplayed);\n    }\n\n    private onRowGroupChanged(): void {\n        if (!this.rowGroupComp) {\n            return;\n        }\n\n        const rowGroupPanelShow = this.gos.get('rowGroupPanelShow');\n\n        if (rowGroupPanelShow === 'always') {\n            this.rowGroupComp.setDisplayed(true);\n        } else if (rowGroupPanelShow === 'onlyWhenGrouping') {\n            const grouping = !this.funcColsService.isRowGroupEmpty();\n            this.rowGroupComp.setDisplayed(grouping);\n        } else {\n            this.rowGroupComp.setDisplayed(false);\n        }\n    }\n\n    private onPivotPanelShow() {\n        if (!this.pivotComp) {\n            return;\n        }\n\n        const pivotPanelShow = this.gos.get('pivotPanelShow');\n\n        if (pivotPanelShow === 'always') {\n            this.pivotComp.setDisplayed(true);\n        } else if (pivotPanelShow === 'onlyWhenPivoting') {\n            const pivoting = this.columnModel.isPivotActive();\n            this.pivotComp.setDisplayed(pivoting);\n        } else {\n            this.pivotComp.setDisplayed(false);\n        }\n    }\n}\n\nexport const AgGridHeaderDropZonesSelector: ComponentSelector = {\n    selector: 'AG-GRID-HEADER-DROP-ZONES',\n    component: AgGridHeaderDropZones,\n};\n", "import type {\n    AgColumn,\n    DragAndDropIcon,\n    DraggingEvent,\n    ITooltipParams,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { _createIconNoSpan } from '@ag-grid-community/core';\n\nimport { BaseDropZonePanel } from './baseDropZonePanel';\n\nexport class PivotDropZonePanel extends BaseDropZonePanel {\n    constructor(horizontal: boolean) {\n        super(horizontal, 'pivot');\n    }\n\n    public postConstruct(): void {\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to set column labels');\n        const title = localeTextFunc('pivots', 'Column Labels');\n\n        super.init({\n            icon: _createIconNoSpan('pivotPanel', this.gos, null)!,\n            emptyMessage: emptyMessage,\n            title: title,\n        });\n\n        this.addManagedEventListeners({\n            newColumnsLoaded: this.refresh.bind(this),\n            columnPivotChanged: this.refresh.bind(this),\n            columnPivotModeChanged: this.checkVisibility.bind(this),\n        });\n\n        this.refresh();\n    }\n\n    protected getAriaLabel(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n        const label = translate('ariaPivotDropZonePanelLabel', 'Column Labels');\n\n        return label;\n    }\n\n    public override getTooltipParams(): WithoutGridCommon<ITooltipParams> {\n        const res = super.getTooltipParams();\n        res.location = 'pivotColumnsList';\n        return res;\n    }\n\n    private refresh(): void {\n        this.checkVisibility();\n        this.refreshGui();\n    }\n\n    private checkVisibility(): void {\n        const pivotMode = this.columnModel.isPivotMode();\n\n        if (this.isHorizontal()) {\n            // what we do for horizontal (ie the pivot panel at the top) depends\n            // on the user property as well as pivotMode.\n            switch (this.gos.get('pivotPanelShow')) {\n                case 'always':\n                    this.setDisplayed(pivotMode);\n                    break;\n                case 'onlyWhenPivoting': {\n                    const pivotActive = this.columnModel.isPivotActive();\n                    this.setDisplayed(pivotMode && pivotActive);\n                    break;\n                }\n                default:\n                    // never show it\n                    this.setDisplayed(false);\n                    break;\n            }\n        } else {\n            // in toolPanel, the pivot panel is always shown when pivot mode is on\n            this.setDisplayed(pivotMode);\n        }\n    }\n\n    protected isItemDroppable(column: AgColumn, draggingEvent: DraggingEvent): boolean {\n        // we never allow grouping of secondary columns\n        if (this.gos.get('functionsReadOnly') || !column.isPrimary()) {\n            return false;\n        }\n\n        return column.isAllowPivot() && (!column.isPivotActive() || this.isSourceEventFromTarget(draggingEvent));\n    }\n\n    protected updateItems(columns: AgColumn[]): void {\n        this.funcColsService.setPivotColumns(columns, 'toolPanelUi');\n    }\n\n    protected getIconName(): DragAndDropIcon {\n        return this.isPotentialDndItems() ? 'pivot' : 'notAllowed';\n    }\n\n    protected getExistingItems(): AgColumn[] {\n        return this.funcColsService.getPivotColumns();\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ColumnEventType,\n    ColumnModel,\n    DragItem,\n    DraggingEvent,\n    DropTarget,\n    FuncColsService,\n} from '@ag-grid-community/core';\nimport { DragSourceType } from '@ag-grid-community/core';\nimport type { PillDropZonePanelParams } from '@ag-grid-enterprise/core';\nimport { PillDropZonePanel } from '@ag-grid-enterprise/core';\n\nimport { DropZoneColumnComp } from './dropZoneColumnComp';\n\nexport type TDropZone = 'rowGroup' | 'pivot' | 'aggregation';\n\nexport abstract class BaseDropZonePanel extends PillDropZonePanel<DropZoneColumnComp, AgColumn> {\n    protected columnModel: ColumnModel;\n    protected funcColsService: FuncColsService;\n\n    public override wireBeans(beans: BeanCollection) {\n        super.wireBeans(beans);\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n    }\n\n    constructor(\n        horizontal: boolean,\n        private dropZonePurpose: TDropZone\n    ) {\n        super(horizontal);\n    }\n\n    public override init(params: PillDropZonePanelParams): void {\n        super.init(params);\n\n        this.addManagedEventListeners({ newColumnsLoaded: this.refreshGui.bind(this) });\n\n        this.addManagedPropertyListeners(\n            ['functionsReadOnly', 'rowGroupPanelSuppressSort', 'groupLockGroupColumns'],\n            this.refreshGui.bind(this)\n        );\n    }\n\n    protected getItems(dragItem: DragItem): AgColumn[] {\n        return (dragItem.columns as AgColumn[]) ?? [];\n    }\n\n    protected isInterestedIn(type: DragSourceType): boolean {\n        // not interested in row drags\n        return type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel;\n    }\n\n    protected override minimumAllowedNewInsertIndex(): number {\n        const numberOfLockedCols = this.gos.get('groupLockGroupColumns');\n        const numberOfGroupCols = this.funcColsService.getRowGroupColumns().length;\n        if (numberOfLockedCols === -1) {\n            return numberOfGroupCols;\n        }\n        return Math.min(numberOfLockedCols, numberOfGroupCols);\n    }\n\n    private showOrHideColumnOnExit(draggingEvent: DraggingEvent): boolean {\n        return this.isRowGroupPanel() && !this.gos.get('suppressRowGroupHidesColumns') && !draggingEvent.fromNudge;\n    }\n\n    protected override handleDragEnterEnd(draggingEvent: DraggingEvent): void {\n        const hideColumnOnExit = this.showOrHideColumnOnExit(draggingEvent);\n\n        if (hideColumnOnExit) {\n            const dragItem = draggingEvent.dragSource.getDragItem();\n            const columns = dragItem.columns as AgColumn[];\n            this.setColumnsVisible(columns, false, 'uiColumnDragged');\n        }\n    }\n\n    protected override handleDragLeaveEnd(draggingEvent: DraggingEvent): void {\n        const showColumnOnExit = this.showOrHideColumnOnExit(draggingEvent);\n\n        if (showColumnOnExit) {\n            const dragItem = draggingEvent.dragSource.getDragItem();\n\n            this.setColumnsVisible(dragItem.columns as AgColumn[], true, 'uiColumnDragged');\n        }\n    }\n\n    public setColumnsVisible(columns: AgColumn[] | null | undefined, visible: boolean, source: ColumnEventType) {\n        if (columns) {\n            const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);\n            this.columnModel.setColsVisible(allowedCols, visible, source);\n        }\n    }\n\n    private isRowGroupPanel() {\n        return this.dropZonePurpose === 'rowGroup';\n    }\n\n    protected createPillComponent(\n        column: AgColumn,\n        dropTarget: DropTarget,\n        ghost: boolean,\n        horizontal: boolean\n    ): DropZoneColumnComp {\n        return new DropZoneColumnComp(column, dropTarget, ghost, this.dropZonePurpose, horizontal);\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ColumnModel,\n    ColumnNameService,\n    DragAndDropIcon,\n    DragItem,\n    DropTarget,\n    FuncColsService,\n    IAggFuncService,\n    PopupService,\n    SortController,\n    SortIndicatorComp,\n} from '@ag-grid-community/core';\nimport {\n    Component,\n    DragSourceType,\n    KeyCode,\n    RefPlaceholder,\n    SortIndicatorSelector,\n    _loadTemplate,\n} from '@ag-grid-community/core';\nimport { PillDragComp, VirtualList } from '@ag-grid-enterprise/core';\n\nimport type { TDropZone } from './baseDropZonePanel';\n\nexport class DropZoneColumnComp extends PillDragComp<AgColumn> {\n    private popupService: PopupService;\n    private sortController: SortController;\n    private columnModel: ColumnModel;\n    private columnNameService: ColumnNameService;\n    private funcColsService: FuncColsService;\n    private aggFuncService?: IAggFuncService;\n\n    public override wireBeans(beans: BeanCollection) {\n        super.wireBeans(beans);\n        this.popupService = beans.popupService;\n        this.sortController = beans.sortController;\n        this.columnModel = beans.columnModel;\n        this.columnNameService = beans.columnNameService;\n        this.funcColsService = beans.funcColsService;\n        this.aggFuncService = beans.aggFuncService;\n    }\n\n    private readonly eSortIndicator: SortIndicatorComp = RefPlaceholder;\n\n    private displayName: string | null;\n    private popupShowing = false;\n\n    constructor(\n        private column: AgColumn,\n        dragSourceDropTarget: DropTarget,\n        ghost: boolean,\n        private dropZonePurpose: TDropZone,\n        horizontal: boolean\n    ) {\n        super(\n            dragSourceDropTarget,\n            ghost,\n            horizontal,\n            /* html */ `\n                <span role=\"option\">\n                    <span data-ref=\"eDragHandle\" class=\"ag-drag-handle ag-column-drop-cell-drag-handle\" role=\"presentation\"></span>\n                    <span data-ref=\"eText\" class=\"ag-column-drop-cell-text\" aria-hidden=\"true\"></span>\n                    <ag-sort-indicator data-ref=\"eSortIndicator\"></ag-sort-indicator>\n                    <span data-ref=\"eButton\" class=\"ag-column-drop-cell-button\" role=\"presentation\"></span>\n                </span>\n            `,\n            [SortIndicatorSelector]\n        );\n    }\n\n    public override postConstruct(): void {\n        this.displayName = this.columnNameService.getDisplayNameForColumn(this.column, 'columnDrop');\n\n        super.postConstruct();\n\n        this.setupSort();\n\n        this.addManagedEventListeners({\n            sortChanged: () => {\n                this.setupAria();\n            },\n        });\n\n        if (this.isGroupingZone()) {\n            this.addManagedPropertyListener('groupLockGroupColumns', () => {\n                this.refreshRemove();\n                this.refreshDraggable();\n                this.setupAria();\n            });\n        }\n    }\n\n    public getItem(): AgColumn {\n        return this.column;\n    }\n\n    protected getDisplayName(): string {\n        return this.displayName!;\n    }\n\n    protected getTooltip(): string | null | undefined {\n        return this.column.getColDef().headerTooltip;\n    }\n\n    protected override addAdditionalAriaInstructions(\n        ariaInstructions: string[],\n        translate: (key: string, defaultValue: string) => string\n    ): void {\n        const isSortSuppressed = this.gos.get('rowGroupPanelSuppressSort');\n        const isFunctionsReadOnly = this.gos.get('functionsReadOnly');\n        if (this.isAggregationZone() && !isFunctionsReadOnly) {\n            const aggregationMenuAria = translate(\n                'ariaDropZoneColumnValueItemDescription',\n                'Press ENTER to change the aggregation type'\n            );\n            ariaInstructions.push(aggregationMenuAria);\n        }\n\n        if (this.isGroupingZone() && this.column.isSortable() && !isSortSuppressed) {\n            const sortProgressAria = translate('ariaDropZoneColumnGroupItemDescription', 'Press ENTER to sort');\n            ariaInstructions.push(sortProgressAria);\n        }\n\n        super.addAdditionalAriaInstructions(ariaInstructions, translate);\n    }\n\n    protected override isDraggable(): boolean {\n        return this.isReadOnly();\n    }\n\n    protected override isRemovable(): boolean {\n        return this.isReadOnly();\n    }\n\n    private isReadOnly(): boolean {\n        return !this.isGroupingAndLocked() && !this.gos.get('functionsReadOnly');\n    }\n\n    protected getAriaDisplayName(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n\n        const { name, aggFuncName } = this.getColumnAndAggFuncName();\n        const aggSeparator = translate('ariaDropZoneColumnComponentAggFuncSeparator', ' of ');\n        const sortDirection = {\n            asc: translate('ariaDropZoneColumnComponentSortAscending', 'ascending'),\n            desc: translate('ariaDropZoneColumnComponentSortDescending', 'descending'),\n        };\n        const columnSort = this.column.getSort();\n        const isSortSuppressed = this.gos.get('rowGroupPanelSuppressSort');\n        return [\n            aggFuncName && `${aggFuncName}${aggSeparator}`,\n            name,\n            this.isGroupingZone() && !isSortSuppressed && columnSort && `, ${sortDirection[columnSort]}`,\n        ]\n            .filter((part) => !!part)\n            .join('');\n    }\n\n    private getColumnAndAggFuncName(): { name: string; aggFuncName: string } {\n        const name = this.displayName as string;\n        let aggFuncName: string = '';\n\n        if (this.isAggregationZone()) {\n            const aggFunc = this.column.getAggFunc();\n            // if aggFunc is a string, we can use it, but if it's a function, then we swap with 'func'\n            const aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'agg';\n            const localeTextFunc = this.localeService.getLocaleTextFunc();\n            aggFuncName = localeTextFunc(aggFuncString, aggFuncString);\n        }\n\n        return { name, aggFuncName };\n    }\n\n    public setupSort(): void {\n        const canSort = this.column.isSortable();\n        const isGroupingZone = this.isGroupingZone();\n        if (!canSort || !isGroupingZone) {\n            return;\n        }\n\n        if (!this.gos.get('rowGroupPanelSuppressSort')) {\n            this.eSortIndicator.setupSort(this.column, true);\n            const performSort = (event: MouseEvent | KeyboardEvent) => {\n                event.preventDefault();\n                const sortUsingCtrl = this.gos.get('multiSortKey') === 'ctrl';\n                const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;\n                this.sortController.progressSort(this.column, multiSort, 'uiColumnSorted');\n            };\n\n            this.addGuiEventListener('click', performSort);\n            this.addGuiEventListener('keydown', (e: KeyboardEvent) => {\n                const isEnter = e.key === KeyCode.ENTER;\n                if (isEnter && this.isGroupingZone()) {\n                    performSort(e);\n                }\n            });\n        }\n    }\n\n    protected override getDefaultIconName(): DragAndDropIcon {\n        return 'hide';\n    }\n\n    protected createGetDragItem(): () => DragItem {\n        const { column } = this;\n        return () => {\n            const visibleState: { [key: string]: boolean } = {};\n            visibleState[column.getId()] = column.isVisible();\n            return {\n                columns: [column],\n                visibleState: visibleState,\n            };\n        };\n    }\n\n    protected override setupComponents(): void {\n        super.setupComponents();\n\n        if (this.isAggregationZone() && !this.gos.get('functionsReadOnly')) {\n            this.addGuiEventListener('click', this.onShowAggFuncSelection.bind(this));\n        }\n    }\n\n    protected override onKeyDown(e: KeyboardEvent): void {\n        super.onKeyDown(e);\n\n        const isEnter = e.key === KeyCode.ENTER;\n        if (isEnter && this.isAggregationZone() && !this.gos.get('functionsReadOnly')) {\n            e.preventDefault();\n            this.onShowAggFuncSelection();\n        }\n    }\n\n    protected override getDisplayValue(): string {\n        const { name, aggFuncName } = this.getColumnAndAggFuncName();\n        return this.isAggregationZone() ? `${aggFuncName}(${name})` : name;\n    }\n\n    private onShowAggFuncSelection(): void {\n        if (this.popupShowing) {\n            return;\n        }\n\n        this.popupShowing = true;\n\n        const virtualList = new VirtualList({ cssIdentifier: 'select-agg-func' });\n        const rows = this.aggFuncService!.getFuncNames(this.column);\n        const eGui = this.getGui();\n        const virtualListGui = virtualList.getGui();\n\n        virtualList.setModel({\n            getRow: function (index: number) {\n                return rows[index];\n            },\n            getRowCount: function () {\n                return rows.length;\n            },\n        });\n\n        this.createBean(virtualList);\n\n        const ePopup = _loadTemplate(/* html*/ `<div class=\"ag-select-agg-func-popup\"></div>`);\n        ePopup.style.top = '0px';\n        ePopup.style.left = '0px';\n        ePopup.appendChild(virtualListGui);\n        ePopup.style.width = `${eGui.clientWidth}px`;\n\n        const [focusoutListener] = this.addManagedElementListeners(ePopup, {\n            focusout: (e: FocusEvent) => {\n                if (!ePopup.contains(e.relatedTarget as HTMLElement) && addPopupRes) {\n                    addPopupRes.hideFunc();\n                }\n            },\n        });\n\n        const popupHiddenFunc = (callbackEvent?: KeyboardEvent) => {\n            this.destroyBean(virtualList);\n            this.popupShowing = false;\n\n            if (callbackEvent?.key === 'Escape') {\n                eGui.focus();\n            }\n\n            if (focusoutListener) {\n                focusoutListener();\n            }\n        };\n\n        const translate = this.localeService.getLocaleTextFunc();\n\n        const addPopupRes = this.popupService.addPopup({\n            modal: true,\n            eChild: ePopup,\n            closeOnEsc: true,\n            closedCallback: popupHiddenFunc,\n            ariaLabel: translate('ariaLabelAggregationFunction', 'Aggregation Function'),\n        });\n\n        if (addPopupRes) {\n            virtualList.setComponentCreator(this.createAggSelect.bind(this, addPopupRes.hideFunc));\n        }\n\n        virtualList.addGuiEventListener('keydown', (e: KeyboardEvent) => {\n            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {\n                const row = virtualList.getLastFocusedRow();\n\n                if (row == null) {\n                    return;\n                }\n\n                const comp = virtualList.getComponentAt(row) as AggItemComp;\n\n                if (comp) {\n                    comp.selectItem();\n                }\n            }\n        });\n\n        this.popupService.positionPopupByComponent({\n            type: 'aggFuncSelect',\n            eventSource: eGui,\n            ePopup: ePopup,\n            keepWithinBounds: true,\n            column: this.column,\n            position: 'under',\n        });\n\n        virtualList.refresh();\n\n        let rowToFocus = rows.findIndex((r) => r === this.column.getAggFunc());\n        if (rowToFocus === -1) {\n            rowToFocus = 0;\n        }\n\n        virtualList.focusRow(rowToFocus);\n    }\n\n    private createAggSelect(hidePopup: () => void, value: any): Component {\n        const itemSelected = () => {\n            hidePopup();\n            this.funcColsService.setColumnAggFunc(this.column, value, 'toolPanelDragAndDrop');\n        };\n\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const aggFuncString = value.toString();\n        const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n        const comp = new AggItemComp(itemSelected, aggFuncStringTranslated);\n\n        return comp;\n    }\n\n    private isGroupingAndLocked(): boolean {\n        return this.isGroupingZone() && this.columnModel.isColGroupLocked(this.column);\n    }\n\n    private isAggregationZone() {\n        return this.dropZonePurpose === 'aggregation';\n    }\n\n    private isGroupingZone() {\n        return this.dropZonePurpose === 'rowGroup';\n    }\n\n    protected getDragSourceType(): DragSourceType {\n        return DragSourceType.ToolPanel;\n    }\n\n    public override destroy(): void {\n        super.destroy();\n        (this.column as any) = null;\n    }\n}\n\nclass AggItemComp extends Component {\n    public selectItem: () => void;\n\n    constructor(itemSelected: () => void, value: string) {\n        super(/* html */ `<div class=\"ag-select-agg-func-item\"/>`);\n        this.selectItem = itemSelected;\n        this.getGui().innerText = value;\n        this.addGuiEventListener('click', this.selectItem);\n    }\n}\n", "import type {\n    AgColumn,\n    DragAndDropIcon,\n    DraggingEvent,\n    ITooltipParams,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { _createIconNoSpan } from '@ag-grid-community/core';\n\nimport { BaseDropZonePanel } from './baseDropZonePanel';\n\nexport class RowGroupDropZonePanel extends BaseDropZonePanel {\n    constructor(horizontal: boolean) {\n        super(horizontal, 'rowGroup');\n    }\n\n    public postConstruct(): void {\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const emptyMessage = localeTextFunc('rowGroupColumnsEmptyMessage', 'Drag here to set row groups');\n        const title = localeTextFunc('groups', 'Row Groups');\n\n        super.init({\n            icon: _createIconNoSpan('rowGroupPanel', this.gos, null)!,\n            emptyMessage: emptyMessage,\n            title,\n        });\n\n        this.addManagedEventListeners({ columnRowGroupChanged: this.refreshGui.bind(this) });\n    }\n\n    protected getAriaLabel(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n        const label = translate('ariaRowGroupDropZonePanelLabel', 'Row Groups');\n\n        return label;\n    }\n\n    public override getTooltipParams(): WithoutGridCommon<ITooltipParams> {\n        const res = super.getTooltipParams();\n        res.location = 'rowGroupColumnsList';\n\n        return res;\n    }\n\n    protected isItemDroppable(column: AgColumn, draggingEvent: DraggingEvent): boolean {\n        // we never allow grouping of secondary columns\n        if (this.gos.get('functionsReadOnly') || !column.isPrimary()) {\n            return false;\n        }\n\n        return column.isAllowRowGroup() && (!column.isRowGroupActive() || this.isSourceEventFromTarget(draggingEvent));\n    }\n\n    protected updateItems(columns: AgColumn[]) {\n        this.funcColsService.setRowGroupColumns(columns, 'toolPanelUi');\n    }\n\n    protected getIconName(): DragAndDropIcon {\n        return this.isPotentialDndItems() ? 'group' : 'notAllowed';\n    }\n\n    protected getExistingItems(): AgColumn[] {\n        return this.funcColsService.getRowGroupColumns();\n    }\n}\n", "import type {\n    BeanCollection,\n    ColumnModel,\n    FilterManager,\n    IRowNodeStage,\n    NamedBean,\n    RowNode,\n    StageExecuteParams,\n} from '@ag-grid-community/core';\nimport { BeanStub } from '@ag-grid-community/core';\n\nexport class FilterAggregatesStage extends BeanStub implements NamedBean, IRowNodeStage {\n    beanName = 'filterAggregatesStage' as const;\n\n    private filterManager?: FilterManager;\n    private columnModel: ColumnModel;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.filterManager = beans.filterManager;\n        this.columnModel = beans.columnModel;\n    }\n\n    public execute(params: StageExecuteParams): void {\n        const isPivotMode = this.columnModel.isPivotMode();\n        const isAggFilterActive =\n            this.filterManager?.isAggregateFilterPresent() || this.filterManager?.isAggregateQuickFilterPresent();\n\n        // This is the default filter for applying only to leaf nodes, realistically this should not apply as primary agg columns,\n        // should not be applied by the filterManager if getGroupAggFiltering is missing. Predicate will apply filters to leaf level.\n        const defaultPrimaryColumnPredicate = (params: { node: RowNode }) => !params.node.group;\n\n        // Default secondary column predicate, selecting only leaf level groups.\n        const defaultSecondaryColumnPredicate = (params: { node: RowNode }) => params.node.leafGroup;\n\n        // The predicate to determine whether filters should apply to this row. Either defined by the user in groupAggFiltering or a default depending\n        // on current pivot mode status.\n        const applyFilterToNode =\n            this.gos.getGroupAggFiltering() ||\n            (isPivotMode ? defaultSecondaryColumnPredicate : defaultPrimaryColumnPredicate);\n\n        const { changedPath } = params;\n\n        const preserveChildren = (node: RowNode, recursive = false) => {\n            if (node.childrenAfterFilter) {\n                node.childrenAfterAggFilter = node.childrenAfterFilter;\n                if (recursive) {\n                    node.childrenAfterAggFilter.forEach((child) => preserveChildren(child, recursive));\n                }\n                this.setAllChildrenCount(node);\n            }\n\n            if (node.sibling) {\n                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;\n            }\n        };\n\n        const filterChildren = (node: RowNode) => {\n            node.childrenAfterAggFilter =\n                node.childrenAfterFilter?.filter((child: RowNode) => {\n                    const shouldFilterRow = applyFilterToNode({ node: child });\n                    if (shouldFilterRow) {\n                        const doesNodePassFilter = this.filterManager!.doesRowPassAggregateFilters({ rowNode: child });\n                        if (doesNodePassFilter) {\n                            // Node has passed, so preserve children\n                            preserveChildren(child, true);\n                            return true;\n                        }\n                    }\n                    const hasChildPassed = child.childrenAfterAggFilter?.length;\n                    return hasChildPassed;\n                }) || null;\n\n            this.setAllChildrenCount(node);\n            if (node.sibling) {\n                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;\n            }\n        };\n\n        changedPath!.forEachChangedNodeDepthFirst(isAggFilterActive ? filterChildren : preserveChildren, true);\n    }\n\n    private setAllChildrenCountTreeData(rowNode: RowNode) {\n        // for tree data, we include all children, groups and leafs\n        let allChildrenCount = 0;\n        rowNode.childrenAfterAggFilter!.forEach((child: RowNode) => {\n            // include child itself\n            allChildrenCount++;\n            // include children of children\n            allChildrenCount += child.allChildrenCount as any;\n        });\n        rowNode.setAllChildrenCount(allChildrenCount);\n    }\n\n    private setAllChildrenCountGridGrouping(rowNode: RowNode) {\n        // for grid data, we only count the leafs\n        let allChildrenCount = 0;\n        rowNode.childrenAfterAggFilter!.forEach((child: RowNode) => {\n            if (child.group) {\n                allChildrenCount += child.allChildrenCount as any;\n            } else {\n                allChildrenCount++;\n            }\n        });\n        rowNode.setAllChildrenCount(allChildrenCount);\n    }\n\n    private setAllChildrenCount(rowNode: RowNode) {\n        if (!rowNode.hasChildren()) {\n            rowNode.setAllChildrenCount(null);\n            return;\n        }\n\n        if (this.gos.get('treeData')) {\n            this.setAllChildrenCountTreeData(rowNode);\n        } else {\n            this.setAllChildrenCountGridGrouping(rowNode);\n        }\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ColumnNameService,\n    FilterManager,\n    FuncColsService,\n    IAfterGuiAttachedParams,\n    IFilterComp,\n    IFilterParams,\n} from '@ag-grid-community/core';\nimport {\n    AgPromise,\n    AgSelect,\n    FilterWrapperComp,\n    RefPlaceholder,\n    TabGuardComp,\n    _clearElement,\n    _loadTemplate,\n    _setDisplayed,\n    _warnOnce,\n} from '@ag-grid-community/core';\n\ninterface FilterColumnPair {\n    filter: IFilterComp;\n    column: AgColumn;\n}\n\nexport type GroupFilterEvent = 'columnRowGroupChanged' | 'selectedColumnChanged';\nexport class GroupFilter extends TabGuardComp<GroupFilterEvent> implements IFilterComp {\n    private filterManager?: FilterManager;\n    private columnNameService: ColumnNameService;\n    private funcColsService: FuncColsService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.filterManager = beans.filterManager;\n        this.columnNameService = beans.columnNameService;\n        this.funcColsService = beans.funcColsService;\n    }\n\n    private readonly eGroupField: HTMLElement = RefPlaceholder;\n    private readonly eUnderlyingFilter: HTMLElement = RefPlaceholder;\n\n    private params: IFilterParams;\n    private groupColumn: AgColumn;\n    private selectedColumn: AgColumn | undefined;\n    private selectedFilter: IFilterComp | undefined;\n    private filterColumnPairs: FilterColumnPair[] | undefined;\n    private eGroupFieldSelect: AgSelect;\n    private afterGuiAttachedParams: IAfterGuiAttachedParams | undefined;\n    private filterWrapperComp?: FilterWrapperComp;\n\n    constructor() {\n        super(/* html */ `\n            <div class=\"ag-group-filter\">\n                <div data-ref=\"eGroupField\"></div>\n                <div data-ref=\"eUnderlyingFilter\"></div>\n            </div>\n        `);\n    }\n\n    public postConstruct() {\n        this.initialiseTabGuard({});\n    }\n\n    public init(params: IFilterParams): AgPromise<void> {\n        this.params = params;\n        this.validateParams();\n        return this.updateGroups().then(() => {\n            this.addManagedEventListeners({ columnRowGroupChanged: () => this.onColumnRowGroupChanged() });\n        });\n    }\n\n    private validateParams(): void {\n        const { colDef } = this.params;\n        if (colDef.field) {\n            _warnOnce(\n                'Group Column Filter does not work with the colDef property \"field\". This property will be ignored.'\n            );\n        }\n        if (colDef.filterValueGetter) {\n            _warnOnce(\n                'Group Column Filter does not work with the colDef property \"filterValueGetter\". This property will be ignored.'\n            );\n        }\n        if (colDef.filterParams) {\n            _warnOnce(\n                'Group Column Filter does not work with the colDef property \"filterParams\". This property will be ignored.'\n            );\n        }\n    }\n\n    private updateGroups(): AgPromise<void> {\n        const sourceColumns = this.updateGroupField();\n        return this.getUnderlyingFilters(sourceColumns);\n    }\n\n    private getSourceColumns(): AgColumn[] {\n        this.groupColumn = this.params.column as AgColumn;\n        if (this.gos.get('treeData')) {\n            _warnOnce(\n                'Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.'\n            );\n            return [];\n        }\n        const sourceColumns = this.funcColsService.getSourceColumnsForGroupColumn(this.groupColumn);\n        if (!sourceColumns) {\n            _warnOnce('Group Column Filter only works on group columns. Please use a different filter.');\n            return [];\n        }\n        return sourceColumns;\n    }\n\n    private updateGroupField(): AgColumn[] | null {\n        _clearElement(this.eGroupField);\n        if (this.eGroupFieldSelect) {\n            this.destroyBean(this.eGroupFieldSelect);\n        }\n        const allSourceColumns = this.getSourceColumns();\n        const sourceColumns = allSourceColumns.filter((sourceColumn) => sourceColumn.isFilterAllowed());\n        if (!sourceColumns.length) {\n            this.selectedColumn = undefined;\n            _setDisplayed(this.eGroupField, false);\n            return null;\n        }\n        if (allSourceColumns.length === 1) {\n            // we only want to hide the group field element if there's only one group column.\n            // If there's one group column that has a filter, but multiple columns in total,\n            // we should still show the select so the user knows which column it's for.\n            this.selectedColumn = sourceColumns[0];\n            _setDisplayed(this.eGroupField, false);\n        } else {\n            // keep the old selected column if it's still valid\n            if (\n                !this.selectedColumn ||\n                !sourceColumns.some((column) => column.getId() === this.selectedColumn!.getId())\n            ) {\n                this.selectedColumn = sourceColumns[0];\n            }\n            this.createGroupFieldSelectElement(sourceColumns);\n            this.eGroupField.appendChild(this.eGroupFieldSelect.getGui());\n            this.eGroupField.appendChild(_loadTemplate(/* html */ `<div class=\"ag-filter-separator\"></div>`));\n            _setDisplayed(this.eGroupField, true);\n        }\n\n        return sourceColumns;\n    }\n\n    private createGroupFieldSelectElement(sourceColumns: AgColumn[]): void {\n        this.eGroupFieldSelect = this.createManagedBean(new AgSelect());\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        this.eGroupFieldSelect.setLabel(localeTextFunc('groupFilterSelect', 'Select field:'));\n        this.eGroupFieldSelect.setLabelAlignment('top');\n        this.eGroupFieldSelect.addOptions(\n            sourceColumns.map((sourceColumn) => ({\n                value: sourceColumn.getId(),\n                text: this.columnNameService.getDisplayNameForColumn(sourceColumn, 'groupFilter', false) ?? undefined,\n            }))\n        );\n        this.eGroupFieldSelect.setValue(this.selectedColumn!.getId());\n        this.eGroupFieldSelect.onValueChange((newValue) => this.updateSelectedColumn(newValue));\n        this.eGroupFieldSelect.addCssClass('ag-group-filter-field-select-wrapper');\n        if (sourceColumns.length === 1) {\n            this.eGroupFieldSelect.setDisabled(true);\n        }\n    }\n\n    private getUnderlyingFilters(sourceColumns: AgColumn[] | null): AgPromise<void> {\n        if (!sourceColumns) {\n            this.filterColumnPairs = undefined;\n            this.selectedFilter = undefined;\n            this.groupColumn.setFilterActive(false, 'columnRowGroupChanged');\n            return AgPromise.resolve();\n        }\n        const filterPromises: AgPromise<IFilterComp>[] = [];\n        const filterColumnPairs: FilterColumnPair[] = [];\n        sourceColumns.forEach((column) => {\n            const filterWrapper = this.filterManager!.getOrCreateFilterWrapper(column);\n            if (filterWrapper?.filterPromise) {\n                filterPromises.push(\n                    filterWrapper.filterPromise.then((filter) => {\n                        if (filter) {\n                            filterColumnPairs.push({\n                                filter,\n                                column,\n                            });\n                        }\n                        if (column.getId() === this.selectedColumn!.getId()) {\n                            this.selectedFilter = filter ?? undefined;\n                        }\n                        return filter!;\n                    })\n                );\n            }\n        });\n        return AgPromise.all(filterPromises).then(() => {\n            this.filterColumnPairs = filterColumnPairs;\n            this.groupColumn.setFilterActive(this.isFilterActive(), 'columnRowGroupChanged');\n        });\n    }\n\n    private addUnderlyingFilterElement(): AgPromise<void> {\n        _clearElement(this.eUnderlyingFilter);\n        if (!this.selectedColumn) {\n            return AgPromise.resolve();\n        }\n        const comp = this.createManagedBean(new FilterWrapperComp(this.selectedColumn, 'COLUMN_MENU'));\n        this.filterWrapperComp = comp;\n        if (!comp.hasFilter()) {\n            return AgPromise.resolve();\n        }\n        this.eUnderlyingFilter.appendChild(comp.getGui());\n\n        return (\n            comp.getFilter()?.then(() => {\n                comp.afterGuiAttached?.(this.afterGuiAttachedParams);\n                if (\n                    !this.afterGuiAttachedParams?.suppressFocus &&\n                    this.eGroupFieldSelect &&\n                    !this.eGroupFieldSelect.isDisabled()\n                ) {\n                    this.eGroupFieldSelect.getFocusableElement().focus();\n                }\n            }) ?? AgPromise.resolve()\n        );\n    }\n\n    private updateSelectedColumn(columnId: string | null | undefined): void {\n        if (!columnId) {\n            return;\n        }\n        this.filterWrapperComp?.afterGuiDetached();\n        this.destroyBean(this.filterWrapperComp);\n        const selectedFilterColumnPair = this.getFilterColumnPair(columnId);\n        this.selectedColumn = selectedFilterColumnPair?.column;\n        this.selectedFilter = selectedFilterColumnPair?.filter;\n\n        this.dispatchLocalEvent({\n            type: 'selectedColumnChanged',\n        });\n        this.addUnderlyingFilterElement();\n    }\n\n    public isFilterActive(): boolean {\n        return !!this.filterColumnPairs?.some(({ filter }) => filter.isFilterActive());\n    }\n\n    public doesFilterPass(): boolean {\n        return true;\n    }\n\n    public getModel(): null {\n        return null;\n    }\n\n    public setModel(): AgPromise<void> {\n        return AgPromise.resolve();\n    }\n\n    public afterGuiAttached(params?: IAfterGuiAttachedParams): void {\n        this.afterGuiAttachedParams = params;\n        this.addUnderlyingFilterElement();\n    }\n\n    public afterGuiDetached(): void {\n        _clearElement(this.eUnderlyingFilter);\n        this.selectedFilter?.afterGuiDetached?.();\n    }\n\n    private onColumnRowGroupChanged(): void {\n        this.updateGroups().then(() => {\n            this.dispatchLocalEvent({\n                type: 'columnRowGroupChanged',\n            });\n        });\n    }\n\n    private getFilterColumnPair(columnId: string | undefined): FilterColumnPair | undefined {\n        if (!columnId) {\n            return undefined;\n        }\n        return this.filterColumnPairs?.find(({ column }) => column.getId() === columnId);\n    }\n\n    public getSelectedFilter(): IFilterComp | undefined {\n        return this.selectedFilter;\n    }\n\n    public getSelectedColumn(): AgColumn | undefined {\n        return this.selectedColumn;\n    }\n\n    public isFilterAllowed(): boolean {\n        return !!this.selectedColumn;\n    }\n\n    public override destroy(): void {\n        super.destroy();\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ColumnEvent,\n    ColumnNameService,\n    FilterChangedEvent,\n    FilterManager,\n    IFloatingFilterComp,\n    IFloatingFilterParams,\n} from '@ag-grid-community/core';\nimport { AgInputTextField, AgPromise, Component, RefPlaceholder, _clearElement } from '@ag-grid-community/core';\n\nimport type { GroupFilter } from './groupFilter';\n\nexport class GroupFloatingFilterComp extends Component implements IFloatingFilterComp<GroupFilter> {\n    private columnNameService: ColumnNameService;\n    private filterManager?: FilterManager;\n\n    public wireBeans(beans: BeanCollection) {\n        this.columnNameService = beans.columnNameService;\n        this.filterManager = beans.filterManager;\n    }\n\n    private readonly eFloatingFilter: HTMLElement = RefPlaceholder;\n\n    private params: IFloatingFilterParams<GroupFilter>;\n    private eFloatingFilterText: AgInputTextField;\n    private parentFilterInstance: GroupFilter;\n    private underlyingFloatingFilter: IFloatingFilterComp | undefined;\n    private showingUnderlyingFloatingFilter: boolean;\n    private haveAddedColumnListeners: boolean = false;\n\n    constructor() {\n        super(/* html */ `\n            <div data-ref=\"eFloatingFilter\" class=\"ag-group-floating-filter ag-floating-filter-input\" role=\"presentation\"></div>\n        `);\n    }\n\n    public init(params: IFloatingFilterParams<GroupFilter>): AgPromise<void> {\n        this.params = params;\n\n        // we only support showing the underlying floating filter for multiple group columns\n        const canShowUnderlyingFloatingFilter = this.gos.get('groupDisplayType') === 'multipleColumns';\n\n        return new AgPromise<void>((resolve) => {\n            this.params.parentFilterInstance((parentFilterInstance) => {\n                this.parentFilterInstance = parentFilterInstance;\n\n                if (canShowUnderlyingFloatingFilter) {\n                    this.setupUnderlyingFloatingFilterElement().then(() => resolve());\n                } else {\n                    this.setupReadOnlyFloatingFilterElement();\n                    resolve();\n                }\n            });\n        }).then(() => {\n            this.addManagedListeners(this.parentFilterInstance, {\n                selectedColumnChanged: this.onSelectedColumnChanged.bind(this),\n                columnRowGroupChanged: this.onColumnRowGroupChanged.bind(this),\n            });\n        });\n    }\n\n    public onParamsUpdated(params: IFloatingFilterParams<GroupFilter>): void {\n        this.refresh(params);\n    }\n\n    public refresh(params: IFloatingFilterParams<GroupFilter>): void {\n        this.params = params;\n        this.setParams();\n    }\n\n    private setParams(): void {\n        const displayName = this.columnNameService.getDisplayNameForColumn(\n            this.params.column as AgColumn,\n            'header',\n            true\n        );\n        const translate = this.localeService.getLocaleTextFunc();\n        this.eFloatingFilterText?.setInputAriaLabel(`${displayName} ${translate('ariaFilterInput', 'Filter Input')}`);\n    }\n\n    private setupReadOnlyFloatingFilterElement(): void {\n        if (!this.eFloatingFilterText) {\n            this.eFloatingFilterText = this.createManagedBean(new AgInputTextField());\n\n            this.eFloatingFilterText\n                .setDisabled(true)\n                .addGuiEventListener('click', () => this.params.showParentFilter());\n\n            this.setParams();\n        }\n\n        this.updateDisplayedValue();\n\n        this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());\n    }\n\n    private setupUnderlyingFloatingFilterElement(): AgPromise<void> {\n        this.showingUnderlyingFloatingFilter = false;\n        this.underlyingFloatingFilter = undefined;\n        _clearElement(this.eFloatingFilter);\n        const column = this.parentFilterInstance.getSelectedColumn();\n        // we can only show the underlying filter if there is one instance (e.g. the underlying column is not visible)\n        if (column && !column.isVisible()) {\n            const compDetails = this.filterManager!.getFloatingFilterCompDetails(column, this.params.showParentFilter);\n            if (compDetails) {\n                if (!this.haveAddedColumnListeners) {\n                    this.haveAddedColumnListeners = true;\n                    this.addManagedListeners(column, {\n                        visibleChanged: this.onColumnVisibleChanged.bind(this),\n                        colDefChanged: this.onColDefChanged.bind(this),\n                    });\n                }\n                return compDetails.newAgStackInstance().then((floatingFilter) => {\n                    this.underlyingFloatingFilter = floatingFilter;\n                    this.underlyingFloatingFilter?.onParentModelChanged(\n                        this.parentFilterInstance.getSelectedFilter()?.getModel()\n                    );\n                    this.appendChild(floatingFilter.getGui());\n                    this.showingUnderlyingFloatingFilter = true;\n                });\n            }\n        }\n        // fallback to the read-only version\n        this.setupReadOnlyFloatingFilterElement();\n        return AgPromise.resolve();\n    }\n\n    private onColumnVisibleChanged(): void {\n        this.setupUnderlyingFloatingFilterElement();\n    }\n\n    private onColDefChanged(event: ColumnEvent): void {\n        if (!event.column) {\n            return;\n        }\n        const compDetails = this.filterManager!.getFloatingFilterCompDetails(\n            event.column as AgColumn,\n            this.params.showParentFilter\n        );\n        if (compDetails) {\n            if (this.underlyingFloatingFilter?.refresh) {\n                this.underlyingFloatingFilter.refresh(compDetails.params);\n            } else {\n                this.underlyingFloatingFilter?.onParamsUpdated?.(compDetails.params);\n            }\n        }\n    }\n\n    public onParentModelChanged(_model: null, event: FilterChangedEvent): void {\n        if (this.showingUnderlyingFloatingFilter) {\n            this.underlyingFloatingFilter?.onParentModelChanged(\n                this.parentFilterInstance.getSelectedFilter()?.getModel(),\n                event\n            );\n        } else {\n            this.updateDisplayedValue();\n        }\n    }\n\n    private updateDisplayedValue(): void {\n        if (!this.parentFilterInstance || !this.eFloatingFilterText) {\n            return;\n        }\n        const selectedFilter = this.parentFilterInstance.getSelectedFilter();\n        if (!selectedFilter) {\n            this.eFloatingFilterText.setValue('');\n            this.eFloatingFilterText.setDisplayed(false);\n            return;\n        }\n        this.eFloatingFilterText.setDisplayed(true);\n        if (selectedFilter.getModelAsString) {\n            const filterModel = selectedFilter.getModel();\n            this.eFloatingFilterText.setValue(filterModel == null ? '' : selectedFilter.getModelAsString(filterModel));\n        } else {\n            this.eFloatingFilterText.setValue('');\n        }\n    }\n\n    private onSelectedColumnChanged(): void {\n        if (!this.showingUnderlyingFloatingFilter) {\n            this.updateDisplayedValue();\n        }\n    }\n\n    private onColumnRowGroupChanged(): void {\n        if (!this.showingUnderlyingFloatingFilter) {\n            this.updateDisplayedValue();\n        }\n    }\n\n    public override destroy(): void {\n        super.destroy();\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ChangedPath,\n    ColumnModel,\n    FuncColsService,\n    GetDataPath,\n    IRowNodeStage,\n    ISelectionService,\n    IShowRowGroupColsService,\n    InitialGroupOrderComparatorParams,\n    IsGroupOpenByDefaultParams,\n    KeyCreatorParams,\n    NamedBean,\n    RowNodeTransaction,\n    SelectableService,\n    StageExecuteParams,\n    ValueService,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport {\n    BeanStub,\n    RowNode,\n    _areEqual,\n    _exists,\n    _existsAndNotEmpty,\n    _last,\n    _removeFromArray,\n    _sortRowNodesByOrder,\n    _warnOnce,\n} from '@ag-grid-community/core';\n\nimport { BatchRemover } from './batchRemover';\n\ninterface GroupInfo {\n    key: string; // e.g. 'Ireland'\n    field: string | null; // e.g. 'country'\n    rowGroupColumn: AgColumn | null;\n    leafNode?: RowNode;\n}\n\ninterface GroupingDetails {\n    pivotMode: boolean;\n    expandByDefault: number;\n    changedPath: ChangedPath;\n    rootNode: RowNode;\n    groupedCols: AgColumn[];\n    groupedColCount: number;\n    transactions: RowNodeTransaction[];\n    rowNodeOrder: { [id: string]: number };\n\n    groupAllowUnbalanced: boolean;\n    isGroupOpenByDefault: (params: WithoutGridCommon<IsGroupOpenByDefaultParams>) => boolean;\n    initialGroupOrderComparator: (params: WithoutGridCommon<InitialGroupOrderComparatorParams>) => number;\n\n    usingTreeData: boolean;\n    suppressGroupMaintainValueType: boolean;\n    getDataPath: GetDataPath | undefined;\n    keyCreators: (((params: KeyCreatorParams) => string) | undefined)[];\n}\n\nexport class GroupStage extends BeanStub implements NamedBean, IRowNodeStage {\n    beanName = 'groupStage' as const;\n\n    private columnModel: ColumnModel;\n    private funcColsService: FuncColsService;\n    private selectableService: SelectableService;\n    private valueService: ValueService;\n    private beans: BeanCollection;\n    private selectionService: ISelectionService;\n    private showRowGroupColsService: IShowRowGroupColsService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.beans = beans;\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n        this.selectableService = beans.selectableService;\n        this.valueService = beans.valueService;\n        this.selectionService = beans.selectionService;\n        this.showRowGroupColsService = beans.showRowGroupColsService!;\n    }\n\n    // when grouping, these items are of note:\n    // rowNode.parent: RowNode: set to the parent\n    // rowNode.childrenAfterGroup: RowNode[] = the direct children of this group\n    // rowNode.childrenMapped: string=>RowNode = children mapped by group key (when groups) or an empty map if leaf group (this is then used by pivot)\n    // for leaf groups, rowNode.childrenAfterGroup = rowNode.allLeafChildren;\n\n    private oldGroupingDetails: GroupingDetails;\n    private oldGroupDisplayColIds: string;\n    /** Hierarchical node cache to speed up tree data node insertion */\n    private treeNodeCache = new TreeDataNodeCache();\n\n    public execute(params: StageExecuteParams): void {\n        const details = this.createGroupingDetails(params);\n\n        if (details.transactions) {\n            this.handleTransaction(details);\n        } else {\n            const afterColsChanged = params.afterColumnsChanged === true;\n            this.shotgunResetEverything(details, afterColsChanged);\n        }\n\n        if (!details.usingTreeData) {\n            // we don't do group sorting for tree data\n            this.positionLeafsAndGroups(params.changedPath!);\n            this.orderGroups(details);\n        }\n\n        this.selectableService.updateSelectableAfterGrouping();\n    }\n\n    private positionLeafsAndGroups(changedPath: ChangedPath) {\n        changedPath.forEachChangedNodeDepthFirst((group) => {\n            if (group.childrenAfterGroup) {\n                const leafNodes: RowNode[] = [];\n                const groupNodes: RowNode[] = [];\n                let unbalancedNode: RowNode | undefined;\n\n                group.childrenAfterGroup.forEach((row) => {\n                    if (!row.childrenAfterGroup?.length) {\n                        leafNodes.push(row);\n                    } else {\n                        if (row.key === '' && !unbalancedNode) {\n                            unbalancedNode = row;\n                        } else {\n                            groupNodes.push(row);\n                        }\n                    }\n                });\n\n                if (unbalancedNode) {\n                    groupNodes.push(unbalancedNode);\n                }\n\n                group.childrenAfterGroup = [...leafNodes, ...groupNodes];\n            }\n        }, false);\n    }\n\n    private createGroupingDetails(params: StageExecuteParams): GroupingDetails {\n        const { rowNode, changedPath, rowNodeTransactions, rowNodeOrder } = params;\n\n        const usingTreeData = this.gos.get('treeData');\n\n        const groupedCols = usingTreeData ? null : this.funcColsService.getRowGroupColumns();\n\n        const details: GroupingDetails = {\n            expandByDefault: this.gos.get('groupDefaultExpanded'),\n            groupedCols: groupedCols!,\n            rootNode: rowNode,\n            pivotMode: this.columnModel.isPivotMode(),\n            groupedColCount: usingTreeData || !groupedCols ? 0 : groupedCols.length,\n            rowNodeOrder: rowNodeOrder!,\n            transactions: rowNodeTransactions!,\n            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway\n            changedPath: changedPath!,\n            groupAllowUnbalanced: this.gos.get('groupAllowUnbalanced'),\n            isGroupOpenByDefault: this.gos.getCallback('isGroupOpenByDefault') as any,\n            initialGroupOrderComparator: this.gos.getCallback('initialGroupOrderComparator') as any,\n            usingTreeData: usingTreeData,\n            suppressGroupMaintainValueType: this.gos.get('suppressGroupMaintainValueType'),\n            getDataPath: usingTreeData ? this.gos.get('getDataPath') : undefined,\n            keyCreators: groupedCols?.map((column) => column.getColDef().keyCreator) ?? [],\n        };\n\n        return details;\n    }\n\n    private handleTransaction(details: GroupingDetails): void {\n        details.transactions.forEach((tran) => {\n            // we don't allow batch remover for tree data as tree data uses Filler Nodes,\n            // and creating/deleting filler nodes needs to be done alongside the node deleting\n            // and moving. if we want to Batch Remover working with tree data then would need\n            // to consider how Filler Nodes would be impacted (it's possible that it can be easily\n            // modified to work, however for now I don't have the brain energy to work it all out).\n            const batchRemover = !details.usingTreeData ? new BatchRemover() : undefined;\n\n            // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,\n            // as the order is important when a record with the same id is added and removed in the same\n            // transaction.\n            if (_existsAndNotEmpty(tran.remove)) {\n                this.removeNodes(tran.remove as RowNode[], details, batchRemover);\n            }\n            if (_existsAndNotEmpty(tran.update)) {\n                this.moveNodesInWrongPath(tran.update as RowNode[], details, batchRemover);\n            }\n            if (_existsAndNotEmpty(tran.add)) {\n                this.insertNodes(tran.add as RowNode[], details, false);\n            }\n            // must flush here, and not allow another transaction to be applied,\n            // as each transaction must finish leaving the data in a consistent state.\n            if (batchRemover) {\n                const parentsWithChildrenRemoved = batchRemover.getAllParents().slice();\n                batchRemover.flush();\n                this.removeEmptyGroups(parentsWithChildrenRemoved, details);\n            }\n        });\n\n        if (details.rowNodeOrder) {\n            this.sortChildren(details);\n        }\n    }\n\n    // this is used when doing delta updates, eg Redux, keeps nodes in right order\n    private sortChildren(details: GroupingDetails): void {\n        details.changedPath.forEachChangedNodeDepthFirst(\n            (node) => {\n                const didSort = _sortRowNodesByOrder(node.childrenAfterGroup, details.rowNodeOrder);\n                if (didSort) {\n                    details.changedPath.addParentNode(node);\n                }\n            },\n            false,\n            true\n        );\n    }\n\n    private orderGroups(details: GroupingDetails): void {\n        const comparator = details.initialGroupOrderComparator;\n        if (_exists(comparator)) {\n            recursiveSort(details.rootNode);\n        }\n\n        function recursiveSort(rowNode: RowNode): void {\n            const doSort =\n                _exists(rowNode.childrenAfterGroup) &&\n                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)\n                !rowNode.leafGroup;\n\n            if (doSort) {\n                rowNode.childrenAfterGroup!.sort((nodeA, nodeB) => comparator!({ nodeA, nodeB }));\n                rowNode.childrenAfterGroup!.forEach((childNode: RowNode) => recursiveSort(childNode));\n            }\n        }\n    }\n\n    private getExistingPathForNode(node: RowNode, details: GroupingDetails): GroupInfo[] {\n        const res: GroupInfo[] = [];\n\n        // when doing tree data, the node is part of the path,\n        // but when doing grid grouping, the node is not part of the path so we start with the parent.\n        let pointer = details.usingTreeData ? node : node.parent;\n        while (pointer && pointer !== details.rootNode) {\n            res.push({\n                key: pointer.key!,\n                rowGroupColumn: pointer.rowGroupColumn,\n                field: pointer.field,\n            });\n            pointer = pointer.parent;\n        }\n        res.reverse();\n        return res;\n    }\n\n    /**\n     * Topological sort of the given row nodes based on the grouping hierarchy, where parents come before children.\n     * Used to ensure tree data is moved in the correct order (see AG-11678)\n     */\n    private topoSort(rowNodes: RowNode[], details: GroupingDetails): RowNode[] {\n        const sortedNodes: RowNode[] = [];\n        // performance: create a cache of ids to make lookups during the search faster\n        const idLookup = Object.fromEntries(rowNodes.map<[string, number]>((node, i) => [node.id!, i]));\n        // performance: keep track of the nodes we haven't found yet so we can return early\n        const stillToFind = new Set(Object.keys(idLookup));\n\n        const queue = [details.rootNode];\n        let i = 0;\n\n        // BFS for nodes in the hierarchy that match IDs of the given nodes\n        while (i < queue.length) {\n            // performance: indexing into the array instead of using e.g. `.shift` is _much_ faster\n            const node = queue[i];\n            i++;\n            if (node === undefined) {\n                continue;\n            }\n\n            if (node.id && node.id in idLookup) {\n                sortedNodes.push(rowNodes[idLookup[node.id]]);\n                stillToFind.delete(node.id);\n            }\n\n            // we can stop early if we've already found all the nodes\n            if (stillToFind.size === 0) {\n                return sortedNodes;\n            }\n\n            const children = node.childrenAfterGroup ?? [];\n            for (let i = 0; i < children.length; i++) {\n                queue.push(children[i]);\n            }\n        }\n\n        return sortedNodes;\n    }\n\n    private moveNodesInWrongPath(\n        childNodes: RowNode[],\n        details: GroupingDetails,\n        batchRemover: BatchRemover | undefined\n    ): void {\n        // AG-11678 avoid unnecessary sorting when using normal row grouping\n        const sorted = details.usingTreeData ? this.topoSort(childNodes, details) : childNodes;\n\n        sorted.forEach((childNode) => {\n            // we add node, even if parent has not changed, as the data could have\n            // changed, hence aggregations will be wrong\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(childNode.parent);\n            }\n\n            const infoToKeyMapper = (item: GroupInfo) => item.key;\n            const oldPath: string[] = this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);\n            const newPath: string[] = this.getGroupInfo(childNode, details).map(infoToKeyMapper);\n\n            const nodeInCorrectPath = _areEqual(oldPath, newPath);\n\n            if (!nodeInCorrectPath) {\n                this.moveNode(childNode, details, batchRemover);\n            }\n        });\n    }\n\n    private moveNode(childNode: RowNode, details: GroupingDetails, batchRemover: BatchRemover | undefined): void {\n        this.removeNodesInStages([childNode], details, batchRemover);\n        this.insertOneNode(childNode, details, true, batchRemover);\n\n        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get\n        // refreshed into the gui.\n        // this is needed to kick off the event that rowComp listens to for refresh. this in turn\n        // then will get each cell in the row to refresh - which is what we need as we don't know which\n        // columns will be displaying the rowNode.key info.\n        childNode.setData(childNode.data);\n\n        // we add both old and new parents to changed path, as both will need to be refreshed.\n        // we already added the old parent (in calling method), so just add the new parent here\n        if (details.changedPath.isActive()) {\n            const newParent = childNode.parent;\n            details.changedPath.addParentNode(newParent);\n        }\n    }\n\n    private removeNodes(\n        leafRowNodes: RowNode[],\n        details: GroupingDetails,\n        batchRemover: BatchRemover | undefined\n    ): void {\n        this.removeNodesInStages(leafRowNodes, details, batchRemover);\n        if (details.changedPath.isActive()) {\n            leafRowNodes.forEach((rowNode) => details.changedPath.addParentNode(rowNode.parent));\n        }\n    }\n\n    private removeNodesInStages(\n        leafRowNodes: RowNode[],\n        details: GroupingDetails,\n        batchRemover: BatchRemover | undefined\n    ): void {\n        this.removeNodesFromParents(leafRowNodes, details, batchRemover);\n        if (details.usingTreeData) {\n            // When not TreeData, then removeEmptyGroups is called just before the BatchRemover is flushed.\n            // However for TreeData, there is no BatchRemover, so we have to call removeEmptyGroups here.\n            const nodeParents = leafRowNodes.map((n) => n.parent!);\n            this.removeEmptyGroups(nodeParents, details);\n        }\n    }\n\n    private forEachParentGroup(details: GroupingDetails, group: RowNode, callback: (parent: RowNode) => void): void {\n        let pointer: RowNode | null = group;\n        while (pointer && pointer !== details.rootNode) {\n            callback(pointer);\n            pointer = pointer.parent;\n        }\n    }\n\n    private removeNodesFromParents(\n        nodesToRemove: RowNode[],\n        details: GroupingDetails,\n        provided: BatchRemover | undefined\n    ): void {\n        // this method can be called with BatchRemover as optional. if it is missed, we created a local version\n        // and flush it at the end. if one is provided, we add to the provided one and it gets flushed elsewhere.\n        const batchRemoverIsLocal = provided == null;\n        const batchRemoverToUse = provided ? provided : new BatchRemover();\n\n        nodesToRemove.forEach((nodeToRemove) => {\n            this.removeFromParent(nodeToRemove, batchRemoverToUse);\n\n            // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as\n            // the ClientSideNodeManager is responsible for the Root Node.\n            this.forEachParentGroup(details, nodeToRemove.parent!, (parentNode) => {\n                batchRemoverToUse.removeFromAllLeafChildren(parentNode, nodeToRemove);\n            });\n        });\n\n        if (batchRemoverIsLocal) {\n            batchRemoverToUse.flush();\n        }\n    }\n\n    private removeEmptyGroups(possibleEmptyGroups: RowNode[], details: GroupingDetails): void {\n        // we do this multiple times, as when we remove groups, that means the parent of just removed\n        // group can then be empty. to get around this, if we remove, then we check everything again for\n        // newly emptied groups. the max number of times this will execute is the depth of the group tree.\n        let checkAgain = true;\n\n        const groupShouldBeRemoved = (rowNode: RowNode): boolean => {\n            // because of the while loop below, it's possible we already moved the node,\n            // so double check before trying to remove again.\n            const mapKey = this.getChildrenMappedKey(rowNode.key!, rowNode.rowGroupColumn);\n            const parentRowNode = rowNode.parent;\n            const groupAlreadyRemoved = parentRowNode?.childrenMapped ? !parentRowNode.childrenMapped[mapKey] : true;\n\n            if (groupAlreadyRemoved) {\n                // if not linked, then group was already removed\n                return false;\n            }\n            // if still not removed, then we remove if this group is empty\n            return rowNode.isEmptyRowGroupNode();\n        };\n\n        while (checkAgain) {\n            checkAgain = false;\n            const batchRemover = new BatchRemover();\n            possibleEmptyGroups.forEach((possibleEmptyGroup) => {\n                // remove empty groups\n                this.forEachParentGroup(details, possibleEmptyGroup, (rowNode) => {\n                    const shouldBeRemoved = groupShouldBeRemoved(rowNode);\n                    if (shouldBeRemoved && details.usingTreeData && details.getDataPath?.(rowNode.data)) {\n                        // This node has associated tree data so shouldn't be removed, but should no longer be\n                        // marked as a group if it has no children.\n                        rowNode.setGroup(\n                            (rowNode.childrenAfterGroup && rowNode.childrenAfterGroup.length > 0) ?? false\n                        );\n                    } else if (shouldBeRemoved) {\n                        checkAgain = true;\n\n                        this.removeFromParent(rowNode, batchRemover);\n                        // we remove selection on filler nodes here, as the selection would not be removed\n                        // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager\n                        rowNode.setSelectedParams({ newValue: false, source: 'rowGroupChanged' });\n                    }\n                });\n            });\n            batchRemover.flush();\n        }\n    }\n\n    // removes the node from the parent by:\n    // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)\n    // b) removing from childrenMapped (immediately)\n    // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed\n    // d) setRowIndex(null) - as the rowNode will no longer be displayed.\n    private removeFromParent(child: RowNode, batchRemover?: BatchRemover) {\n        if (child.parent) {\n            if (batchRemover) {\n                batchRemover.removeFromChildrenAfterGroup(child.parent, child);\n            } else {\n                _removeFromArray(child.parent.childrenAfterGroup!, child);\n                child.parent.updateHasChildren();\n            }\n        }\n        const mapKey = this.getChildrenMappedKey(child.key!, child.rowGroupColumn);\n        if (child.parent?.childrenMapped != undefined) {\n            delete child.parent.childrenMapped[mapKey];\n        }\n        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and\n        // remove, if rowTop is still present, the rowComp thinks it's just moved position.\n        child.setRowTop(null);\n        child.setRowIndex(null);\n    }\n\n    /**\n     * This is idempotent, but relies on the `key` field being the same throughout a RowNode's lifetime\n     */\n    private addToParent(child: RowNode, parent: RowNode | null) {\n        const mapKey = this.getChildrenMappedKey(child.key!, child.rowGroupColumn);\n        if (parent?.childrenMapped != null) {\n            if (parent?.childrenMapped?.[mapKey] !== child) {\n                parent.childrenMapped[mapKey] = child;\n                parent.childrenAfterGroup!.push(child);\n                parent.setGroup(true); // calls `.updateHasChildren` internally\n            }\n        }\n    }\n\n    private areGroupColsEqual(d1: GroupingDetails, d2: GroupingDetails): boolean {\n        if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {\n            return false;\n        }\n\n        return _areEqual(d1.groupedCols, d2.groupedCols) && _areEqual(d1.keyCreators, d2.keyCreators);\n    }\n\n    private checkAllGroupDataAfterColsChanged(details: GroupingDetails): void {\n        const recurse = (rowNodes: RowNode[] | null) => {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach((rowNode) => {\n                const isLeafNode = !details.usingTreeData && !rowNode.group;\n                if (isLeafNode) {\n                    return;\n                }\n                const groupInfo: GroupInfo = {\n                    field: rowNode.field,\n                    key: rowNode.key!,\n                    rowGroupColumn: rowNode.rowGroupColumn,\n                    leafNode: rowNode.allLeafChildren?.[0],\n                };\n                this.setGroupData(rowNode, groupInfo, details);\n                recurse(rowNode.childrenAfterGroup);\n            });\n        };\n\n        recurse(details.rootNode.childrenAfterGroup);\n    }\n\n    private shotgunResetEverything(details: GroupingDetails, afterColumnsChanged: boolean): void {\n        if (this.noChangeInGroupingColumns(details, afterColumnsChanged)) {\n            return;\n        }\n\n        // groups are about to get disposed, so need to deselect any that are selected\n        this.selectionService.filterFromSelection((node: RowNode) => node && !node.group);\n\n        const { rootNode, groupedCols } = details;\n        // because we are not creating the root node each time, we have the logic\n        // here to change leafGroup once.\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        rootNode.leafGroup = details.usingTreeData ? false : groupedCols.length === 0;\n\n        // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode\n        rootNode.childrenAfterGroup = [];\n        rootNode.childrenMapped = {};\n        rootNode.updateHasChildren();\n\n        const sibling = rootNode.sibling;\n        if (sibling) {\n            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n            sibling.childrenMapped = rootNode.childrenMapped;\n        }\n\n        this.insertNodes(rootNode.allLeafChildren!, details, false);\n    }\n\n    private noChangeInGroupingColumns(details: GroupingDetails, afterColumnsChanged: boolean): boolean {\n        let noFurtherProcessingNeeded = false;\n\n        const groupDisplayColumns = this.showRowGroupColsService.getShowRowGroupCols();\n        const newGroupDisplayColIds = groupDisplayColumns ? groupDisplayColumns.map((c) => c.getId()).join('-') : '';\n\n        if (afterColumnsChanged) {\n            // we only need to redo grouping if doing normal grouping (ie not tree data)\n            // and the group cols have changed.\n            noFurtherProcessingNeeded =\n                details.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails);\n\n            // if the group display cols have changed, then we need to update rowNode.groupData\n            // (regardless of tree data or row grouping)\n            if (this.oldGroupDisplayColIds !== newGroupDisplayColIds) {\n                this.checkAllGroupDataAfterColsChanged(details);\n            }\n        }\n\n        this.oldGroupingDetails = details;\n        this.oldGroupDisplayColIds = newGroupDisplayColIds;\n\n        return noFurtherProcessingNeeded;\n    }\n\n    private insertNodes(newRowNodes: RowNode[], details: GroupingDetails, isMove: boolean): void {\n        if (details.usingTreeData) {\n            this.buildNodeCacheFromRows(newRowNodes, details);\n        } else {\n            this.treeNodeCache.clear();\n        }\n\n        newRowNodes.forEach((rowNode) => {\n            this.insertOneNode(rowNode, details, isMove);\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(rowNode.parent);\n            }\n        });\n    }\n\n    private insertOneNode(\n        childNode: RowNode,\n        details: GroupingDetails,\n        isMove: boolean,\n        batchRemover?: BatchRemover\n    ): void {\n        const path: GroupInfo[] = this.getGroupInfo(childNode, details);\n        const level = details.usingTreeData ? path.length - 1 : undefined;\n\n        const parentGroup = this.findParentForNode(childNode, path, details, batchRemover, level);\n\n        if (details.usingTreeData) {\n            const info = _last(path);\n            childNode.parent = parentGroup;\n            childNode.level = path.length;\n            this.ensureRowNodeFields(childNode, this.getChildrenMappedKey(info.key, info.rowGroupColumn));\n            this.setGroupData(childNode, info, details);\n            // AG-3441 - only set initial value if node is not being moved\n            if (!isMove) {\n                this.setExpandedInitialValue(details, childNode);\n            }\n            this.addToParent(childNode, parentGroup);\n        } else {\n            if (!parentGroup.group) {\n                _warnOnce(`duplicate group keys for row data, keys should be unique`, [\n                    parentGroup.data,\n                    childNode.data,\n                ]);\n            }\n            childNode.parent = parentGroup;\n            childNode.level = path.length;\n            parentGroup.childrenAfterGroup!.push(childNode);\n            parentGroup.updateHasChildren();\n        }\n    }\n\n    private findParentForNode(\n        childNode: RowNode,\n        path: GroupInfo[],\n        details: GroupingDetails,\n        batchRemover?: BatchRemover,\n        stopLevel?: number\n    ): RowNode {\n        let nextNode: RowNode = details.rootNode;\n\n        path.forEach((groupInfo, level) => {\n            // in some cases (i.e. tree data) the given path includes the child node, so we need to exclude it\n            if (stopLevel !== undefined && level >= stopLevel) {\n                return;\n            }\n\n            nextNode = this.getOrCreateNextNode(nextNode, path, groupInfo, level, details);\n            // node gets added to all group nodes.\n            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes\n\n            if (!batchRemover?.isRemoveFromAllLeafChildren(nextNode, childNode)) {\n                nextNode.allLeafChildren!.push(childNode);\n            } else {\n                // if this node is about to be removed, prevent that\n                batchRemover?.preventRemoveFromAllLeafChildren(nextNode, childNode);\n            }\n        });\n\n        return nextNode;\n    }\n\n    private getOrCreateNextNode(\n        parentGroup: RowNode,\n        path: GroupInfo[],\n        groupInfo: GroupInfo,\n        level: number,\n        details: GroupingDetails\n    ): RowNode {\n        const key = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);\n        let nextNode = parentGroup?.childrenMapped?.[key];\n\n        if (!nextNode) {\n            if (details.usingTreeData && this.treeNodeCache.has(path, level, key)) {\n                nextNode = this.treeNodeCache.get(path, level, key);\n                nextNode.parent = parentGroup;\n            } else {\n                nextNode = this.createGroup(groupInfo, parentGroup, level, details);\n            }\n            // attach the new group to the parent\n            this.addToParent(nextNode, parentGroup);\n        }\n\n        return nextNode;\n    }\n\n    /**\n     * Directly re-initialises the `TreeDataNodeCache`\n     */\n    private buildNodeCacheFromRows(rowNodes: RowNode[], details: GroupingDetails): void {\n        let width = 0;\n        const paths = rowNodes.map((node) => {\n            const info = this.getGroupInfo(node, details);\n            width = Math.max(width, info.length);\n            return info;\n        });\n\n        this.treeNodeCache.clear();\n\n        // Iterate through the paths level-by-level, populating the cache with RowNode\n        // instances for all leaves of the hierarchy, and nulls otherwise (to be backfilled\n        // with filler nodes in the subsequent step)\n        for (let level = 0; level < width; level++) {\n            for (const [rowIdx, path] of paths.entries()) {\n                const isDefined = path[level] !== undefined;\n                const isLeaf = path[level + 1] === undefined;\n\n                if (!isDefined) {\n                    continue;\n                }\n\n                const info = path[level];\n\n                const currentValue = this.treeNodeCache.get(path, level, info.key);\n                if (currentValue != null) {\n                    continue;\n                }\n\n                this.treeNodeCache.set(\n                    path,\n                    level,\n                    info.key,\n                    isLeaf ? this.ensureRowNodeFields(rowNodes[rowIdx], info.key) : null\n                );\n            }\n        }\n\n        this.backfillGroups(this.treeNodeCache.inner(), details.rootNode, 0, details);\n    }\n\n    private ensureRowNodeFields(rowNode: RowNode, key?: string): RowNode {\n        if (key !== undefined) {\n            rowNode.key = key;\n        }\n        rowNode.childrenMapped ??= {};\n        rowNode.allLeafChildren ??= [];\n        rowNode.childrenAfterGroup ??= [];\n        return rowNode;\n    }\n\n    /** Walks the TreeDataNodeCache recursively and backfills `null` entries with filler group nodes */\n    private backfillGroups(\n        cache: InnerTreeDataNodeCache,\n        parent: RowNode,\n        level: number,\n        details: GroupingDetails\n    ): void {\n        for (const [key, value] of Object.entries(cache)) {\n            if (value.node === null) {\n                value.node = this.createGroup({ key, rowGroupColumn: null, field: null }, parent, level, details);\n            }\n            this.backfillGroups(value.subtree, value.node, level + 1, details);\n        }\n    }\n\n    private createGroup(groupInfo: GroupInfo, parent: RowNode, level: number, details: GroupingDetails): RowNode {\n        const groupNode = new RowNode(this.beans);\n\n        groupNode.group = true;\n        groupNode.field = groupInfo.field;\n        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;\n\n        this.setGroupData(groupNode, groupInfo, details);\n\n        groupNode.key = groupInfo.key;\n        groupNode.id = this.createGroupId(groupNode, parent, details.usingTreeData, level);\n\n        groupNode.level = level;\n        groupNode.leafGroup = details.usingTreeData ? false : level === details.groupedColCount - 1;\n\n        groupNode.allLeafChildren = [];\n\n        // why is this done here? we are not updating the children count as we go,\n        // i suspect this is updated in the filter stage\n        groupNode.setAllChildrenCount(0);\n\n        groupNode.rowGroupIndex = details.usingTreeData ? null : level;\n\n        groupNode.childrenAfterGroup = [];\n        groupNode.childrenMapped = {};\n        groupNode.updateHasChildren();\n\n        groupNode.parent = parent;\n\n        this.setExpandedInitialValue(details, groupNode);\n\n        return groupNode;\n    }\n\n    private createGroupId(node: RowNode, parent: RowNode, usingTreeData: boolean, level: number): string {\n        let createGroupId: (node: RowNode, parent: RowNode | null, level: number) => string | null;\n        if (usingTreeData) {\n            createGroupId = (node, parent, level) => {\n                if (level < 0) {\n                    return null;\n                } // root node\n                const parentId = parent ? createGroupId(parent, parent.parent, level - 1) : null;\n                return `${parentId == null ? '' : parentId + '-'}${level}-${node.key}`;\n            };\n        } else {\n            createGroupId = (node, parent) => {\n                if (!node.rowGroupColumn) {\n                    return null;\n                } // root node\n                const parentId = parent ? createGroupId(parent, parent.parent, 0) : null;\n                return `${parentId == null ? '' : parentId + '-'}${node.rowGroupColumn.getColId()}-${node.key}`;\n            };\n        }\n\n        // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'\n        // for top pinned and bottom pinned rows.\n        return RowNode.ID_PREFIX_ROW_GROUP + createGroupId(node, parent, level);\n    }\n\n    private setGroupData(groupNode: RowNode, groupInfo: GroupInfo, details: GroupingDetails): void {\n        groupNode.groupData = {};\n        const groupDisplayCols = this.showRowGroupColsService.getShowRowGroupCols();\n        groupDisplayCols.forEach((col) => {\n            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column\n            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so\n            const isTreeData = details.usingTreeData;\n            if (isTreeData) {\n                groupNode.groupData![col.getColId()] = groupInfo.key;\n                return;\n            }\n\n            const groupColumn = groupNode.rowGroupColumn;\n            const isRowGroupDisplayed = groupColumn !== null && col.isRowGroupDisplayed(groupColumn.getId());\n            if (isRowGroupDisplayed) {\n                if (details.suppressGroupMaintainValueType) {\n                    groupNode.groupData![col.getColId()] = groupInfo.key;\n                } else {\n                    // if maintain group value type, get the value from any leaf node.\n                    groupNode.groupData![col.getColId()] = this.valueService.getValue(groupColumn, groupInfo.leafNode);\n                }\n            }\n        });\n    }\n\n    private getChildrenMappedKey(key: string, rowGroupColumn: AgColumn | null): string {\n        if (rowGroupColumn) {\n            // grouping by columns\n            return rowGroupColumn.getId() + '-' + key;\n        }\n        // tree data - we don't have rowGroupColumns\n        return key;\n    }\n\n    private setExpandedInitialValue(details: GroupingDetails, groupNode: RowNode): void {\n        // if pivoting the leaf group is never expanded as we do not show leaf rows\n        if (details.pivotMode && groupNode.leafGroup) {\n            groupNode.expanded = false;\n            return;\n        }\n\n        // use callback if exists\n        const userCallback = details.isGroupOpenByDefault;\n        if (userCallback) {\n            const params: WithoutGridCommon<IsGroupOpenByDefaultParams> = {\n                rowNode: groupNode,\n                field: groupNode.field!,\n                key: groupNode.key!,\n                level: groupNode.level,\n                rowGroupColumn: groupNode.rowGroupColumn!,\n            };\n            groupNode.expanded = userCallback(params) == true;\n            return;\n        }\n\n        // use expandByDefault if exists\n        if (details.expandByDefault === -1) {\n            groupNode.expanded = true;\n            return;\n        }\n\n        // otherwise\n        groupNode.expanded = groupNode.level < details.expandByDefault;\n    }\n\n    private getGroupInfo(rowNode: RowNode, details: GroupingDetails): GroupInfo[] {\n        if (details.usingTreeData) {\n            return this.getGroupInfoFromCallback(rowNode, details);\n        }\n        return this.getGroupInfoFromGroupColumns(rowNode, details);\n    }\n\n    private getGroupInfoFromCallback(rowNode: RowNode, details: GroupingDetails): GroupInfo[] {\n        const keys = details.getDataPath?.(rowNode.data);\n\n        if (keys === undefined || keys.length === 0) {\n            _warnOnce(`getDataPath() should not return an empty path for data ${rowNode.data}`);\n        }\n        return keys?.map((key) => ({ key, field: null, rowGroupColumn: null })) ?? [];\n    }\n\n    private getGroupInfoFromGroupColumns(rowNode: RowNode, details: GroupingDetails) {\n        const res: GroupInfo[] = [];\n        details.groupedCols.forEach((groupCol) => {\n            let key: string = this.valueService.getKeyForNode(groupCol, rowNode);\n            let keyExists = key !== null && key !== undefined && key !== '';\n\n            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make\n            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.\n            // this keeps the tree balanced and hence can be represented as a group.\n            const createGroupForEmpty = details.pivotMode || !details.groupAllowUnbalanced;\n            if (createGroupForEmpty && !keyExists) {\n                key = '';\n                keyExists = true;\n            }\n\n            if (keyExists) {\n                const item = {\n                    key: key,\n                    field: groupCol.getColDef().field,\n                    rowGroupColumn: groupCol,\n                    leafNode: rowNode,\n                } as GroupInfo;\n                res.push(item);\n            }\n        });\n        return res;\n    }\n}\n\n/** Hierarchical cache of RowNode or sentinel value indicating a filler group node is necessary */\ntype InnerTreeDataNodeCache = Record<string, { node: null | RowNode; subtree: InnerTreeDataNodeCache }>;\n\nclass TreeDataNodeCache {\n    private cache: InnerTreeDataNodeCache = {};\n\n    private traverse(path: GroupInfo[], level: number): InnerTreeDataNodeCache {\n        let cache = this.cache;\n        let i = 0;\n\n        while (i <= level) {\n            const key = path[i].key;\n\n            if (!(key in cache)) {\n                cache[key] = { node: null, subtree: {} };\n            }\n            cache = cache[key].subtree;\n\n            i++;\n        }\n\n        return cache;\n    }\n\n    public set(path: GroupInfo[], level: number, key: string, value: null | RowNode) {\n        const cache = this.traverse(path, level - 1);\n        cache[key] = { node: value, subtree: {} };\n    }\n\n    public has(path: GroupInfo[], level: number, key: string): boolean {\n        const cache = this.traverse(path, level - 1);\n        return key in cache;\n    }\n\n    public get(path: GroupInfo[], level: number, key: string): RowNode | null | undefined {\n        const cache = this.traverse(path, level - 1);\n        return cache[key]?.node;\n    }\n\n    public clear(): void {\n        this.cache = {};\n    }\n\n    public inner(): InnerTreeDataNodeCache {\n        return this.cache;\n    }\n}\n", "import type { RowNode } from '@ag-grid-community/core';\n\n// doing _removeFromArray() multiple times on a large list can be a bottleneck.\n// when doing large deletes (eg removing 1,000 rows) then we would be calling _removeFromArray()\n// a thousands of times, in particular RootNode.allGroupChildren could be a large list, and\n// 1,000 removes is time consuming as each one requires traversing the full list.\n// to get around this, we do all the removes in a batch. this class manages the batch.\n//\n// This problem was brought to light by a client (AG-2879), with dataset of 20,000\n// in 10,000 groups (2 items per group), then deleting all rows with transaction,\n// it took about 20 seconds to delete. with the BathRemoved, the reduced to less than 1 second.\n\ninterface RemoveDetails {\n    removeFromChildrenAfterGroup: { [id: string]: boolean };\n    removeFromAllLeafChildren: { [id: string]: boolean };\n}\n\nexport class BatchRemover {\n    private allSets: { [parentId: string]: RemoveDetails } = {};\n    private allParents: RowNode[] = [];\n\n    public removeFromChildrenAfterGroup(parent: RowNode, child: RowNode): void {\n        const set = this.getSet(parent);\n        set.removeFromChildrenAfterGroup[child.id!] = true;\n    }\n\n    public isRemoveFromAllLeafChildren(parent: RowNode, child: RowNode): boolean {\n        const set = this.getSet(parent);\n        return !!set.removeFromAllLeafChildren[child.id!];\n    }\n\n    public preventRemoveFromAllLeafChildren(parent: RowNode, child: RowNode): void {\n        const set = this.getSet(parent);\n        delete set.removeFromAllLeafChildren[child.id!];\n    }\n\n    public removeFromAllLeafChildren(parent: RowNode, child: RowNode): void {\n        const set = this.getSet(parent);\n        set.removeFromAllLeafChildren[child.id!] = true;\n    }\n\n    private getSet(parent: RowNode): RemoveDetails {\n        if (!this.allSets[parent.id!]) {\n            this.allSets[parent.id!] = {\n                removeFromAllLeafChildren: {},\n                removeFromChildrenAfterGroup: {},\n            };\n            this.allParents.push(parent);\n        }\n        return this.allSets[parent.id!];\n    }\n\n    public getAllParents(): RowNode[] {\n        return this.allParents;\n    }\n\n    public flush(): void {\n        this.allParents.forEach((parent) => {\n            const nodeDetails = this.allSets[parent.id!];\n\n            parent.childrenAfterGroup = parent.childrenAfterGroup!.filter(\n                (child) => !nodeDetails.removeFromChildrenAfterGroup[child.id!]\n            );\n            parent.allLeafChildren =\n                parent.allLeafChildren?.filter((child) => !nodeDetails.removeFromAllLeafChildren[child.id!]) ?? null;\n            parent.updateHasChildren();\n\n            if (parent.sibling) {\n                parent.sibling.childrenAfterGroup = parent.childrenAfterGroup;\n                parent.sibling.allLeafChildren = parent.allLeafChildren;\n            }\n        });\n        this.allSets = {};\n        this.allParents.length = 0;\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ColDef,\n    ColGroupDef,\n    ColumnModel,\n    ColumnNameService,\n    FuncColsService,\n    IPivotColDefService,\n    NamedBean,\n} from '@ag-grid-community/core';\nimport { BeanStub, _cloneObject, _iterateObject } from '@ag-grid-community/core';\n\nexport interface PivotColDefServiceResult {\n    pivotColumnGroupDefs: (ColDef | ColGroupDef)[];\n    pivotColumnDefs: ColDef[];\n}\n\nconst PIVOT_ROW_TOTAL_PREFIX = 'PivotRowTotal_';\nexport class PivotColDefService extends BeanStub implements NamedBean, IPivotColDefService {\n    beanName = 'pivotColDefService' as const;\n\n    private columnModel: ColumnModel;\n    private funcColsService: FuncColsService;\n    private columnNameService: ColumnNameService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n        this.columnNameService = beans.columnNameService;\n    }\n\n    private fieldSeparator: string;\n    private pivotDefaultExpanded: number;\n\n    public postConstruct(): void {\n        const getFieldSeparator = () => this.gos.get('serverSidePivotResultFieldSeparator') ?? '_';\n        this.fieldSeparator = getFieldSeparator();\n        this.addManagedPropertyListener('serverSidePivotResultFieldSeparator', () => {\n            this.fieldSeparator = getFieldSeparator();\n        });\n\n        const getPivotDefaultExpanded = () => this.gos.get('pivotDefaultExpanded');\n        this.pivotDefaultExpanded = getPivotDefaultExpanded();\n        this.addManagedPropertyListener('pivotDefaultExpanded', () => {\n            this.pivotDefaultExpanded = getPivotDefaultExpanded();\n        });\n    }\n\n    public createPivotColumnDefs(uniqueValues: any): PivotColDefServiceResult {\n        // this is passed to the columnModel, to configure the columns and groups we show\n\n        const pivotColumnGroupDefs: (ColDef | ColGroupDef)[] = this.createPivotColumnsFromUniqueValues(uniqueValues);\n\n        function extractColDefs(input: (ColDef | ColGroupDef)[], arr: ColDef[] = []): ColDef[] {\n            input.forEach((def: any) => {\n                if (def.children !== undefined) {\n                    extractColDefs(def.children, arr);\n                } else {\n                    arr.push(def);\n                }\n            });\n            return arr;\n        }\n        const pivotColumnDefs = extractColDefs(pivotColumnGroupDefs);\n\n        // additional columns that contain the aggregated total for each value column per row\n        this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs);\n\n        // additional group columns that contain child totals for each collapsed child column / group\n        this.addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs);\n\n        // additional group columns that contain an aggregated total across all child columns\n        this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs);\n\n        // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that\n        // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,\n        // as these use the col defs also\n        const pivotColumnDefsClone: ColDef[] = pivotColumnDefs.map((colDef) => _cloneObject(colDef));\n\n        return {\n            pivotColumnGroupDefs: pivotColumnGroupDefs,\n            pivotColumnDefs: pivotColumnDefsClone,\n        };\n    }\n\n    private createPivotColumnsFromUniqueValues(uniqueValues: any): (ColDef | ColGroupDef)[] {\n        const pivotColumns = this.funcColsService.getPivotColumns();\n        const maxDepth = pivotColumns.length;\n\n        const pivotColumnGroupDefs: (ColDef | ColGroupDef)[] = this.recursivelyBuildGroup(\n            0,\n            uniqueValues,\n            [],\n            maxDepth,\n            pivotColumns\n        );\n        return pivotColumnGroupDefs;\n    }\n\n    private recursivelyBuildGroup(\n        index: number,\n        uniqueValue: any,\n        pivotKeys: string[],\n        maxDepth: number,\n        primaryPivotColumns: AgColumn[]\n    ): ColGroupDef[] | ColDef[] {\n        const measureColumns = this.funcColsService.getValueColumns();\n        if (index >= maxDepth) {\n            // Base case - build the measure columns\n            return this.buildMeasureCols(pivotKeys);\n        }\n\n        // sort by either user provided comparator, or our own one\n        const primaryPivotColumnDefs = primaryPivotColumns[index].getColDef();\n        const comparator = this.headerNameComparator.bind(this, primaryPivotColumnDefs.pivotComparator);\n\n        // Base case for the compact layout, instead of recursing build the last layer of groups as measure columns instead\n        if (\n            measureColumns.length === 1 &&\n            this.gos.get('removePivotHeaderRowWhenSingleValueColumn') &&\n            index === maxDepth - 1\n        ) {\n            const leafCols: ColDef[] = [];\n\n            _iterateObject(uniqueValue, (key) => {\n                const newPivotKeys = [...pivotKeys, key];\n                const colDef = this.createColDef(measureColumns[0], key, newPivotKeys);\n                colDef.columnGroupShow = 'open';\n                leafCols.push(colDef);\n            });\n            leafCols.sort(comparator);\n            return leafCols;\n        }\n        // Recursive case\n        const groups: ColGroupDef[] = [];\n        _iterateObject(uniqueValue, (key, value) => {\n            // expand group by default based on depth of group. (pivotDefaultExpanded provides desired level of depth for expanding group by default)\n            const openByDefault = this.pivotDefaultExpanded === -1 || index < this.pivotDefaultExpanded;\n\n            const newPivotKeys = [...pivotKeys, key];\n            groups.push({\n                children: this.recursivelyBuildGroup(index + 1, value, newPivotKeys, maxDepth, primaryPivotColumns),\n                headerName: key,\n                pivotKeys: newPivotKeys,\n                columnGroupShow: 'open',\n                openByDefault: openByDefault,\n                groupId: this.generateColumnGroupId(newPivotKeys),\n            });\n        });\n        groups.sort(comparator);\n        return groups;\n    }\n\n    private buildMeasureCols(pivotKeys: string[]): ColDef[] {\n        const measureColumns = this.funcColsService.getValueColumns();\n        if (measureColumns.length === 0) {\n            // if no value columns selected, then we insert one blank column, so the user at least sees columns\n            // rendered. otherwise the grid would render with no columns (just empty groups) which would give the\n            // impression that the grid is broken\n            return [this.createColDef(null, '-', pivotKeys)];\n        }\n        return measureColumns.map((measureCol) => {\n            const columnName = this.columnNameService.getDisplayNameForColumn(measureCol, 'header');\n            return {\n                ...this.createColDef(measureCol, columnName, pivotKeys),\n                columnGroupShow: 'open',\n            };\n        });\n    }\n\n    private addExpandablePivotGroups(pivotColumnGroupDefs: (ColDef | ColGroupDef)[], pivotColumnDefs: ColDef[]) {\n        if (this.gos.get('suppressExpandablePivotGroups') || this.gos.get('pivotColumnGroupTotals')) {\n            return;\n        }\n\n        const recursivelyAddSubTotals = (\n            groupDef: ColGroupDef | ColDef,\n            currentPivotColumnDefs: ColDef[],\n            acc: Map<string, string[]>\n        ) => {\n            const group = groupDef as ColGroupDef;\n\n            if (group.children) {\n                const childAcc = new Map();\n\n                group.children.forEach((grp: ColDef | ColGroupDef) => {\n                    recursivelyAddSubTotals(grp, currentPivotColumnDefs, childAcc);\n                });\n\n                const firstGroup = !group.children.some((child) => (child as ColGroupDef).children);\n\n                this.funcColsService.getValueColumns().forEach((valueColumn) => {\n                    const columnName: string | null = this.columnNameService.getDisplayNameForColumn(\n                        valueColumn,\n                        'header'\n                    );\n                    const totalColDef = this.createColDef(valueColumn, columnName, groupDef.pivotKeys);\n                    totalColDef.pivotTotalColumnIds = childAcc.get(valueColumn.getColId());\n\n                    totalColDef.columnGroupShow = 'closed';\n\n                    totalColDef.aggFunc = valueColumn.getAggFunc();\n\n                    if (!firstGroup) {\n                        // add total colDef to group and pivot colDefs array\n                        const children = (groupDef as ColGroupDef).children;\n                        children.push(totalColDef);\n                        currentPivotColumnDefs.push(totalColDef);\n                    }\n                });\n\n                this.merge(acc, childAcc);\n            } else {\n                const def: ColDef = groupDef as ColDef;\n\n                // check that value column exists, i.e. aggFunc is supplied\n                if (!def.pivotValueColumn) {\n                    return;\n                }\n\n                const pivotValueColId = def.pivotValueColumn.getColId();\n\n                const arr = acc.has(pivotValueColId) ? acc.get(pivotValueColId) : [];\n                arr!.push(def.colId!);\n                acc.set(pivotValueColId, arr!);\n            }\n        };\n\n        pivotColumnGroupDefs.forEach((groupDef: ColGroupDef | ColDef) => {\n            recursivelyAddSubTotals(groupDef, pivotColumnDefs, new Map());\n        });\n    }\n\n    private addPivotTotalsToGroups(pivotColumnGroupDefs: (ColDef | ColGroupDef)[], pivotColumnDefs: ColDef[]) {\n        if (!this.gos.get('pivotColumnGroupTotals')) {\n            return;\n        }\n\n        const insertAfter = this.gos.get('pivotColumnGroupTotals') === 'after';\n\n        const valueCols = this.funcColsService.getValueColumns();\n        const aggFuncs = valueCols.map((valueCol) => valueCol.getAggFunc());\n\n        // don't add pivot totals if there is less than 1 aggFunc or they are not all the same\n        if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {\n            // console.warn('AG Grid: aborting adding pivot total columns - value columns require same aggFunc');\n            return;\n        }\n\n        // arbitrarily select a value column to use as a template for pivot columns\n        const valueColumn = valueCols[0];\n\n        pivotColumnGroupDefs.forEach((groupDef: ColGroupDef | ColDef) => {\n            this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter);\n        });\n    }\n\n    private recursivelyAddPivotTotal(\n        groupDef: ColGroupDef | ColDef,\n        pivotColumnDefs: ColDef[],\n        valueColumn: AgColumn,\n        insertAfter: boolean\n    ): string[] | null {\n        const group = groupDef as ColGroupDef;\n        if (!group.children) {\n            const def: ColDef = groupDef as ColDef;\n            return def.colId ? [def.colId] : null;\n        }\n\n        let colIds: string[] = [];\n\n        // need to recurse children first to obtain colIds used in the aggregation stage\n        group.children.forEach((grp: ColDef | ColGroupDef) => {\n            const childColIds = this.recursivelyAddPivotTotal(grp, pivotColumnDefs, valueColumn, insertAfter);\n            if (childColIds) {\n                colIds = colIds.concat(childColIds);\n            }\n        });\n\n        // only add total colDef if there is more than 1 child node\n        if (group.children.length > 1) {\n            const localeTextFunc = this.localeService.getLocaleTextFunc();\n            const headerName = localeTextFunc('pivotColumnGroupTotals', 'Total');\n\n            //create total colDef using an arbitrary value column as a template\n            const totalColDef = this.createColDef(valueColumn, headerName, groupDef.pivotKeys, true);\n            totalColDef.pivotTotalColumnIds = colIds;\n            totalColDef.aggFunc = valueColumn.getAggFunc();\n\n            // add total colDef to group and pivot colDefs array\n            const children = (groupDef as ColGroupDef).children;\n            insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);\n            pivotColumnDefs.push(totalColDef);\n        }\n\n        return colIds;\n    }\n\n    private addRowGroupTotals(pivotColumnGroupDefs: (ColDef | ColGroupDef)[], pivotColumnDefs: ColDef[]) {\n        if (!this.gos.get('pivotRowTotals')) {\n            return;\n        }\n\n        const insertAfter = this.gos.get('pivotRowTotals') === 'after';\n\n        const valueColumns = this.funcColsService.getValueColumns();\n        // order of row group totals depends on position\n        const valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();\n\n        for (let i = 0; i < valueCols.length; i++) {\n            const valueCol = valueCols[i];\n\n            let colIds: any[] = [];\n            pivotColumnGroupDefs.forEach((groupDef: ColGroupDef | ColDef) => {\n                colIds = colIds.concat(this.extractColIdsForValueColumn(groupDef, valueCol));\n            });\n\n            const withGroup = valueCols.length > 1 || !this.gos.get('removePivotHeaderRowWhenSingleValueColumn');\n            this.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, valueCol, colIds, insertAfter, withGroup);\n        }\n    }\n\n    private extractColIdsForValueColumn(groupDef: ColGroupDef | ColDef, valueColumn: AgColumn): string[] {\n        const group = groupDef as ColGroupDef;\n        if (!group.children) {\n            const colDef = group as ColDef;\n            return colDef.pivotValueColumn === valueColumn && colDef.colId ? [colDef.colId] : [];\n        }\n\n        let colIds: string[] = [];\n        group.children.forEach((grp: ColDef | ColGroupDef) => {\n            this.extractColIdsForValueColumn(grp, valueColumn);\n            const childColIds = this.extractColIdsForValueColumn(grp, valueColumn);\n            colIds = colIds.concat(childColIds);\n        });\n\n        return colIds;\n    }\n\n    private createRowGroupTotal(\n        parentChildren: (ColGroupDef | ColDef)[],\n        pivotColumnDefs: ColDef[],\n        valueColumn: AgColumn,\n        colIds: string[],\n        insertAfter: boolean,\n        addGroup: boolean\n    ): void {\n        const measureColumns = this.funcColsService.getValueColumns();\n\n        let colDef: ColDef;\n\n        if (measureColumns.length === 0) {\n            colDef = this.createColDef(null, '-', []);\n        } else {\n            const columnName: string | null = this.columnNameService.getDisplayNameForColumn(valueColumn, 'header');\n            colDef = this.createColDef(valueColumn, columnName, []);\n            colDef.pivotTotalColumnIds = colIds;\n        }\n\n        colDef.colId = PIVOT_ROW_TOTAL_PREFIX + colDef.colId;\n        pivotColumnDefs.push(colDef);\n\n        const valueGroup: ColGroupDef | ColDef = addGroup\n            ? {\n                  children: [colDef],\n                  pivotKeys: [],\n                  groupId: `${PIVOT_ROW_TOTAL_PREFIX}_pivotGroup_${valueColumn.getColId()}`,\n              }\n            : colDef;\n\n        insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);\n    }\n\n    private createColDef(\n        valueColumn: AgColumn | null,\n        headerName: any,\n        pivotKeys: string[] | undefined,\n        totalColumn: boolean = false\n    ): ColDef {\n        const colDef: ColDef = {};\n\n        // This is null when there are no measure columns and we're creating placeholder columns\n        if (valueColumn) {\n            const colDefToCopy = valueColumn.getColDef();\n            Object.assign(colDef, colDefToCopy);\n            // even if original column was hidden, we always show the pivot value column, otherwise it would be\n            // very confusing for people thinking the pivot is broken\n            colDef.hide = false;\n        }\n\n        colDef.headerName = headerName;\n        colDef.colId = this.generateColumnId(\n            pivotKeys || [],\n            valueColumn && !totalColumn ? valueColumn.getColId() : ''\n        );\n\n        // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to\n        // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.\n        colDef.field = colDef.colId;\n        // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId\n        // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects\n        colDef.valueGetter = (params) => params.data?.[params.colDef.field!];\n\n        colDef.pivotKeys = pivotKeys;\n        colDef.pivotValueColumn = valueColumn;\n        if (colDef.filter === true) {\n            colDef.filter = 'agNumberColumnFilter';\n        }\n\n        return colDef;\n    }\n\n    private sameAggFuncs(aggFuncs: any[]) {\n        if (aggFuncs.length == 1) {\n            return true;\n        }\n        //check if all aggFunc's match\n        for (let i = 1; i < aggFuncs.length; i++) {\n            if (aggFuncs[i] !== aggFuncs[0]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private headerNameComparator(\n        userComparator: (a: string | undefined, b: string | undefined) => number,\n        a: ColGroupDef | ColDef,\n        b: ColGroupDef | ColDef\n    ): number {\n        if (userComparator) {\n            return userComparator(a.headerName, b.headerName);\n        } else {\n            if (a.headerName && !b.headerName) {\n                return 1;\n            } else if (!a.headerName && b.headerName) {\n                return -1;\n            }\n\n            // slightly naff here - just to satify typescript\n            // really should be &&, but if so ts complains\n            // the above if/else checks would deal with either being falsy, so at this stage if either are falsy, both are\n            // ..still naff though\n            if (!a.headerName || !b.headerName) {\n                return 0;\n            }\n\n            if (a.headerName < b.headerName) {\n                return -1;\n            }\n\n            if (a.headerName > b.headerName) {\n                return 1;\n            }\n\n            return 0;\n        }\n    }\n\n    private merge(m1: Map<string, string[]>, m2: Map<any, any>) {\n        m2.forEach((value, key) => {\n            const existingList = m1.has(key) ? m1.get(key) : [];\n            const updatedList = [...existingList!, ...value];\n            m1.set(key, updatedList);\n        });\n    }\n\n    private generateColumnGroupId(pivotKeys: string[]): string {\n        const pivotCols = this.funcColsService.getPivotColumns().map((col) => col.getColId());\n        return `pivotGroup_${pivotCols.join('-')}_${pivotKeys.join('-')}`;\n    }\n\n    private generateColumnId(pivotKeys: string[], measureColumnId: string) {\n        const pivotCols = this.funcColsService.getPivotColumns().map((col) => col.getColId());\n        return `pivot_${pivotCols.join('-')}_${pivotKeys.join('-')}_${measureColumnId}`;\n    }\n\n    /**\n     * Used by the SSRM to create secondary columns from provided fields\n     * @param fields\n     */\n    public createColDefsFromFields(fields: string[]): (ColDef | ColGroupDef)[] {\n        interface UniqueValue {\n            [key: string]: UniqueValue;\n        }\n        // tear the ids down into groups, while this could be done in-step with the next stage, the lookup is faster\n        // than searching col group children array for the right group\n        const uniqueValues: UniqueValue = {};\n        for (let i = 0; i < fields.length; i++) {\n            const field = fields[i];\n            const parts = field.split(this.fieldSeparator);\n\n            let level: UniqueValue = uniqueValues;\n            for (let p = 0; p < parts.length; p++) {\n                const part = parts[p];\n                if (level[part] == null) {\n                    level[part] = {};\n                }\n                level = level[part];\n            }\n        }\n\n        const uniqueValuesToGroups = (\n            id: string,\n            key: string,\n            uniqueValues: UniqueValue,\n            depth: number\n        ): ColDef | ColGroupDef => {\n            const children: (ColDef | ColGroupDef)[] = [];\n            for (const key in uniqueValues) {\n                const item = uniqueValues[key];\n                const child = uniqueValuesToGroups(`${id}${this.fieldSeparator}${key}`, key, item, depth + 1);\n                children.push(child);\n            }\n\n            if (children.length === 0) {\n                const potentialAggCol = this.columnModel.getColDefCol(key);\n                if (potentialAggCol) {\n                    const headerName = this.columnNameService.getDisplayNameForColumn(potentialAggCol, 'header') ?? key;\n                    const colDef = this.createColDef(potentialAggCol, headerName, undefined, false);\n                    colDef.colId = id;\n                    colDef.aggFunc = potentialAggCol.getAggFunc();\n                    colDef.valueGetter = (params) => params.data?.[id];\n                    return colDef;\n                }\n\n                const col: ColDef = {\n                    colId: id,\n                    headerName: key,\n                    // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId\n                    // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects\n                    valueGetter: (params) => params.data?.[id],\n                };\n                return col;\n            }\n\n            // this is a bit sketchy. As the fields can be anything we just build groups as deep as the fields go.\n            // nothing says user has to give us groups the same depth.\n            const collapseSingleChildren = this.gos.get('removePivotHeaderRowWhenSingleValueColumn');\n            if (collapseSingleChildren && children.length === 1 && 'colId' in children[0]) {\n                children[0].headerName = key;\n                return children[0];\n            }\n\n            const group: ColGroupDef = {\n                openByDefault: this.pivotDefaultExpanded === -1 || depth < this.pivotDefaultExpanded,\n                groupId: id,\n                headerName: key,\n                children,\n            };\n            return group;\n        };\n\n        const res: (ColDef | ColGroupDef)[] = [];\n        for (const key in uniqueValues) {\n            const item = uniqueValues[key];\n            const col = uniqueValuesToGroups(key, key, item, 0);\n            res.push(col);\n        }\n        return res;\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    ChangedPath,\n    ColDef,\n    ColumnModel,\n    FuncColsService,\n    GridOptions,\n    IRowNodeStage,\n    NamedBean,\n    PivotMaxColumnsExceededEvent,\n    PivotResultColsService,\n    RowNode,\n    StageExecuteParams,\n    ValueService,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, _iterateObject, _missing } from '@ag-grid-community/core';\n\nimport type { PivotColDefService } from './pivotColDefService';\n\nconst EXCEEDED_MAX_UNIQUE_VALUES = 'Exceeded maximum allowed pivot column count.';\n\nexport class PivotStage extends BeanStub implements NamedBean, IRowNodeStage {\n    beanName = 'pivotStage' as const;\n\n    private valueService: ValueService;\n    private columnModel: ColumnModel;\n    private pivotResultColsService: PivotResultColsService;\n    private funcColsService: FuncColsService;\n    private pivotColDefService: PivotColDefService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.valueService = beans.valueService;\n        this.columnModel = beans.columnModel;\n        this.pivotResultColsService = beans.pivotResultColsService;\n        this.funcColsService = beans.funcColsService;\n        this.pivotColDefService = beans.pivotColDefService as PivotColDefService;\n    }\n\n    private uniqueValues: any = {};\n\n    private pivotColumnDefs: ColDef[];\n\n    private aggregationColumnsHashLastTime: string | null;\n    private aggregationFuncsHashLastTime: string;\n\n    private groupColumnsHashLastTime: string | null;\n\n    private pivotRowTotalsLastTime: GridOptions['pivotRowTotals'];\n    private pivotColumnGroupTotalsLastTime: GridOptions['pivotColumnGroupTotals'];\n    private suppressExpandablePivotGroupsLastTime: GridOptions['suppressExpandablePivotGroups'];\n    private removePivotHeaderRowWhenSingleValueColumnLastTime: GridOptions['removePivotHeaderRowWhenSingleValueColumn'];\n\n    private lastTimeFailed = false;\n\n    private maxUniqueValues: number = -1;\n\n    public execute(params: StageExecuteParams): void {\n        const changedPath = params.changedPath;\n        if (this.columnModel.isPivotActive()) {\n            this.executePivotOn(changedPath!);\n        } else {\n            this.executePivotOff(changedPath!);\n        }\n    }\n\n    private executePivotOff(changedPath: ChangedPath): void {\n        this.aggregationColumnsHashLastTime = null;\n        this.uniqueValues = {};\n        if (this.pivotResultColsService.isPivotResultColsPresent()) {\n            this.pivotResultColsService.setPivotResultCols(null, 'rowModelUpdated');\n            if (changedPath) {\n                changedPath.setInactive();\n            }\n        }\n    }\n\n    private executePivotOn(changedPath: ChangedPath): void {\n        const numberOfAggregationColumns = this.funcColsService.getValueColumns().length ?? 1;\n\n        // As unique values creates one column per aggregation column, divide max columns by number of aggregation columns\n        // to get the max number of unique values.\n        const configuredMaxCols = this.gos.get('pivotMaxGeneratedColumns');\n        this.maxUniqueValues = configuredMaxCols === -1 ? -1 : configuredMaxCols / numberOfAggregationColumns;\n        let uniqueValues;\n        try {\n            // try catch is used to force execution to stop when the max count is exceeded.\n            uniqueValues = this.bucketUpRowNodes(changedPath);\n        } catch (e) {\n            // message is checked rather than inheritance as the build seems to break instanceof\n            if (e.message === EXCEEDED_MAX_UNIQUE_VALUES) {\n                this.pivotResultColsService.setPivotResultCols([], 'rowModelUpdated');\n                const event: WithoutGridCommon<PivotMaxColumnsExceededEvent> = {\n                    type: 'pivotMaxColumnsExceeded',\n                    message: e.message,\n                };\n                this.eventService.dispatchEvent(event);\n                this.lastTimeFailed = true;\n                return;\n            }\n            throw e;\n        }\n\n        const uniqueValuesChanged = this.setUniqueValues(uniqueValues);\n\n        const aggregationColumns = this.funcColsService.getValueColumns();\n        const aggregationColumnsHash = aggregationColumns\n            .map((column) => `${column.getId()}-${column.getColDef().headerName}`)\n            .join('#');\n        const aggregationFuncsHash = aggregationColumns.map((column) => column.getAggFunc()!.toString()).join('#');\n\n        const aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;\n        const aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;\n        this.aggregationColumnsHashLastTime = aggregationColumnsHash;\n        this.aggregationFuncsHashLastTime = aggregationFuncsHash;\n\n        const groupColumnsHash = this.funcColsService\n            .getRowGroupColumns()\n            .map((column) => column.getId())\n            .join('#');\n        const groupColumnsChanged = groupColumnsHash !== this.groupColumnsHashLastTime;\n        this.groupColumnsHashLastTime = groupColumnsHash;\n\n        const pivotRowTotals = this.gos.get('pivotRowTotals');\n        const pivotColumnGroupTotals = this.gos.get('pivotColumnGroupTotals');\n        const suppressExpandablePivotGroups = this.gos.get('suppressExpandablePivotGroups');\n        const removePivotHeaderRowWhenSingleValueColumn = this.gos.get('removePivotHeaderRowWhenSingleValueColumn');\n\n        const anyGridOptionsChanged =\n            pivotRowTotals !== this.pivotRowTotalsLastTime ||\n            pivotColumnGroupTotals !== this.pivotColumnGroupTotalsLastTime ||\n            suppressExpandablePivotGroups !== this.suppressExpandablePivotGroupsLastTime ||\n            removePivotHeaderRowWhenSingleValueColumn !== this.removePivotHeaderRowWhenSingleValueColumnLastTime;\n\n        this.pivotRowTotalsLastTime = pivotRowTotals;\n        this.pivotColumnGroupTotalsLastTime = pivotColumnGroupTotals;\n        this.suppressExpandablePivotGroupsLastTime = suppressExpandablePivotGroups;\n        this.removePivotHeaderRowWhenSingleValueColumnLastTime = removePivotHeaderRowWhenSingleValueColumn;\n\n        if (\n            this.lastTimeFailed ||\n            uniqueValuesChanged ||\n            aggregationColumnsChanged ||\n            groupColumnsChanged ||\n            aggregationFuncsChanged ||\n            anyGridOptionsChanged\n        ) {\n            const { pivotColumnGroupDefs, pivotColumnDefs } = this.pivotColDefService.createPivotColumnDefs(\n                this.uniqueValues\n            );\n            this.pivotColumnDefs = pivotColumnDefs;\n            this.pivotResultColsService.setPivotResultCols(pivotColumnGroupDefs, 'rowModelUpdated');\n            // because the secondary columns have changed, then the aggregation needs to visit the whole\n            // tree again, so we make the changedPath not active, to force aggregation to visit all paths.\n            if (changedPath) {\n                changedPath.setInactive();\n            }\n        }\n        this.lastTimeFailed = false;\n    }\n\n    private setUniqueValues(newValues: any): boolean {\n        const json1 = JSON.stringify(newValues);\n        const json2 = JSON.stringify(this.uniqueValues);\n\n        const uniqueValuesChanged = json1 !== json2;\n\n        // we only continue the below if the unique values are different, as otherwise\n        // the result will be the same as the last time we did it\n        if (uniqueValuesChanged) {\n            this.uniqueValues = newValues;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private currentUniqueCount = 0;\n    private bucketUpRowNodes(changedPath: ChangedPath): any {\n        this.currentUniqueCount = 0;\n        // accessed from inside inner function\n        const uniqueValues: any = {};\n\n        // ensure childrenMapped is cleared, as if a node has been filtered out it should not have mapped children.\n        changedPath.forEachChangedNodeDepthFirst((node) => {\n            if (node.leafGroup) {\n                node.childrenMapped = null;\n            }\n        });\n\n        const recursivelyBucketFilteredChildren = (node: RowNode) => {\n            if (node.leafGroup) {\n                this.bucketRowNode(node, uniqueValues);\n            } else {\n                node.childrenAfterFilter?.forEach(recursivelyBucketFilteredChildren);\n            }\n        };\n\n        changedPath.executeFromRootNode(recursivelyBucketFilteredChildren);\n\n        return uniqueValues;\n    }\n\n    private bucketRowNode(rowNode: RowNode, uniqueValues: any): void {\n        const pivotColumns = this.funcColsService.getPivotColumns();\n\n        if (pivotColumns.length === 0) {\n            rowNode.childrenMapped = null;\n        } else {\n            rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter!, pivotColumns, 0, uniqueValues);\n        }\n\n        if (rowNode.sibling) {\n            rowNode.sibling.childrenMapped = rowNode.childrenMapped;\n        }\n    }\n\n    private bucketChildren(\n        children: RowNode[],\n        pivotColumns: AgColumn[],\n        pivotIndex: number,\n        uniqueValues: any\n    ): Record<string, any> {\n        const mappedChildren: Record<string, any> = {};\n        const pivotColumn = pivotColumns[pivotIndex];\n\n        // map the children out based on the pivot column\n        children.forEach((child: RowNode) => {\n            let key: string = this.valueService.getKeyForNode(pivotColumn, child);\n\n            if (_missing(key)) {\n                key = '';\n            }\n\n            if (!uniqueValues[key]) {\n                this.currentUniqueCount += 1;\n                uniqueValues[key] = {};\n\n                const doesGeneratedColMaxExist = this.maxUniqueValues !== -1;\n                const hasExceededColMax = this.currentUniqueCount > this.maxUniqueValues;\n                if (doesGeneratedColMaxExist && hasExceededColMax) {\n                    // throw an error to prevent all additional execution and escape the loops.\n                    throw Error(EXCEEDED_MAX_UNIQUE_VALUES);\n                }\n            }\n\n            if (!mappedChildren[key]) {\n                mappedChildren[key] = [];\n            }\n            mappedChildren[key].push(child);\n        });\n\n        // if it's the last pivot column, return as is, otherwise go one level further in the map\n        if (pivotIndex === pivotColumns.length - 1) {\n            return mappedChildren;\n        } else {\n            const result: Record<string, any> = {};\n\n            _iterateObject(mappedChildren, (key: string, value: RowNode[]) => {\n                result[key] = this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);\n            });\n\n            return result;\n        }\n    }\n\n    public getPivotColumnDefs(): ColDef[] {\n        return this.pivotColumnDefs;\n    }\n}\n", "import type { BeanCollection, ColDef, ColGroupDef, Column, IAggFunc } from '@ag-grid-community/core';\n\n/** @deprecated v31.1 */\nexport function addAggFunc(beans: BeanCollection, key: string, aggFunc: IAggFunc): void {\n    if (beans.aggFuncService) {\n        beans.aggFuncService.addAggFuncs({ key: aggFunc });\n    }\n}\n\nexport function addAggFuncs(beans: BeanCollection, aggFuncs: { [key: string]: IAggFunc }): void {\n    if (beans.aggFuncService) {\n        beans.aggFuncService.addAggFuncs(aggFuncs);\n    }\n}\n\nexport function clearAggFuncs(beans: BeanCollection): void {\n    if (beans.aggFuncService) {\n        beans.aggFuncService.clear();\n    }\n}\n\nexport function setColumnAggFunc(\n    beans: BeanCollection,\n    key: string | ColDef | Column,\n    aggFunc: string | IAggFunc | null | undefined\n): void {\n    beans.funcColsService.setColumnAggFunc(key, aggFunc, 'api');\n}\n\nexport function isPivotMode(beans: BeanCollection): boolean {\n    return beans.columnModel.isPivotMode();\n}\n\nexport function getPivotResultColumn<TValue = any, TData = any>(\n    beans: BeanCollection,\n    pivotKeys: string[],\n    valueColKey: string | ColDef<TData, TValue> | Column<TValue>\n): Column<TValue> | null {\n    return beans.pivotResultColsService.lookupPivotResultCol(pivotKeys, valueColKey);\n}\n\nexport function setValueColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.setValueColumns(colKeys, 'api');\n}\n\nexport function getValueColumns(beans: BeanCollection): Column[] {\n    return beans.funcColsService.getValueColumns();\n}\n\n/** @deprecated v31.1 */\nexport function removeValueColumn(beans: BeanCollection, colKey: string | ColDef | Column): void {\n    beans.funcColsService.removeValueColumns([colKey], 'api');\n}\n\nexport function removeValueColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.removeValueColumns(colKeys, 'api');\n}\n\n/** @deprecated v31.1 */\nexport function addValueColumn(beans: BeanCollection, colKey: string | ColDef | Column): void {\n    beans.funcColsService.addValueColumns([colKey], 'api');\n}\n\nexport function addValueColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.addValueColumns(colKeys, 'api');\n}\n\nexport function setRowGroupColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.setRowGroupColumns(colKeys, 'api');\n}\n\n/** @deprecated v31.1 */\nexport function removeRowGroupColumn(beans: BeanCollection, colKey: string | ColDef | Column): void {\n    beans.funcColsService.removeRowGroupColumns([colKey], 'api');\n}\n\nexport function removeRowGroupColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.removeRowGroupColumns(colKeys, 'api');\n}\n\n/** @deprecated v31.1 */\nexport function addRowGroupColumn(beans: BeanCollection, colKey: string | ColDef | Column): void {\n    beans.funcColsService.addRowGroupColumns([colKey], 'api');\n}\n\nexport function addRowGroupColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.addRowGroupColumns(colKeys, 'api');\n}\n\nexport function moveRowGroupColumn(beans: BeanCollection, fromIndex: number, toIndex: number): void {\n    beans.funcColsService.moveRowGroupColumn(fromIndex, toIndex, 'api');\n}\n\nexport function getRowGroupColumns(beans: BeanCollection): Column[] {\n    return beans.funcColsService.getRowGroupColumns();\n}\n\nexport function setPivotColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.setPivotColumns(colKeys, 'api');\n}\n\n/** @deprecated v31.1 */\nexport function removePivotColumn(beans: BeanCollection, colKey: string | ColDef | Column): void {\n    beans.funcColsService.removePivotColumns([colKey], 'api');\n}\n\nexport function removePivotColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.removePivotColumns(colKeys, 'api');\n}\n\n/** @deprecated v31.1 */\nexport function addPivotColumn(beans: BeanCollection, colKey: string | ColDef | Column): void {\n    beans.funcColsService.addPivotColumns([colKey], 'api');\n}\n\nexport function addPivotColumns(beans: BeanCollection, colKeys: (string | ColDef | Column)[]): void {\n    beans.funcColsService.addPivotColumns(colKeys, 'api');\n}\n\nexport function getPivotColumns(beans: BeanCollection): Column[] {\n    return beans.funcColsService.getPivotColumns();\n}\n\nexport function setPivotResultColumns(beans: BeanCollection, colDefs: (ColDef | ColGroupDef)[] | null): void {\n    beans.pivotResultColsService.setPivotResultCols(colDefs, 'api');\n}\n\nexport function getPivotResultColumns(beans: BeanCollection): Column[] | null {\n    const pivotResultCols = beans.pivotResultColsService.getPivotResultCols();\n    return pivotResultCols ? pivotResultCols.list : null;\n}\n", "import { BeanStub } from '@ag-grid-community/core';\nimport type {\n    AgColumn,\n    BeanCollection,\n    ColumnModel,\n    FuncColsService,\n    IShowRowGroupColsService,\n    NamedBean,\n} from '@ag-grid-community/core';\n\nexport class ShowRowGroupColsService extends BeanStub implements NamedBean, IShowRowGroupColsService {\n    beanName = 'showRowGroupColsService' as const;\n\n    private columnModel: ColumnModel;\n    private funcColsService: FuncColsService;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n    }\n\n    private showRowGroupCols: AgColumn[];\n    private showRowGroupColsMap: { [originalColumnId: string]: AgColumn };\n\n    public refresh(): void {\n        this.showRowGroupCols = [];\n        this.showRowGroupColsMap = {};\n\n        this.columnModel.getCols().forEach((col) => {\n            const colDef = col.getColDef();\n            const showRowGroup = colDef.showRowGroup;\n\n            const isString = typeof showRowGroup === 'string';\n            const isTrue = showRowGroup === true;\n\n            if (!isString && !isTrue) {\n                return;\n            }\n\n            this.showRowGroupCols.push(col);\n\n            if (isString) {\n                this.showRowGroupColsMap[showRowGroup] = col;\n            } else {\n                const rowGroupCols = this.funcColsService.getRowGroupColumns();\n                rowGroupCols.forEach((rowGroupCol) => {\n                    this.showRowGroupColsMap[rowGroupCol.getId()] = col;\n                });\n            }\n        });\n    }\n\n    public getShowRowGroupCols(): AgColumn[] {\n        return this.showRowGroupCols;\n    }\n\n    public getShowRowGroupCol(id: string): AgColumn | undefined {\n        return this.showRowGroupColsMap[id];\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.3.1';\n", "import type {\n    AgColumn,\n    DragAndDropIcon,\n    DraggingEvent,\n    ITooltipParams,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { _createIconNoSpan } from '@ag-grid-community/core';\n\nimport { BaseDropZonePanel } from './baseDropZonePanel';\n\nexport class ValuesDropZonePanel extends BaseDropZonePanel {\n    constructor(horizontal: boolean) {\n        super(horizontal, 'aggregation');\n    }\n\n    public postConstruct(): void {\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const emptyMessage = localeTextFunc('valueColumnsEmptyMessage', 'Drag here to aggregate');\n        const title = localeTextFunc('values', 'Values');\n\n        super.init({\n            icon: _createIconNoSpan('valuePanel', this.gos, null)!,\n            emptyMessage: emptyMessage,\n            title: title,\n        });\n\n        this.addManagedEventListeners({ columnValueChanged: this.refreshGui.bind(this) });\n    }\n\n    protected getAriaLabel(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n        const label = translate('ariaValuesDropZonePanelLabel', 'Values');\n\n        return label;\n    }\n\n    public override getTooltipParams(): WithoutGridCommon<ITooltipParams> {\n        const res = super.getTooltipParams();\n        res.location = 'valueColumnsList';\n        return res;\n    }\n\n    protected getIconName(): DragAndDropIcon {\n        return this.isPotentialDndItems() ? 'aggregate' : 'notAllowed';\n    }\n\n    protected isItemDroppable(column: AgColumn, draggingEvent: DraggingEvent): boolean {\n        // we never allow grouping of secondary columns\n        if (this.gos.get('functionsReadOnly') || !column.isPrimary()) {\n            return false;\n        }\n\n        return column.isAllowValue() && (!column.isValueActive() || this.isSourceEventFromTarget(draggingEvent));\n    }\n\n    protected updateItems(columns: AgColumn[]): void {\n        this.funcColsService.setValueColumns(columns, 'toolPanelUi');\n    }\n\n    protected getExistingItems(): AgColumn[] {\n        return this.funcColsService.getValueColumns();\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "isPivotMode", "params", "import_core", "import_core", "import_core", "i", "node", "parent", "level", "import_core", "uniqueValues", "key", "import_core", "import_core", "import_core"]
}
