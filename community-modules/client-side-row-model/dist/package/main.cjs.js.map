{
  "version": 3,
  "sources": ["../../src/main.ts", "../../src/clientSideRowModelModule.ts", "../../src/clientSideRowModel/clientSideRowModel.ts", "../../src/clientSideRowModel/clientSideNodeManager.ts", "../../src/clientSideRowModel/clientSideRowModelApi.ts", "../../src/clientSideRowModel/filterStage.ts", "../../src/clientSideRowModel/flattenStage.ts", "../../src/clientSideRowModel/immutableService.ts", "../../src/clientSideRowModel/sortService.ts", "../../src/clientSideRowModel/sortStage.ts", "../../src/version.ts"],
  "sourcesContent": ["export { ClientSideRowModelModule } from './clientSideRowModelModule';\n", "import type { Module } from '@ag-grid-community/core';\nimport { ModuleNames, RowModelHelperService, _CsrmSsrmSharedApiModule } from '@ag-grid-community/core';\n\nimport { ClientSideRowModel } from './clientSideRowModel/clientSideRowModel';\nimport {\n    applyTransaction,\n    applyTransactionAsync,\n    flushAsyncTransactions,\n    forEachLeafNode,\n    forEachNodeAfterFilter,\n    forEachNodeAfterFilterAndSort,\n    getBestCostNodeSelection,\n    onGroupExpandedOrCollapsed,\n    refreshClientSideRowModel,\n    resetRowHeights,\n} from './clientSideRowModel/clientSideRowModelApi';\nimport { FilterStage } from './clientSideRowModel/filterStage';\nimport { FlattenStage } from './clientSideRowModel/flattenStage';\nimport { ImmutableService } from './clientSideRowModel/immutableService';\nimport { SortService } from './clientSideRowModel/sortService';\nimport { SortStage } from './clientSideRowModel/sortStage';\nimport { VERSION } from './version';\n\nexport const ClientSideRowModelCoreModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.ClientSideRowModelModule}-core`,\n    rowModel: 'clientSide',\n    beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, ImmutableService],\n};\n\nexport const ClientSideRowModelApiModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.ClientSideRowModelModule}-api`,\n    beans: [RowModelHelperService],\n    apiFunctions: {\n        onGroupExpandedOrCollapsed,\n        refreshClientSideRowModel,\n        forEachLeafNode,\n        forEachNodeAfterFilter,\n        forEachNodeAfterFilterAndSort,\n        resetRowHeights,\n        applyTransaction,\n        applyTransactionAsync,\n        flushAsyncTransactions,\n        getBestCostNodeSelection,\n    },\n    dependantModules: [ClientSideRowModelCoreModule, _CsrmSsrmSharedApiModule],\n};\n\nexport const ClientSideRowModelModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.ClientSideRowModelModule,\n    dependantModules: [ClientSideRowModelCoreModule, ClientSideRowModelApiModule],\n};\n", "import type {\n    AsyncTransactionsFlushed,\n    BeanCollection,\n    ClientSideRowModelStep,\n    ColumnModel,\n    CssVariablesChanged,\n    Environment,\n    ExpandOrCollapseAllEvent,\n    FilterChangedEvent,\n    FuncColsService,\n    GridOptions,\n    IClientSideRowModel,\n    IRowNodeStage,\n    ISelectionService,\n    ModelUpdatedEvent,\n    NamedBean,\n    RefreshModelParams,\n    RowBounds,\n    RowDataTransaction,\n    RowDataUpdatedEvent,\n    RowModelType,\n    RowNodeTransaction,\n    SelectionChangedEvent,\n    ValueCache,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport {\n    BeanStub,\n    ChangedPath,\n    ClientSideRowModelSteps,\n    RowHighlightPosition,\n    RowNode,\n    _debounce,\n    _errorOnce,\n    _exists,\n    _insertIntoArray,\n    _last,\n    _missing,\n    _missingOrEmpty,\n    _removeFromArray,\n} from '@ag-grid-community/core';\n\nimport { ClientSideNodeManager } from './clientSideNodeManager';\n\nenum RecursionType {\n    Normal,\n    AfterFilter,\n    AfterFilterAndSort,\n    PivotNodes,\n}\n\nexport interface BatchTransactionItem<TData = any> {\n    rowDataTransaction: RowDataTransaction<TData>;\n    callback: ((res: RowNodeTransaction<TData>) => void) | undefined;\n}\n\nexport interface RowNodeMap {\n    [id: string]: RowNode;\n}\n\nexport class ClientSideRowModel extends BeanStub implements IClientSideRowModel, NamedBean {\n    beanName = 'rowModel' as const;\n\n    private beans: BeanCollection;\n\n    private columnModel: ColumnModel;\n    private funcColsService: FuncColsService;\n    private selectionService: ISelectionService;\n    private valueCache: ValueCache;\n    private environment: Environment;\n\n    // standard stages\n    private filterStage: IRowNodeStage;\n    private sortStage: IRowNodeStage;\n    private flattenStage: IRowNodeStage;\n\n    // enterprise stages\n    private groupStage?: IRowNodeStage;\n    private aggregationStage?: IRowNodeStage;\n    private pivotStage?: IRowNodeStage;\n    private filterAggregatesStage?: IRowNodeStage;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.beans = beans;\n\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n        this.selectionService = beans.selectionService;\n        this.valueCache = beans.valueCache;\n        this.environment = beans.environment;\n\n        this.filterStage = beans.filterStage!;\n        this.sortStage = beans.sortStage!;\n        this.flattenStage = beans.flattenStage!;\n\n        this.groupStage = beans.groupStage;\n        this.aggregationStage = beans.aggregationStage;\n        this.pivotStage = beans.pivotStage;\n        this.filterAggregatesStage = beans.filterAggregatesStage;\n    }\n\n    private onRowHeightChanged_debounced = _debounce(this.onRowHeightChanged.bind(this), 100);\n\n    // top most node of the tree. the children are the user provided data.\n    private rootNode: RowNode;\n    private rowsToDisplay: RowNode[] = []; // the rows mapped to rows to display\n    private nodeManager: ClientSideNodeManager;\n    private rowDataTransactionBatch: BatchTransactionItem[] | null;\n    private lastHighlightedRow: RowNode | null;\n    private applyAsyncTransactionsTimeout: number | undefined;\n    /** Has the start method been called */\n    private hasStarted: boolean = false;\n    /** E.g. data has been set into the node manager already */\n    private shouldSkipSettingDataOnStart: boolean = false;\n    /**\n     * This is to prevent refresh model being called when it's already being called.\n     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,\n     * which then triggers the listener here that calls refresh model again but at the filter stage\n     * (which is about to be run by the original call).\n     */\n    private isRefreshingModel: boolean = false;\n    private rowCountReady: boolean = false;\n\n    public postConstruct(): void {\n        const refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });\n        const animate = !this.gos.get('suppressAnimationFrame');\n        const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.EVERYTHING, // after cols change, row grouping (the first stage) could of changed\n            afterColumnsChanged: true,\n            keepRenderedRows: true, // we want animations cos sorting or filtering could be applied\n            animate,\n        });\n\n        this.addManagedEventListeners({\n            newColumnsLoaded: refreshEverythingAfterColsChangedFunc,\n            columnRowGroupChanged: refreshEverythingFunc,\n            columnValueChanged: this.onValueChanged.bind(this),\n            columnPivotChanged: this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }),\n            filterChanged: this.onFilterChanged.bind(this),\n            sortChanged: this.onSortChanged.bind(this),\n            columnPivotModeChanged: refreshEverythingFunc,\n            gridStylesChanged: this.onGridStylesChanges.bind(this),\n            gridReady: this.onGridReady.bind(this),\n        });\n\n        // doesn't need done if doing full reset\n        // Property listeners which call `refreshModel` at different stages\n        this.addPropertyListeners();\n\n        this.rootNode = new RowNode(this.beans);\n        this.nodeManager = new ClientSideNodeManager(\n            this.rootNode,\n            this.gos,\n            this.eventService,\n            this.funcColsService,\n            this.selectionService,\n            this.beans\n        );\n    }\n\n    private addPropertyListeners() {\n        // Omitted Properties\n        //\n        // We do not act reactively on all functional properties, as it's possible the application is React and\n        // has not memoised the property and it's getting set every render.\n        //\n        // ** LIST OF NON REACTIVE, NO ARGUMENT\n        //\n        // getDataPath, getRowId, isRowMaster -- these are called once for each Node when the Node is created.\n        //                                    -- these are immutable Node properties (ie a Node ID cannot be changed)\n        //\n        // getRowHeight - this is called once when Node is created, if a new getRowHeight function is provided,\n        //              - we do not revisit the heights of each node.\n        //\n        // pivotDefaultExpanded - relevant for initial pivot column creation, no impact on existing pivot columns.\n        //\n        // deltaSort - this changes the type of algorithm used only, it doesn't change the sort order. so no point\n        //           - in doing the sort again as the same result will be got. the new Prop will be used next time we sort.\n        //\n        // ** LIST OF NON REACTIVE, SOME ARGUMENT\n        // ** For these, they could be reactive, but not convinced the business argument is strong enough,\n        // ** so leaving as non-reactive for now, and see if anyone complains.\n        //\n        // processPivotResultColDef, processPivotResultColGroupDef\n        //                       - there is an argument for having these reactive, that if the application changes\n        //                       - these props, we should re-create the Pivot Columns, however it's highly unlikely\n        //                       - the application would change these functions, far more likely the functions were\n        //                       - non memoised correctly.\n\n        const resetProps: Set<keyof GridOptions> = new Set(['treeData', 'masterDetail']);\n        const groupStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'groupDefaultExpanded',\n            'groupAllowUnbalanced',\n            'initialGroupOrderComparator',\n            'groupHideOpenParents',\n            'groupDisplayType',\n        ]);\n        const filterStageRefreshProps: Set<keyof GridOptions> = new Set(['excludeChildrenWhenTreeDataFiltering']);\n        const pivotStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'removePivotHeaderRowWhenSingleValueColumn',\n            'pivotRowTotals',\n            'pivotColumnGroupTotals',\n            'suppressExpandablePivotGroups',\n        ]);\n        const aggregateStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'getGroupRowAgg',\n            'alwaysAggregateAtRootLevel',\n            'groupIncludeTotalFooter',\n            'suppressAggFilteredOnly',\n            'grandTotalRow',\n        ]);\n        const sortStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'postSortRows',\n            'groupDisplayType',\n            'accentedSort',\n        ]);\n        const filterAggStageRefreshProps: Set<keyof GridOptions> = new Set([]);\n        const flattenStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'groupRemoveSingleChildren',\n            'groupRemoveLowestSingleChildren',\n            'groupIncludeFooter',\n            'groupTotalRow',\n        ]);\n\n        const allProps = [\n            ...resetProps,\n            ...groupStageRefreshProps,\n            ...filterStageRefreshProps,\n            ...pivotStageRefreshProps,\n            ...pivotStageRefreshProps,\n            ...aggregateStageRefreshProps,\n            ...sortStageRefreshProps,\n            ...filterAggStageRefreshProps,\n            ...flattenStageRefreshProps,\n        ];\n        this.addManagedPropertyListeners(allProps, (params) => {\n            const properties = params.changeSet?.properties;\n            if (!properties) {\n                return;\n            }\n\n            const arePropertiesImpacted = (propSet: Set<keyof GridOptions>) =>\n                properties.some((prop) => propSet.has(prop));\n\n            if (arePropertiesImpacted(resetProps)) {\n                this.setRowData(this.rootNode.allLeafChildren!.map((child) => child.data));\n                return;\n            }\n\n            if (arePropertiesImpacted(groupStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.EVERYTHING });\n                return;\n            }\n\n            if (arePropertiesImpacted(filterStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.FILTER });\n                return;\n            }\n\n            if (arePropertiesImpacted(pivotStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n                return;\n            }\n            if (arePropertiesImpacted(aggregateStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n                return;\n            }\n\n            if (arePropertiesImpacted(sortStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.SORT });\n                return;\n            }\n\n            if (arePropertiesImpacted(filterAggStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.FILTER_AGGREGATES });\n                return;\n            }\n\n            if (arePropertiesImpacted(flattenStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n            }\n        });\n\n        this.addManagedPropertyListener('rowHeight', () => this.resetRowHeights());\n    }\n\n    public start(): void {\n        this.hasStarted = true;\n        if (this.shouldSkipSettingDataOnStart) {\n            this.dispatchUpdateEventsAndRefresh();\n        } else {\n            this.setInitialData();\n        }\n    }\n\n    private setInitialData(): void {\n        const rowData = this.gos.get('rowData');\n        if (rowData) {\n            this.shouldSkipSettingDataOnStart = true;\n            this.setRowData(rowData);\n        }\n    }\n\n    public ensureRowHeightsValid(\n        startPixel: number,\n        endPixel: number,\n        startLimitIndex: number,\n        endLimitIndex: number\n    ): boolean {\n        let atLeastOneChange: boolean;\n        let res = false;\n\n        // we do this multiple times as changing the row heights can also change the first and last rows,\n        // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n        // more rows.\n        do {\n            atLeastOneChange = false;\n\n            const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n            const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n\n            // keep check to current page if doing pagination\n            const firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n            const lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n\n            for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n                const rowNode = this.getRow(rowIndex);\n                if (rowNode.rowHeightEstimated) {\n                    const rowHeight = this.gos.getRowHeightForNode(rowNode);\n                    rowNode.setRowHeight(rowHeight.height);\n                    atLeastOneChange = true;\n                    res = true;\n                }\n            }\n\n            if (atLeastOneChange) {\n                this.setRowTopAndRowIndex();\n            }\n        } while (atLeastOneChange);\n\n        return res;\n    }\n\n    private setRowTopAndRowIndex(): Set<string> {\n        const defaultRowHeight = this.environment.getDefaultRowHeight();\n        let nextRowTop = 0;\n\n        // mapping displayed rows is not needed for this method, however it's used in\n        // clearRowTopAndRowIndex(), and given we are looping through this.rowsToDisplay here,\n        // we create the map here for performance reasons, so we don't loop a second time\n        // in clearRowTopAndRowIndex()\n        const displayedRowsMapped = new Set<string>();\n\n        // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n        // with these two layouts.\n        const allowEstimate = this.gos.isDomLayout('normal');\n\n        for (let i = 0; i < this.rowsToDisplay.length; i++) {\n            const rowNode = this.rowsToDisplay[i];\n\n            if (rowNode.id != null) {\n                displayedRowsMapped.add(rowNode.id);\n            }\n\n            if (rowNode.rowHeight == null) {\n                const rowHeight = this.gos.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);\n                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n            }\n\n            rowNode.setRowTop(nextRowTop);\n            rowNode.setRowIndex(i);\n            nextRowTop += rowNode.rowHeight!;\n        }\n\n        return displayedRowsMapped;\n    }\n\n    private clearRowTopAndRowIndex(changedPath: ChangedPath, displayedRowsMapped: Set<string>): void {\n        const changedPathActive = changedPath.isActive();\n\n        const clearIfNotDisplayed = (rowNode: RowNode) => {\n            if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n                rowNode.clearRowTopAndRowIndex();\n            }\n        };\n\n        const recurse = (rowNode: RowNode) => {\n            clearIfNotDisplayed(rowNode);\n            clearIfNotDisplayed(rowNode.detailNode);\n            clearIfNotDisplayed(rowNode.sibling);\n\n            if (rowNode.hasChildren()) {\n                if (rowNode.childrenAfterGroup) {\n                    // if a changedPath is active, it means we are here because of a transaction update or\n                    // a change detection. neither of these impacts the open/closed state of groups. so if\n                    // a group is not open this time, it was not open last time. so we know all closed groups\n                    // already have their top positions cleared. so there is no need to traverse all the way\n                    // when changedPath is active and the rowNode is not expanded.\n                    const isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n                    // as expanded=undefined for root node\n                    const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n                    if (!skipChildren) {\n                        rowNode.childrenAfterGroup.forEach(recurse);\n                    }\n                }\n            }\n        };\n\n        recurse(this.rootNode);\n    }\n\n    // returns false if row was moved, otherwise true\n    public ensureRowsAtPixel(rowNodes: RowNode[], pixel: number, increment: number = 0): boolean {\n        const indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        const animate = !this.gos.get('suppressAnimationFrame');\n\n        if (rowNodeAtPixelNow === rowNodes[0]) {\n            return false;\n        }\n\n        rowNodes.forEach((rowNode) => {\n            _removeFromArray(this.rootNode.allLeafChildren!, rowNode);\n        });\n\n        rowNodes.forEach((rowNode, idx) => {\n            _insertIntoArray(this.rootNode.allLeafChildren!, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n        });\n\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate,\n        });\n\n        return true;\n    }\n\n    public highlightRowAtPixel(rowNode: RowNode | null, pixel?: number): void {\n        const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n        const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n\n        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n            if (this.lastHighlightedRow) {\n                this.lastHighlightedRow.setHighlighted(null);\n                this.lastHighlightedRow = null;\n            }\n            return;\n        }\n\n        const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n\n        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n            this.lastHighlightedRow.setHighlighted(null);\n            this.lastHighlightedRow = null;\n        }\n\n        rowNodeAtPixelNow.setHighlighted(highlight);\n        this.lastHighlightedRow = rowNodeAtPixelNow;\n    }\n\n    public getHighlightPosition(pixel: number, rowNode?: RowNode): RowHighlightPosition {\n        if (!rowNode) {\n            const index = this.getRowIndexAtPixel(pixel);\n            rowNode = this.getRow(index || 0);\n\n            if (!rowNode) {\n                return RowHighlightPosition.Below;\n            }\n        }\n\n        const { rowTop, rowHeight } = rowNode;\n\n        return pixel - rowTop! < rowHeight! / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n    }\n\n    public getLastHighlightedRowNode(): RowNode | null {\n        return this.lastHighlightedRow;\n    }\n\n    public isLastRowIndexKnown(): boolean {\n        return true;\n    }\n\n    public getRowCount(): number {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n\n        return 0;\n    }\n\n    public getTopLevelRowCount(): number {\n        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n        if (showingRootNode) {\n            return 1;\n        }\n\n        const totalFooterInc = this.rootNode.sibling ? 1 : 0;\n\n        const filteredChildren = this.rootNode.childrenAfterAggFilter;\n        return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;\n    }\n\n    public getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n        if (showingRootNode) {\n            return topLevelIndex;\n        }\n\n        // if first row is footer, any following rows are pushed down by one\n        let adjustedIndex = topLevelIndex;\n        if (this.rowsToDisplay[0].footer) {\n            if (topLevelIndex === 0) {\n                return 0;\n            }\n            adjustedIndex -= 1;\n        }\n\n        let rowNode = this.rootNode.childrenAfterSort![adjustedIndex];\n\n        if (this.gos.get('groupHideOpenParents')) {\n            // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n            while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n                rowNode = rowNode.childrenAfterSort[0];\n            }\n        }\n\n        return rowNode.rowIndex!;\n    }\n\n    public getRowBounds(index: number): RowBounds | null {\n        if (_missing(this.rowsToDisplay)) {\n            return null;\n        }\n\n        const rowNode = this.rowsToDisplay[index];\n\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop!,\n                rowHeight: rowNode.rowHeight!,\n            };\n        }\n\n        return null;\n    }\n\n    public onRowGroupOpened(): void {\n        const animate = this.gos.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate: animate });\n    }\n\n    private onFilterChanged(event: FilterChangedEvent): void {\n        if (event.afterDataChange) {\n            return;\n        }\n        const animate = this.gos.isAnimateRows();\n\n        const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col) => col.isPrimary());\n        const step: ClientSideRowModelSteps = primaryOrQuickFilterChanged\n            ? ClientSideRowModelSteps.FILTER\n            : ClientSideRowModelSteps.FILTER_AGGREGATES;\n        this.refreshModel({ step: step, keepRenderedRows: true, animate: animate });\n    }\n\n    private onSortChanged(): void {\n        const animate = this.gos.isAnimateRows();\n        this.refreshModel({\n            step: ClientSideRowModelSteps.SORT,\n            keepRenderedRows: true,\n            animate: animate,\n            keepEditingRows: true,\n        });\n    }\n\n    public getType(): RowModelType {\n        return 'clientSide';\n    }\n\n    private onValueChanged(): void {\n        if (this.columnModel.isPivotActive()) {\n            this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n        } else {\n            this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n        }\n    }\n\n    private createChangePath(rowNodeTransactions: (RowNodeTransaction | null)[] | undefined): ChangedPath {\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n\n        const noTransactions = _missingOrEmpty(rowNodeTransactions);\n\n        const changedPath = new ChangedPath(false, this.rootNode);\n\n        if (noTransactions || this.gos.get('treeData')) {\n            changedPath.setInactive();\n        }\n\n        return changedPath;\n    }\n\n    private isSuppressModelUpdateAfterUpdateTransaction(params: RefreshModelParams): boolean {\n        if (!this.gos.get('suppressModelUpdateAfterUpdateTransaction')) {\n            return false;\n        }\n\n        // return true if we are only doing update transactions\n        if (params.rowNodeTransactions == null) {\n            return false;\n        }\n\n        const transWithAddsOrDeletes = params.rowNodeTransactions.filter(\n            (tx) => (tx.add != null && tx.add.length > 0) || (tx.remove != null && tx.remove.length > 0)\n        );\n\n        const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n\n        return transactionsContainUpdatesOnly;\n    }\n\n    private buildRefreshModelParams(step: ClientSideRowModelStep | undefined): RefreshModelParams | undefined {\n        let paramsStep = ClientSideRowModelSteps.EVERYTHING;\n        const stepsMapped: any = {\n            everything: ClientSideRowModelSteps.EVERYTHING,\n            group: ClientSideRowModelSteps.EVERYTHING,\n            filter: ClientSideRowModelSteps.FILTER,\n            map: ClientSideRowModelSteps.MAP,\n            aggregate: ClientSideRowModelSteps.AGGREGATE,\n            sort: ClientSideRowModelSteps.SORT,\n            pivot: ClientSideRowModelSteps.PIVOT,\n        };\n        if (_exists(step)) {\n            paramsStep = stepsMapped[step];\n        }\n\n        if (_missing(paramsStep)) {\n            _errorOnce(`invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(', ')}`);\n            return undefined;\n        }\n        const animate = !this.gos.get('suppressAnimationFrame');\n        const modelParams: RefreshModelParams = {\n            step: paramsStep,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate,\n        };\n        return modelParams;\n    }\n\n    refreshModel(paramsOrStep: RefreshModelParams | ClientSideRowModelStep | undefined): void {\n        if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching()) {\n            return;\n        }\n\n        const params =\n            typeof paramsOrStep === 'object' && 'step' in paramsOrStep\n                ? paramsOrStep\n                : this.buildRefreshModelParams(paramsOrStep);\n\n        if (!params) {\n            return;\n        }\n\n        if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n            return;\n        }\n\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n\n        const changedPath: ChangedPath = this.createChangePath(params.rowNodeTransactions);\n\n        this.isRefreshingModel = true;\n\n        switch (params.step) {\n            case ClientSideRowModelSteps.EVERYTHING:\n                this.doRowGrouping(\n                    params.rowNodeTransactions,\n                    params.rowNodeOrder,\n                    changedPath,\n                    !!params.afterColumnsChanged\n                );\n            /* eslint-disable no-fallthrough */\n            case ClientSideRowModelSteps.FILTER:\n                this.doFilter(changedPath);\n            case ClientSideRowModelSteps.PIVOT:\n                this.doPivot(changedPath);\n            case ClientSideRowModelSteps.AGGREGATE: // depends on agg fields\n                this.doAggregate(changedPath);\n            case ClientSideRowModelSteps.FILTER_AGGREGATES:\n                this.doFilterAggregates(changedPath);\n            case ClientSideRowModelSteps.SORT:\n                this.doSort(params.rowNodeTransactions, changedPath);\n            case ClientSideRowModelSteps.MAP:\n                this.doRowsToDisplay();\n            /* eslint-enable no-fallthrough */\n        }\n\n        // set all row tops to null, then set row tops on all visible rows. if we don't\n        // do this, then the algorithm below only sets row tops, old row tops from old rows\n        // will still lie around\n        const displayedNodesMapped = this.setRowTopAndRowIndex();\n        this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n\n        this.isRefreshingModel = false;\n\n        const event: WithoutGridCommon<ModelUpdatedEvent> = {\n            type: 'modelUpdated',\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false,\n            keepUndoRedoStack: params.keepUndoRedoStack,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public isEmpty(): boolean {\n        const rowsMissing = _missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        return _missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n    }\n\n    public isRowsToRender(): boolean {\n        return _exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    }\n\n    public getNodesInRangeForSelection(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        let started = false;\n        let finished = false;\n\n        const result: RowNode[] = [];\n\n        const groupsSelectChildren = this.gos.get('groupSelectsChildren');\n\n        this.forEachNodeAfterFilterAndSort((rowNode) => {\n            // range has been closed, skip till end\n            if (finished) {\n                return;\n            }\n\n            if (started) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    // check if this is the last node we're going to be adding\n                    finished = true;\n\n                    // if the final node was a group node, and we're doing groupSelectsChildren\n                    // make the exception to select all of it's descendants too\n                    if (rowNode.group && groupsSelectChildren) {\n                        result.push(...rowNode.allLeafChildren!);\n                        return;\n                    }\n                }\n            }\n\n            if (!started) {\n                if (rowNode !== lastInRange && rowNode !== firstInRange) {\n                    // still haven't hit a boundary node, keep searching\n                    return;\n                }\n                started = true;\n            }\n\n            // only select leaf nodes if groupsSelectChildren\n            const includeThisNode = !rowNode.group || !groupsSelectChildren;\n            if (includeThisNode) {\n                result.push(rowNode);\n                return;\n            }\n        });\n\n        return result;\n    }\n\n    // eslint-disable-next-line\n    public setDatasource(datasource: any): void {\n        _errorOnce('should never call setDatasource on clientSideRowController');\n    }\n\n    public getTopLevelNodes(): RowNode[] | null {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    }\n\n    public getRootNode(): RowNode {\n        return this.rootNode;\n    }\n\n    public getRow(index: number): RowNode {\n        return this.rowsToDisplay[index];\n    }\n\n    public isRowPresent(rowNode: RowNode): boolean {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    }\n\n    public getRowIndexAtPixel(pixelToMatch: number): number {\n        if (this.isEmpty() || this.rowsToDisplay.length === 0) {\n            return -1;\n        }\n\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        let bottomPointer = 0;\n        let topPointer = this.rowsToDisplay.length - 1;\n\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        const lastNode = _last(this.rowsToDisplay);\n        if (lastNode.rowTop! <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n\n        let oldBottomPointer = -1;\n        let oldTopPointer = -1;\n\n        while (true) {\n            const midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            const currentRowNode = this.rowsToDisplay[midPointer];\n\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n\n            if (currentRowNode.rowTop! < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            } else if (currentRowNode.rowTop! > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n\n            // infinite loops happen when there is space between rows. this can happen\n            // when Auto Height is active, cos we re-calculate row tops asynchronously\n            // when row heights change, which can temporarily result in gaps between rows.\n            const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;\n            if (caughtInInfiniteLoop) {\n                return midPointer;\n            }\n\n            oldBottomPointer = bottomPointer;\n            oldTopPointer = topPointer;\n        }\n    }\n\n    private isRowInPixel(rowNode: RowNode, pixelToMatch: number): boolean {\n        const topPixel = rowNode.rowTop;\n        const bottomPixel = rowNode.rowTop! + rowNode.rowHeight!;\n        const pixelInRow = topPixel! <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    }\n\n    public forEachLeafNode(callback: (node: RowNode, index: number) => void): void {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));\n        }\n    }\n\n    public forEachNode(callback: (node: RowNode, index: number) => void, includeFooterNodes: boolean = false): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterGroup || [])],\n            callback,\n            recursionType: RecursionType.Normal,\n            index: 0,\n            includeFooterNodes,\n        });\n    }\n\n    public forEachNodeAfterFilter(\n        callback: (node: RowNode, index: number) => void,\n        includeFooterNodes: boolean = false\n    ): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterAggFilter || [])],\n            callback,\n            recursionType: RecursionType.AfterFilter,\n            index: 0,\n            includeFooterNodes,\n        });\n    }\n\n    public forEachNodeAfterFilterAndSort(\n        callback: (node: RowNode, index: number) => void,\n        includeFooterNodes: boolean = false\n    ): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterSort || [])],\n            callback,\n            recursionType: RecursionType.AfterFilterAndSort,\n            index: 0,\n            includeFooterNodes,\n        });\n    }\n\n    public forEachPivotNode(\n        callback: (node: RowNode, index: number) => void,\n        includeFooterNodes: boolean = false\n    ): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [this.rootNode],\n            callback,\n            recursionType: RecursionType.PivotNodes,\n            index: 0,\n            includeFooterNodes,\n        });\n    }\n\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascript's array function\n    private recursivelyWalkNodesAndCallback(params: {\n        nodes: RowNode[];\n        callback: (node: RowNode, index: number) => void;\n        recursionType: RecursionType;\n        index: number;\n        includeFooterNodes: boolean;\n    }): number {\n        const { nodes, callback, recursionType, includeFooterNodes } = params;\n        let { index } = params;\n\n        const addFooters = (position: 'top' | 'bottom') => {\n            const parentNode = nodes[0]?.parent;\n\n            if (!parentNode) return;\n\n            const grandTotal = includeFooterNodes && this.gos.getGrandTotalRow();\n            const isGroupIncludeFooter = this.gos.getGroupTotalRowCallback();\n            const groupTotal = includeFooterNodes && isGroupIncludeFooter({ node: parentNode });\n\n            const isRootNode = parentNode === this.rootNode;\n            if (isRootNode) {\n                if (grandTotal === position) {\n                    parentNode.createFooter();\n                    callback(parentNode.sibling, index++);\n                }\n                return;\n            }\n\n            if (groupTotal === position) {\n                parentNode.createFooter();\n                callback(parentNode.sibling, index++);\n            }\n        };\n\n        addFooters('top');\n\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            callback(node, index++);\n            // go to the next level if it is a group\n            if (node.hasChildren() && !node.footer) {\n                // depending on the recursion type, we pick a difference set of children\n                let nodeChildren: RowNode[] | null = null;\n                switch (recursionType) {\n                    case RecursionType.Normal:\n                        nodeChildren = node.childrenAfterGroup;\n                        break;\n                    case RecursionType.AfterFilter:\n                        nodeChildren = node.childrenAfterAggFilter;\n                        break;\n                    case RecursionType.AfterFilterAndSort:\n                        nodeChildren = node.childrenAfterSort;\n                        break;\n                    case RecursionType.PivotNodes:\n                        // for pivot, we don't go below leafGroup levels\n                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                        break;\n                }\n                if (nodeChildren) {\n                    index = this.recursivelyWalkNodesAndCallback({\n                        nodes: [...nodeChildren],\n                        callback,\n                        recursionType,\n                        index,\n                        includeFooterNodes,\n                    });\n                }\n            }\n        }\n        addFooters('bottom');\n        return index;\n    }\n\n    // it's possible to recompute the aggregate without doing the other parts\n    // + api.refreshClientSideRowModel('aggregate')\n    public doAggregate(changedPath?: ChangedPath): void {\n        this.aggregationStage?.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    }\n\n    private doFilterAggregates(changedPath: ChangedPath): void {\n        if (this.filterAggregatesStage) {\n            this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        } else {\n            // If filterAggregatesStage is undefined, then so is the grouping stage, so all children should be on the rootNode.\n            this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;\n        }\n    }\n\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    public expandOrCollapseAll(expand: boolean): void {\n        const usingTreeData = this.gos.get('treeData');\n        const usingPivotMode = this.columnModel.isPivotActive();\n\n        const recursiveExpandOrCollapse = (rowNodes: RowNode[] | null): void => {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach((rowNode) => {\n                const actionRow = () => {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                };\n\n                if (usingTreeData) {\n                    const hasChildren = _exists(rowNode.childrenAfterGroup);\n                    if (hasChildren) {\n                        actionRow();\n                    }\n                    return;\n                }\n\n                if (usingPivotMode) {\n                    const notLeafGroup = !rowNode.leafGroup;\n                    if (notLeafGroup) {\n                        actionRow();\n                    }\n                    return;\n                }\n\n                const isRowGroup = rowNode.group;\n                if (isRowGroup) {\n                    actionRow();\n                }\n            });\n        };\n\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n\n        const eventSource = expand ? 'expandAll' : 'collapseAll';\n        const event: WithoutGridCommon<ExpandOrCollapseAllEvent> = {\n            type: 'expandOrCollapseAll',\n            source: eventSource,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private doSort(rowNodeTransactions: RowNodeTransaction[] | undefined, changedPath: ChangedPath) {\n        this.sortStage.execute({\n            rowNode: this.rootNode,\n            rowNodeTransactions: rowNodeTransactions,\n            changedPath: changedPath,\n        });\n    }\n\n    private doRowGrouping(\n        rowNodeTransactions: RowNodeTransaction[] | undefined,\n        rowNodeOrder: { [id: string]: number } | undefined,\n        changedPath: ChangedPath,\n        afterColumnsChanged: boolean\n    ) {\n        if (this.groupStage) {\n            if (rowNodeTransactions) {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    rowNodeTransactions: rowNodeTransactions,\n                    rowNodeOrder: rowNodeOrder,\n                    changedPath: changedPath,\n                });\n            } else {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    changedPath: changedPath,\n                    afterColumnsChanged: afterColumnsChanged,\n                });\n            }\n\n            if (this.gos.get('groupSelectsChildren')) {\n                const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections(\n                    'rowGroupChanged',\n                    changedPath\n                );\n\n                if (selectionChanged) {\n                    const event: WithoutGridCommon<SelectionChangedEvent> = {\n                        type: 'selectionChanged',\n                        source: 'rowGroupChanged',\n                    };\n                    this.eventService.dispatchEvent(event);\n                }\n            }\n        } else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n            if (this.rootNode.sibling) {\n                this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;\n            }\n            this.rootNode.updateHasChildren();\n        }\n\n        if (this.nodeManager.isRowCountReady()) {\n            // only if row data has been set\n            this.rowCountReady = true;\n            this.eventService.dispatchEventOnce({\n                type: 'rowCountReady',\n            });\n        }\n    }\n\n    private doFilter(changedPath: ChangedPath) {\n        this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    }\n\n    private doPivot(changedPath: ChangedPath) {\n        this.pivotStage?.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    }\n\n    public getCopyOfNodesMap(): { [id: string]: RowNode } {\n        return this.nodeManager.getCopyOfNodesMap();\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        // although id is typed a string, this could be called by the user, and they could have passed a number\n        const idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n\n        if (idIsGroup) {\n            // only one users complained about getRowNode not working for groups, after years of\n            // this working for normal rows. so have done quick implementation. if users complain\n            // about performance, then GroupStage should store / manage created groups in a map,\n            // which is a chunk of work.\n            let res: RowNode | undefined = undefined;\n            this.forEachNode((node) => {\n                if (node.id === id) {\n                    res = node;\n                }\n            });\n            return res;\n        }\n\n        return this.nodeManager.getRowNode(id);\n    }\n\n    // rows: the rows to put into the model\n    public setRowData(rowData: any[]): void {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n\n        // - clears selection, done before we set row data to ensure it isn't readded via `selectionService.syncInOldRowNode`\n        this.selectionService.reset('rowDataChanged');\n\n        this.nodeManager.setRowData(rowData);\n\n        if (this.hasStarted) {\n            this.dispatchUpdateEventsAndRefresh();\n        }\n    }\n\n    private dispatchUpdateEventsAndRefresh(): void {\n        // this event kicks off:\n        // - shows 'no rows' overlay if needed\n        const rowDataUpdatedEvent: WithoutGridCommon<RowDataUpdatedEvent> = {\n            type: 'rowDataUpdated',\n        };\n        this.eventService.dispatchEvent(rowDataUpdatedEvent);\n\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            newData: true,\n        });\n    }\n\n    public batchUpdateRowData(\n        rowDataTransaction: RowDataTransaction,\n        callback?: (res: RowNodeTransaction) => void\n    ): void {\n        if (this.applyAsyncTransactionsTimeout == null) {\n            this.rowDataTransactionBatch = [];\n            const waitMillis = this.gos.getAsyncTransactionWaitMillis();\n            this.applyAsyncTransactionsTimeout = window.setTimeout(() => {\n                this.executeBatchUpdateRowData();\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch!.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    }\n\n    public flushAsyncTransactions(): void {\n        if (this.applyAsyncTransactionsTimeout != null) {\n            clearTimeout(this.applyAsyncTransactionsTimeout);\n            this.executeBatchUpdateRowData();\n        }\n    }\n\n    private executeBatchUpdateRowData(): void {\n        this.valueCache.onDataChanged();\n\n        const callbackFuncsBound: ((...args: any[]) => any)[] = [];\n        const rowNodeTrans: RowNodeTransaction[] = [];\n\n        // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n        // commonUpdateRowData, using addIndex would have no effect when grouping.\n        let forceRowNodeOrder = false;\n\n        if (this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch.forEach((tranItem) => {\n                const rowNodeTran = this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n                rowNodeTrans.push(rowNodeTran);\n                if (tranItem.callback) {\n                    callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n                }\n                if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n                    forceRowNodeOrder = true;\n                }\n            });\n        }\n\n        this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder);\n\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            window.setTimeout(() => {\n                callbackFuncsBound.forEach((func) => func());\n            }, 0);\n        }\n\n        if (rowNodeTrans.length > 0) {\n            const event: WithoutGridCommon<AsyncTransactionsFlushed> = {\n                type: 'asyncTransactionsFlushed',\n                results: rowNodeTrans,\n            };\n            this.eventService.dispatchEvent(event);\n        }\n\n        this.rowDataTransactionBatch = null;\n        this.applyAsyncTransactionsTimeout = undefined;\n    }\n\n    public updateRowData(\n        rowDataTran: RowDataTransaction,\n        rowNodeOrder?: { [id: string]: number }\n    ): RowNodeTransaction | null {\n        this.valueCache.onDataChanged();\n\n        const rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n\n        // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n        // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n        // stage also uses the\n        const forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n\n        return rowNodeTran;\n    }\n\n    private createRowNodeOrder(): { [id: string]: number } | undefined {\n        const suppressSortOrder = this.gos.get('suppressMaintainUnsortedOrder');\n        if (suppressSortOrder) {\n            return;\n        }\n\n        const orderMap: { [id: string]: number } = {};\n\n        if (this.rootNode && this.rootNode.allLeafChildren) {\n            for (let index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n                const node = this.rootNode.allLeafChildren[index];\n                orderMap[node.id!] = index;\n            }\n        }\n\n        return orderMap;\n    }\n\n    // common to updateRowData and batchUpdateRowData\n    private commonUpdateRowData(\n        rowNodeTrans: RowNodeTransaction[],\n        rowNodeOrder: { [id: string]: number } | undefined,\n        forceRowNodeOrder: boolean\n    ): void {\n        if (!this.hasStarted) {\n            return;\n        }\n\n        const animate = !this.gos.get('suppressAnimationFrame');\n\n        if (forceRowNodeOrder) {\n            rowNodeOrder = this.createRowNodeOrder();\n        }\n\n        const event: WithoutGridCommon<RowDataUpdatedEvent> = {\n            type: 'rowDataUpdated',\n        };\n        this.eventService.dispatchEvent(event);\n\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate,\n        });\n    }\n\n    private doRowsToDisplay() {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode }) as RowNode[];\n    }\n\n    public onRowHeightChanged(): void {\n        this.refreshModel({\n            step: ClientSideRowModelSteps.MAP,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            keepUndoRedoStack: true,\n        });\n    }\n\n    /** This method is debounced. It is used for row auto-height. If we don't debounce,\n     * then the Row Models will end up recalculating each row position\n     * for each row height change and result in the Row Renderer laying out rows.\n     * This is particularly bad if using print layout, and showing eg 1,000 rows,\n     * each row will change it's height, causing Row Model to update 1,000 times.\n     */\n    public onRowHeightChangedDebounced(): void {\n        this.onRowHeightChanged_debounced();\n    }\n\n    public resetRowHeights(): void {\n        const atLeastOne = this.resetRowHeightsForAllRowNodes();\n\n        this.rootNode.setRowHeight(this.rootNode.rowHeight, true);\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);\n        }\n\n        // when pivotMode but pivot not active, root node is displayed on its own\n        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required\n        if (atLeastOne) {\n            this.onRowHeightChanged();\n        }\n    }\n\n    private resetRowHeightsForAllRowNodes(): boolean {\n        let atLeastOne = false;\n        this.forEachNode((rowNode) => {\n            rowNode.setRowHeight(rowNode.rowHeight, true);\n            // we keep the height each row is at, however we set estimated=true rather than clear the height.\n            // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n            const detailNode = rowNode.detailNode;\n            if (detailNode) {\n                detailNode.setRowHeight(detailNode.rowHeight, true);\n            }\n\n            if (rowNode.sibling) {\n                rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);\n            }\n            atLeastOne = true;\n        });\n\n        return atLeastOne;\n    }\n\n    private onGridStylesChanges(e: CssVariablesChanged) {\n        if (e.rowHeightChanged) {\n            if (this.columnModel.isAutoRowHeightActive()) {\n                return;\n            }\n\n            this.resetRowHeights();\n        }\n    }\n\n    private onGridReady(): void {\n        if (this.hasStarted) {\n            return;\n        }\n        // App can start using API to add transactions, so need to add data into the node manager if not started\n        this.setInitialData();\n    }\n\n    public isRowDataLoaded(): boolean {\n        return this.rowCountReady;\n    }\n}\n", "import type {\n    BeanCollection,\n    EventService,\n    FuncColsService,\n    GridOptionsService,\n    ISelectionService,\n    RowDataTransaction,\n    RowDataUpdateStartedEvent,\n    RowNodeTransaction,\n    SelectionChangedEvent,\n    SelectionEventSourceType,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport {\n    RowNode,\n    _cloneObject,\n    _errorOnce,\n    _missingOrEmpty,\n    _sortRowNodesByOrder,\n    _warnOnce,\n} from '@ag-grid-community/core';\n\nconst ROOT_NODE_ID = 'ROOT_NODE_ID';\nconst TOP_LEVEL = 0;\nexport class ClientSideNodeManager {\n    private readonly rootNode: RowNode;\n\n    private gos: GridOptionsService;\n    private eventService: EventService;\n    private funcColsService: FuncColsService;\n    private selectionService: ISelectionService;\n    private beans: BeanCollection;\n\n    private nextId = 0;\n\n    // has row data actually been set\n    private rowCountReady = false;\n\n    // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n    private allNodesMap: { [id: string]: RowNode } = {};\n\n    constructor(\n        rootNode: RowNode,\n        gos: GridOptionsService,\n        eventService: EventService,\n        funcColsService: FuncColsService,\n        selectionService: ISelectionService,\n        beans: BeanCollection\n    ) {\n        this.rootNode = rootNode;\n        this.gos = gos;\n        this.eventService = eventService;\n        this.funcColsService = funcColsService;\n        this.beans = beans;\n        this.selectionService = selectionService;\n\n        this.rootNode.group = true;\n        this.rootNode.level = -1;\n        this.rootNode.id = ROOT_NODE_ID;\n        this.rootNode.allLeafChildren = [];\n        this.rootNode.childrenAfterGroup = [];\n        this.rootNode.childrenAfterSort = [];\n        this.rootNode.childrenAfterAggFilter = [];\n        this.rootNode.childrenAfterFilter = [];\n    }\n\n    public getCopyOfNodesMap(): { [id: string]: RowNode } {\n        return _cloneObject(this.allNodesMap);\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        return this.allNodesMap[id];\n    }\n\n    public setRowData(rowData: any[]): RowNode[] | undefined {\n        if (typeof rowData === 'string') {\n            _warnOnce('rowData must be an array.');\n            return;\n        }\n        this.rowCountReady = true;\n\n        this.dispatchRowDataUpdateStartedEvent(rowData);\n\n        const rootNode = this.rootNode;\n        const sibling = this.rootNode.sibling;\n\n        rootNode.childrenAfterFilter = null;\n        rootNode.childrenAfterGroup = null;\n        rootNode.childrenAfterAggFilter = null;\n        rootNode.childrenAfterSort = null;\n        rootNode.childrenMapped = null;\n        rootNode.updateHasChildren();\n\n        this.nextId = 0;\n        this.allNodesMap = {};\n\n        if (rowData) {\n            // we use rootNode as the parent, however if using ag-grid-enterprise, the grouping stage\n            // sets the parent node on each row (even if we are not grouping). so setting parent node\n            // here is for benefit of ag-grid-community users\n            rootNode.allLeafChildren = rowData.map((dataItem) => this.createNode(dataItem, this.rootNode, TOP_LEVEL));\n        } else {\n            rootNode.allLeafChildren = [];\n            rootNode.childrenAfterGroup = [];\n        }\n\n        if (sibling) {\n            sibling.childrenAfterFilter = rootNode.childrenAfterFilter;\n            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n            sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;\n            sibling.childrenAfterSort = rootNode.childrenAfterSort;\n            sibling.childrenMapped = rootNode.childrenMapped;\n            sibling.allLeafChildren = rootNode.allLeafChildren;\n        }\n    }\n\n    public updateRowData(\n        rowDataTran: RowDataTransaction,\n        rowNodeOrder: { [id: string]: number } | null | undefined\n    ): RowNodeTransaction {\n        this.rowCountReady = true;\n        this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);\n\n        const rowNodeTransaction: RowNodeTransaction = {\n            remove: [],\n            update: [],\n            add: [],\n        };\n\n        const nodesToUnselect: RowNode[] = [];\n\n        this.executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect);\n        this.executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect);\n        this.executeAdd(rowDataTran, rowNodeTransaction);\n\n        this.updateSelection(nodesToUnselect, 'rowDataChanged');\n\n        if (rowNodeOrder) {\n            _sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);\n        }\n\n        return rowNodeTransaction;\n    }\n\n    public isRowCountReady(): boolean {\n        return this.rowCountReady;\n    }\n\n    private dispatchRowDataUpdateStartedEvent(rowData?: any[] | null): void {\n        const event: WithoutGridCommon<RowDataUpdateStartedEvent> = {\n            type: 'rowDataUpdateStarted',\n            firstRowData: rowData?.length ? rowData[0] : null,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private updateSelection(nodesToUnselect: RowNode[], source: SelectionEventSourceType): void {\n        const selectionChanged = nodesToUnselect.length > 0;\n        if (selectionChanged) {\n            this.selectionService.setNodesSelected({\n                newValue: false,\n                nodes: nodesToUnselect,\n                suppressFinishActions: true,\n                source,\n            });\n        }\n\n        // we do this regardless of nodes to unselect or not, as it's possible\n        // a new node was inserted, so a parent that was previously selected (as all\n        // children were selected) should not be tri-state (as new one unselected against\n        // all other selected children).\n        this.selectionService.updateGroupsFromChildrenSelections(source);\n\n        if (selectionChanged) {\n            const event: WithoutGridCommon<SelectionChangedEvent> = {\n                type: 'selectionChanged',\n                source: source,\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    private executeAdd(rowDataTran: RowDataTransaction, rowNodeTransaction: RowNodeTransaction): void {\n        const { add, addIndex } = rowDataTran;\n        if (_missingOrEmpty(add)) {\n            return;\n        }\n\n        // create new row nodes for each data item\n        const newNodes: RowNode[] = add!.map((item) => this.createNode(item, this.rootNode, TOP_LEVEL));\n\n        const allLeafChildren = this.rootNode.allLeafChildren!;\n        if (typeof addIndex === 'number' && addIndex >= 0) {\n            // new rows are inserted in one go by concatenating them in between the existing rows at the desired index.\n            // this is much faster than splicing them individually into 'allLeafChildren' when there are large inserts.\n            const len = allLeafChildren.length;\n            let normalisedAddIndex = addIndex;\n\n            const isTreeData = this.gos.get('treeData');\n            if (isTreeData && addIndex > 0 && len > 0) {\n                for (let i = 0; i < len; i++) {\n                    if (allLeafChildren[i]?.rowIndex == addIndex - 1) {\n                        normalisedAddIndex = i + 1;\n                        break;\n                    }\n                }\n            }\n\n            const nodesBeforeIndex = allLeafChildren.slice(0, normalisedAddIndex);\n            const nodesAfterIndex = allLeafChildren.slice(normalisedAddIndex, allLeafChildren.length);\n            this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];\n        } else {\n            this.rootNode.allLeafChildren = [...allLeafChildren, ...newNodes];\n        }\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.allLeafChildren = allLeafChildren;\n        }\n        // add new row nodes to the transaction add items\n        rowNodeTransaction.add = newNodes;\n    }\n\n    private executeRemove(\n        rowDataTran: RowDataTransaction,\n        rowNodeTransaction: RowNodeTransaction,\n        nodesToUnselect: RowNode[]\n    ): void {\n        const { remove } = rowDataTran;\n\n        if (_missingOrEmpty(remove)) {\n            return;\n        }\n\n        const rowIdsRemoved: { [key: string]: boolean } = {};\n\n        remove!.forEach((item) => {\n            const rowNode = this.lookupRowNode(item);\n\n            if (!rowNode) {\n                return;\n            }\n\n            // do delete - setting 'suppressFinishActions = true' to ensure EVENT_SELECTION_CHANGED is not raised for\n            // each row node updated, instead it is raised once by the calling code if any selected nodes exist.\n            if (rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n\n            // so row renderer knows to fade row out (and not reposition it)\n            rowNode.clearRowTopAndRowIndex();\n\n            // NOTE: were we could remove from allLeaveChildren, however removeFromArray() is expensive, especially\n            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list\n            rowIdsRemoved[rowNode.id!] = true;\n            // removeFromArray(this.rootNode.allLeafChildren, rowNode);\n            delete this.allNodesMap[rowNode.id!];\n\n            rowNodeTransaction.remove.push(rowNode);\n        });\n\n        this.rootNode.allLeafChildren =\n            this.rootNode.allLeafChildren?.filter((rowNode) => !rowIdsRemoved[rowNode.id!]) ?? null;\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;\n        }\n    }\n\n    private executeUpdate(\n        rowDataTran: RowDataTransaction,\n        rowNodeTransaction: RowNodeTransaction,\n        nodesToUnselect: RowNode[]\n    ): void {\n        const { update } = rowDataTran;\n        if (_missingOrEmpty(update)) {\n            return;\n        }\n\n        update!.forEach((item) => {\n            const rowNode = this.lookupRowNode(item);\n\n            if (!rowNode) {\n                return;\n            }\n\n            rowNode.updateData(item);\n            if (!rowNode.selectable && rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n\n            this.setMasterForRow(rowNode, item, TOP_LEVEL, false);\n\n            rowNodeTransaction.update.push(rowNode);\n        });\n    }\n\n    private lookupRowNode(data: any): RowNode | null {\n        const getRowIdFunc = this.gos.getRowIdCallback();\n\n        let rowNode: RowNode | undefined;\n        if (getRowIdFunc) {\n            // find rowNode using id\n            const id = getRowIdFunc({ data, level: 0 });\n            rowNode = this.allNodesMap[id];\n            if (!rowNode) {\n                _errorOnce(`could not find row id=${id}, data item was not found for this id`);\n                return null;\n            }\n        } else {\n            // find rowNode using object references\n            rowNode = this.rootNode.allLeafChildren?.find((node) => node.data === data);\n            if (!rowNode) {\n                _errorOnce(`could not find data item as object was not found`, data);\n                _errorOnce(`Consider using getRowId to help the Grid find matching row data`);\n                return null;\n            }\n        }\n\n        return rowNode || null;\n    }\n\n    private createNode(dataItem: any, parent: RowNode, level: number): RowNode {\n        const node = new RowNode(this.beans);\n\n        node.group = false;\n        this.setMasterForRow(node, dataItem, level, true);\n\n        if (parent) {\n            node.parent = parent;\n        }\n        node.level = level;\n        node.setDataAndId(dataItem, this.nextId.toString());\n\n        if (this.allNodesMap[node.id!]) {\n            _warnOnce(\n                `duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`\n            );\n        }\n        this.allNodesMap[node.id!] = node;\n\n        this.nextId++;\n\n        return node;\n    }\n\n    private setMasterForRow(rowNode: RowNode, data: any, level: number, setExpanded: boolean): void {\n        const isTreeData = this.gos.get('treeData');\n        if (isTreeData) {\n            rowNode.setMaster(false);\n            if (setExpanded) {\n                rowNode.expanded = false;\n            }\n        } else {\n            const masterDetail = this.gos.get('masterDetail');\n            // this is the default, for when doing grid data\n            if (masterDetail) {\n                // if we are doing master detail, then the\n                // default is that everything can be a Master Row.\n                const isRowMasterFunc = this.gos.get('isRowMaster');\n                if (isRowMasterFunc) {\n                    rowNode.setMaster(isRowMasterFunc(data));\n                } else {\n                    rowNode.setMaster(true);\n                }\n            } else {\n                rowNode.setMaster(false);\n            }\n\n            if (setExpanded) {\n                const rowGroupColumns = this.funcColsService.getRowGroupColumns();\n                const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;\n\n                // need to take row group into account when determining level\n                const masterRowLevel = level + numRowGroupColumns;\n\n                rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;\n            }\n        }\n    }\n\n    private isExpanded(level: any) {\n        const expandByDefault = this.gos.get('groupDefaultExpanded');\n        if (expandByDefault === -1) {\n            return true;\n        }\n        return level < expandByDefault;\n    }\n}\n", "import type {\n    BeanCollection,\n    ClientSideRowModelStep,\n    IRowNode,\n    RowDataTransaction,\n    RowNodeTransaction,\n} from '@ag-grid-community/core';\nimport { _warnOnce } from '@ag-grid-community/core';\n\nexport function onGroupExpandedOrCollapsed(beans: BeanCollection): void {\n    beans.expansionService.onGroupExpandedOrCollapsed();\n}\n\nexport function refreshClientSideRowModel(beans: BeanCollection, step?: ClientSideRowModelStep): void {\n    beans.rowModelHelperService?.getClientSideRowModel()?.refreshModel(step);\n}\n\nexport function forEachLeafNode<TData = any>(\n    beans: BeanCollection,\n    callback: (rowNode: IRowNode<TData>) => void\n): void {\n    beans.rowModelHelperService?.getClientSideRowModel()?.forEachLeafNode(callback);\n}\n\nexport function forEachNodeAfterFilter<TData = any>(\n    beans: BeanCollection,\n    callback: (rowNode: IRowNode<TData>, index: number) => void\n): void {\n    beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilter(callback);\n}\n\nexport function forEachNodeAfterFilterAndSort<TData = any>(\n    beans: BeanCollection,\n    callback: (rowNode: IRowNode<TData>, index: number) => void\n): void {\n    beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilterAndSort(callback);\n}\n\nexport function resetRowHeights(beans: BeanCollection): void {\n    if (beans.columnModel.isAutoRowHeightActive()) {\n        _warnOnce('calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.');\n        return;\n    }\n    beans.rowModelHelperService?.getClientSideRowModel()?.resetRowHeights();\n}\n\nexport function applyTransaction<TData = any>(\n    beans: BeanCollection,\n    rowDataTransaction: RowDataTransaction<TData>\n): RowNodeTransaction<TData> | null | undefined {\n    return beans.frameworkOverrides.wrapIncoming(() =>\n        beans.rowModelHelperService?.getClientSideRowModel()?.updateRowData(rowDataTransaction)\n    );\n}\n\nexport function applyTransactionAsync<TData = any>(\n    beans: BeanCollection,\n    rowDataTransaction: RowDataTransaction<TData>,\n    callback?: (res: RowNodeTransaction<TData>) => void\n): void {\n    beans.frameworkOverrides.wrapIncoming(() =>\n        beans.rowModelHelperService?.getClientSideRowModel()?.batchUpdateRowData(rowDataTransaction, callback)\n    );\n}\n\nexport function flushAsyncTransactions(beans: BeanCollection): void {\n    beans.frameworkOverrides.wrapIncoming(() =>\n        beans.rowModelHelperService?.getClientSideRowModel()?.flushAsyncTransactions()\n    );\n}\n\nexport function getBestCostNodeSelection<TData = any>(beans: BeanCollection): IRowNode<TData>[] | undefined {\n    return beans.selectionService.getBestCostNodeSelection();\n}\n", "import type {\n    BeanCollection,\n    ChangedPath,\n    FilterManager,\n    IRowNodeStage,\n    NamedBean,\n    RowNode,\n    StageExecuteParams,\n} from '@ag-grid-community/core';\nimport { BeanStub } from '@ag-grid-community/core';\n\nexport class FilterStage extends BeanStub implements IRowNodeStage, NamedBean {\n    beanName = 'filterStage' as const;\n\n    private filterManager?: FilterManager;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.filterManager = beans.filterManager;\n    }\n\n    public execute(params: StageExecuteParams): void {\n        const { changedPath } = params;\n        this.filter(changedPath!);\n    }\n\n    private filter(changedPath: ChangedPath): void {\n        const filterActive: boolean = !!this.filterManager?.isChildFilterPresent();\n        this.filterNodes(filterActive, changedPath);\n    }\n\n    private filterNodes(filterActive: boolean, changedPath: ChangedPath): void {\n        const filterCallback = (rowNode: RowNode, includeChildNodes: boolean) => {\n            // recursively get all children that are groups to also filter\n            if (rowNode.hasChildren()) {\n                // result of filter for this node. when filtering tree data, includeChildNodes = true when parent passes\n                if (filterActive && !includeChildNodes) {\n                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup!.filter((childNode) => {\n                        // a group is included in the result if it has any children of it's own.\n                        // by this stage, the child groups are already filtered\n                        const passBecauseChildren =\n                            childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;\n\n                        // both leaf level nodes and tree data nodes have data. these get added if\n                        // the data passes the filter\n                        const passBecauseDataPasses =\n                            childNode.data && this.filterManager!.doesRowPassFilter({ rowNode: childNode });\n\n                        // note - tree data nodes pass either if a) they pass themselves or b) any children of that node pass\n\n                        return passBecauseChildren || passBecauseDataPasses;\n                    });\n                } else {\n                    // if not filtering, the result is the original list\n                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n                }\n            } else {\n                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n            }\n\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;\n            }\n        };\n\n        if (this.doingTreeDataFiltering()) {\n            const treeDataDepthFirstFilter = (rowNode: RowNode, alreadyFoundInParent: boolean) => {\n                // tree data filter traverses the hierarchy depth first and includes child nodes if parent passes\n                // filter, and parent nodes will be include if any children exist.\n\n                if (rowNode.childrenAfterGroup) {\n                    for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n                        const childNode = rowNode.childrenAfterGroup[i];\n\n                        // first check if current node passes filter before invoking child nodes\n                        const foundInParent =\n                            alreadyFoundInParent || this.filterManager!.doesRowPassFilter({ rowNode: childNode });\n                        if (childNode.childrenAfterGroup) {\n                            treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);\n                        } else {\n                            filterCallback(childNode, foundInParent);\n                        }\n                    }\n                }\n                filterCallback(rowNode, alreadyFoundInParent);\n            };\n\n            const treeDataFilterCallback = (rowNode: RowNode) => treeDataDepthFirstFilter(rowNode, false);\n            changedPath.executeFromRootNode(treeDataFilterCallback);\n        } else {\n            const defaultFilterCallback = (rowNode: RowNode) => filterCallback(rowNode, false);\n            changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);\n        }\n    }\n\n    private doingTreeDataFiltering() {\n        return this.gos.get('treeData') && !this.gos.get('excludeChildrenWhenTreeDataFiltering');\n    }\n}\n", "import type {\n    BeanCollection,\n    ColumnModel,\n    GetGroupIncludeFooterParams,\n    IRowNodeStage,\n    NamedBean,\n    StageExecuteParams,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, RowNode, _exists, _missingOrEmpty } from '@ag-grid-community/core';\n\ninterface FlattenDetails {\n    hideOpenParents: boolean;\n    groupRemoveSingleChildren: boolean;\n    groupRemoveLowestSingleChildren: boolean;\n    isGroupMultiAutoColumn: boolean;\n    grandTotalRow: 'top' | 'bottom' | undefined;\n    groupTotalRow: (params: WithoutGridCommon<GetGroupIncludeFooterParams<any, any>>) => 'top' | 'bottom' | undefined;\n}\n\nexport class FlattenStage extends BeanStub implements IRowNodeStage, NamedBean {\n    beanName = 'flattenStage' as const;\n\n    private beans: BeanCollection;\n    private columnModel: ColumnModel;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.beans = beans;\n        this.columnModel = beans.columnModel;\n    }\n\n    public execute(params: StageExecuteParams): RowNode[] {\n        const rootNode = params.rowNode;\n\n        // even if not doing grouping, we do the mapping, as the client might\n        // of passed in data that already has a grouping in it somewhere\n        const result: RowNode[] = [];\n        const skipLeafNodes = this.columnModel.isPivotMode();\n        // if we are reducing, and not grouping, then we want to show the root node, as that\n        // is where the pivot values are\n        const showRootNode = skipLeafNodes && rootNode.leafGroup;\n        const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n\n        const details = this.getFlattenDetails();\n\n        this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);\n\n        // we do not want the footer total if the gris is empty\n        const atLeastOneRowPresent = result.length > 0;\n\n        const includeGrandTotalRow =\n            !showRootNode &&\n            // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n            atLeastOneRowPresent &&\n            details.grandTotalRow;\n\n        if (includeGrandTotalRow) {\n            rootNode.createFooter();\n            const addToTop = details.grandTotalRow === 'top';\n            this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0, addToTop);\n        }\n\n        return result;\n    }\n\n    private getFlattenDetails(): FlattenDetails {\n        // these two are mutually exclusive, so if first set, we don't set the second\n        const groupRemoveSingleChildren = this.gos.get('groupRemoveSingleChildren');\n        const groupRemoveLowestSingleChildren =\n            !groupRemoveSingleChildren && this.gos.get('groupRemoveLowestSingleChildren');\n\n        return {\n            groupRemoveLowestSingleChildren,\n            groupRemoveSingleChildren,\n            isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),\n            hideOpenParents: this.gos.get('groupHideOpenParents'),\n            grandTotalRow: this.gos.getGrandTotalRow(),\n            groupTotalRow: this.gos.getGroupTotalRowCallback(),\n        };\n    }\n\n    private recursivelyAddToRowsToDisplay(\n        details: FlattenDetails,\n        rowsToFlatten: RowNode[] | null,\n        result: RowNode[],\n        skipLeafNodes: boolean,\n        uiLevel: number\n    ) {\n        if (_missingOrEmpty(rowsToFlatten)) {\n            return;\n        }\n\n        for (let i = 0; i < rowsToFlatten!.length; i++) {\n            const rowNode = rowsToFlatten![i];\n            // check all these cases, for working out if this row should be included in the final mapped list\n            const isParent = rowNode.hasChildren();\n\n            const isSkippedLeafNode = skipLeafNodes && !isParent;\n\n            const isRemovedSingleChildrenGroup =\n                details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup!.length === 1;\n\n            const isRemovedLowestSingleChildrenGroup =\n                details.groupRemoveLowestSingleChildren &&\n                isParent &&\n                rowNode.leafGroup &&\n                rowNode.childrenAfterGroup!.length === 1;\n\n            // hide open parents means when group is open, we don't show it. we also need to make sure the\n            // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).\n            // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all row groups')\n            const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n\n            const isHiddenOpenParent =\n                details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;\n\n            const thisRowShouldBeRendered =\n                !isSkippedLeafNode &&\n                !isHiddenOpenParent &&\n                !isRemovedSingleChildrenGroup &&\n                !isRemovedLowestSingleChildrenGroup;\n\n            if (thisRowShouldBeRendered) {\n                this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);\n            }\n\n            // if we are pivoting, we never map below the leaf group\n            if (skipLeafNodes && rowNode.leafGroup) {\n                continue;\n            }\n\n            if (isParent) {\n                const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;\n\n                // we traverse the group if it is expended, however we always traverse if the parent node\n                // was removed (as the group will never be opened if it is not displayed, we show the children instead)\n                if (rowNode.expanded || excludedParent) {\n                    const doesRowShowFooter = details.groupTotalRow({ node: rowNode });\n                    if (!doesRowShowFooter) {\n                        rowNode.destroyFooter();\n                    }\n\n                    // if the parent was excluded, then ui level is that of the parent\n                    const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n                    if (doesRowShowFooter === 'top') {\n                        rowNode.createFooter();\n                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n                    }\n\n                    this.recursivelyAddToRowsToDisplay(\n                        details,\n                        rowNode.childrenAfterSort,\n                        result,\n                        skipLeafNodes,\n                        uiLevelForChildren\n                    );\n\n                    if (doesRowShowFooter === 'bottom') {\n                        rowNode.createFooter();\n                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n                    }\n                }\n            } else if (rowNode.master && rowNode.expanded) {\n                const detailNode = this.createDetailNode(rowNode);\n                this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);\n            }\n        }\n    }\n\n    // duplicated method, it's also in floatingRowModel\n    private addRowNodeToRowsToDisplay(\n        details: FlattenDetails,\n        rowNode: RowNode,\n        result: RowNode[],\n        uiLevel: number,\n        addToTop?: boolean\n    ): void {\n        if (addToTop) {\n            result.unshift(rowNode);\n        } else {\n            result.push(rowNode);\n        }\n        rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);\n    }\n\n    private createDetailNode(masterNode: RowNode): RowNode {\n        if (_exists(masterNode.detailNode)) {\n            return masterNode.detailNode;\n        }\n\n        const detailNode = new RowNode(this.beans);\n\n        detailNode.detail = true;\n        detailNode.selectable = false;\n        detailNode.parent = masterNode;\n\n        if (_exists(masterNode.id)) {\n            detailNode.id = 'detail_' + masterNode.id;\n        }\n\n        detailNode.data = masterNode.data;\n        detailNode.level = masterNode.level + 1;\n        masterNode.detailNode = detailNode;\n\n        return detailNode;\n    }\n}\n", "import type {\n    BeanCollection,\n    IImmutableService,\n    IRowModel,\n    ISelectionService,\n    NamedBean,\n    RowDataTransaction,\n    RowNode,\n} from '@ag-grid-community/core';\nimport { BeanStub, _errorOnce, _exists, _iterateObject, _missing } from '@ag-grid-community/core';\n\nimport type { ClientSideRowModel } from './clientSideRowModel';\n\nexport class ImmutableService extends BeanStub implements NamedBean, IImmutableService {\n    beanName = 'immutableService' as const;\n\n    private rowModel: IRowModel;\n    private selectionService: ISelectionService;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.rowModel = beans.rowModel;\n        this.selectionService = beans.selectionService;\n    }\n\n    private clientSideRowModel: ClientSideRowModel;\n\n    public postConstruct(): void {\n        if (this.rowModel.getType() === 'clientSide') {\n            this.clientSideRowModel = this.rowModel as ClientSideRowModel;\n\n            this.addManagedPropertyListener('rowData', () => this.onRowDataUpdated());\n        }\n    }\n\n    public isActive(): boolean {\n        const getRowIdProvided = this.gos.exists('getRowId');\n        // this property is a backwards compatibility property, for those who want\n        // the old behaviour of Row ID's but NOT Immutable Data.\n        const resetRowDataOnUpdate = this.gos.get('resetRowDataOnUpdate');\n\n        if (resetRowDataOnUpdate) {\n            return false;\n        }\n        return getRowIdProvided;\n    }\n\n    public setRowData(rowData: any[]): void {\n        const transactionAndMap = this.createTransactionForRowData(rowData);\n        if (!transactionAndMap) {\n            return;\n        }\n\n        const [transaction, orderIdMap] = transactionAndMap;\n        this.clientSideRowModel.updateRowData(transaction, orderIdMap);\n    }\n\n    // converts the setRowData() command to a transaction\n    private createTransactionForRowData(\n        rowData: any[]\n    ): [RowDataTransaction, { [id: string]: number } | undefined] | undefined {\n        if (_missing(this.clientSideRowModel)) {\n            _errorOnce('ImmutableService only works with ClientSideRowModel');\n            return;\n        }\n\n        const getRowIdFunc = this.gos.getRowIdCallback();\n        if (getRowIdFunc == null) {\n            _errorOnce('ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!');\n            return;\n        }\n\n        // convert the data into a transaction object by working out adds, removes and updates\n        const transaction: RowDataTransaction = {\n            remove: [],\n            update: [],\n            add: [],\n        };\n\n        const existingNodesMap: { [id: string]: RowNode | undefined } = this.clientSideRowModel.getCopyOfNodesMap();\n\n        const suppressSortOrder = this.gos.get('suppressMaintainUnsortedOrder');\n        const orderMap: { [id: string]: number } | undefined = suppressSortOrder ? undefined : {};\n\n        if (_exists(rowData)) {\n            // split all the new data in the following:\n            // if new, push to 'add'\n            // if update, push to 'update'\n            // if not changed, do not include in the transaction\n            rowData.forEach((data: any, index: number) => {\n                const id: string = getRowIdFunc({ data, level: 0 });\n                const existingNode: RowNode | undefined = existingNodesMap[id];\n\n                if (orderMap) {\n                    orderMap[id] = index;\n                }\n\n                if (existingNode) {\n                    const dataHasChanged = existingNode.data !== data;\n                    if (dataHasChanged) {\n                        transaction.update!.push(data);\n                    }\n                    // otherwise, if data not changed, we just don't include it anywhere, as it's not a delta\n\n                    // remove from list, so we know the item is not to be removed\n                    existingNodesMap[id] = undefined;\n                } else {\n                    transaction.add!.push(data);\n                }\n            });\n        }\n\n        // at this point, all rows that are left, should be removed\n        _iterateObject(existingNodesMap, (id: string, rowNode: RowNode) => {\n            if (rowNode) {\n                transaction.remove!.push(rowNode.data);\n            }\n        });\n\n        return [transaction, orderMap];\n    }\n\n    private onRowDataUpdated(): void {\n        const rowData = this.gos.get('rowData');\n        if (!rowData) {\n            return;\n        }\n\n        if (this.isActive()) {\n            this.setRowData(rowData);\n        } else {\n            this.selectionService.reset('rowDataChanged');\n            this.clientSideRowModel.setRowData(rowData);\n        }\n    }\n}\n", "import type {\n    BeanCollection,\n    ChangedPath,\n    ColumnModel,\n    FuncColsService,\n    IRowNode,\n    IShowRowGroupColsService,\n    NamedBean,\n    PostSortRowsParams,\n    RowNode,\n    RowNodeSorter,\n    RowNodeTransaction,\n    SortOption,\n    SortedRowNode,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, _errorOnce, _missing, _warnOnce } from '@ag-grid-community/core';\n\nexport class SortService extends BeanStub implements NamedBean {\n    beanName = 'sortService' as const;\n\n    private columnModel: ColumnModel;\n    private funcColsService: FuncColsService;\n    private rowNodeSorter: RowNodeSorter;\n    private showRowGroupColsService?: IShowRowGroupColsService;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.columnModel = beans.columnModel;\n        this.funcColsService = beans.funcColsService;\n        this.rowNodeSorter = beans.rowNodeSorter;\n        this.showRowGroupColsService = beans.showRowGroupColsService;\n    }\n\n    public sort(\n        sortOptions: SortOption[],\n        sortActive: boolean,\n        useDeltaSort: boolean,\n        rowNodeTransactions: RowNodeTransaction[] | null | undefined,\n        changedPath: ChangedPath | undefined,\n        sortContainsGroupColumns: boolean\n    ): void {\n        const groupMaintainOrder = this.gos.get('groupMaintainOrder');\n        const groupColumnsPresent = this.columnModel.getCols().some((c) => c.isRowGroupActive());\n\n        let allDirtyNodes: { [key: string]: true } = {};\n        if (useDeltaSort && rowNodeTransactions) {\n            allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);\n        }\n\n        const isPivotMode = this.columnModel.isPivotMode();\n        const postSortFunc = this.gos.getCallback('postSortRows');\n\n        const callback = (rowNode: RowNode) => {\n            // we clear out the 'pull down open parents' first, as the values mix up the sorting\n            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);\n\n            // It's pointless to sort rows which aren't being displayed. in pivot mode we don't need to sort the leaf group children.\n            const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;\n\n            // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,\n            // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we\n            // are going to inspect the original array position. This is what sortedRowNodes is for.\n            const skipSortingGroups =\n                groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n            if (skipSortingGroups) {\n                const nextGroup = this.funcColsService.getRowGroupColumns()?.[rowNode.level + 1];\n                // if the sort is null, then sort was explicitly removed, so remove sort from this group.\n                const wasSortExplicitlyRemoved = nextGroup?.getSort() === null;\n\n                const childrenToBeSorted = rowNode.childrenAfterAggFilter!.slice(0);\n                if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {\n                    const indexedOrders: { [key: string]: number } = {};\n                    rowNode.childrenAfterSort.forEach((node, idx) => {\n                        indexedOrders[node.id!] = idx;\n                    });\n                    childrenToBeSorted.sort(\n                        (row1, row2) => (indexedOrders[row1.id!] ?? 0) - (indexedOrders[row2.id!] ?? 0)\n                    );\n                }\n                rowNode.childrenAfterSort = childrenToBeSorted;\n            } else if (!sortActive || skipSortingPivotLeafs) {\n                // if there's no sort to make, skip this step\n                rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter!.slice(0);\n            } else if (useDeltaSort) {\n                rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath!, sortOptions);\n            } else {\n                rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter!, sortOptions);\n            }\n\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n            }\n\n            this.updateChildIndexes(rowNode);\n\n            if (postSortFunc) {\n                const params: WithoutGridCommon<PostSortRowsParams> = { nodes: rowNode.childrenAfterSort };\n                postSortFunc(params);\n            }\n        };\n\n        if (changedPath) {\n            changedPath.forEachChangedNodeDepthFirst(callback);\n        }\n\n        this.updateGroupDataForHideOpenParents(changedPath);\n    }\n\n    private calculateDirtyNodes(rowNodeTransactions?: RowNodeTransaction[] | null): { [nodeId: string]: true } {\n        const dirtyNodes: { [nodeId: string]: true } = {};\n\n        const addNodesFunc = (rowNodes: IRowNode[]) => {\n            if (rowNodes) {\n                rowNodes.forEach((rowNode) => (dirtyNodes[rowNode.id!] = true));\n            }\n        };\n\n        // all leaf level nodes in the transaction were impacted\n        if (rowNodeTransactions) {\n            rowNodeTransactions.forEach((tran) => {\n                addNodesFunc(tran.add);\n                addNodesFunc(tran.update);\n                addNodesFunc(tran.remove);\n            });\n        }\n\n        return dirtyNodes;\n    }\n\n    private doDeltaSort(\n        rowNode: RowNode,\n        allTouchedNodes: { [rowId: string]: true },\n        changedPath: ChangedPath,\n        sortOptions: SortOption[]\n    ) {\n        const unsortedRows = rowNode.childrenAfterAggFilter!;\n        const oldSortedRows = rowNode.childrenAfterSort;\n        if (!oldSortedRows) {\n            return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);\n        }\n\n        const untouchedRowsMap: { [rowId: string]: true } = {};\n        const touchedRows: RowNode[] = [];\n\n        unsortedRows.forEach((row) => {\n            if (allTouchedNodes[row.id!] || !changedPath.canSkip(row)) {\n                touchedRows.push(row);\n            } else {\n                untouchedRowsMap[row.id!] = true;\n            }\n        });\n\n        const sortedUntouchedRows = oldSortedRows.filter((child) => untouchedRowsMap[child.id!]);\n\n        const mapNodeToSortedNode = (rowNode: RowNode, pos: number): SortedRowNode => ({\n            currentPos: pos,\n            rowNode: rowNode,\n        });\n\n        const sortedChangedRows = touchedRows\n            .map(mapNodeToSortedNode)\n            .sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));\n\n        return this.mergeSortedArrays(sortOptions, sortedChangedRows, sortedUntouchedRows.map(mapNodeToSortedNode)).map(\n            ({ rowNode }) => rowNode\n        );\n    }\n\n    // Merge two sorted arrays into each other\n    private mergeSortedArrays(sortOptions: SortOption[], arr1: SortedRowNode[], arr2: SortedRowNode[]) {\n        const res = [];\n        let i = 0;\n        let j = 0;\n\n        // Traverse both array, adding them in order\n        while (i < arr1.length && j < arr2.length) {\n            // Check if current element of first\n            // array is smaller than current element\n            // of second array. If yes, store first\n            // array element and increment first array\n            // index. Otherwise do same with second array\n            const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n            if (compareResult < 0) {\n                res.push(arr1[i++]);\n            } else {\n                res.push(arr2[j++]);\n            }\n        }\n\n        // add remaining from arr1\n        while (i < arr1.length) {\n            res.push(arr1[i++]);\n        }\n\n        // add remaining from arr2\n        while (j < arr2.length) {\n            res.push(arr2[j++]);\n        }\n\n        return res;\n    }\n\n    private updateChildIndexes(rowNode: RowNode) {\n        if (_missing(rowNode.childrenAfterSort)) {\n            return;\n        }\n\n        const listToSort = rowNode.childrenAfterSort;\n        for (let i = 0; i < listToSort.length; i++) {\n            const child = listToSort[i];\n            const firstChild = i === 0;\n            const lastChild = i === rowNode.childrenAfterSort.length - 1;\n            child.setFirstChild(firstChild);\n            child.setLastChild(lastChild);\n            child.setChildIndex(i);\n        }\n    }\n\n    private updateGroupDataForHideOpenParents(changedPath?: ChangedPath) {\n        if (!this.gos.get('groupHideOpenParents')) {\n            return;\n        }\n\n        if (this.gos.get('treeData')) {\n            _warnOnce(\n                `The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.`\n            );\n            return false;\n        }\n\n        // recurse breadth first over group nodes after sort to 'pull down' group data to child groups\n        const callback = (rowNode: RowNode) => {\n            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n            rowNode.childrenAfterSort!.forEach((child) => {\n                if (child.hasChildren()) {\n                    callback(child);\n                }\n            });\n        };\n\n        if (changedPath) {\n            changedPath.executeFromRootNode((rowNode) => callback(rowNode));\n        }\n    }\n\n    private pullDownGroupDataForHideOpenParents(rowNodes: RowNode[] | null, clearOperation: boolean) {\n        if (!this.gos.get('groupHideOpenParents') || _missing(rowNodes)) {\n            return;\n        }\n\n        rowNodes.forEach((childRowNode) => {\n            const groupDisplayCols = this.showRowGroupColsService?.getShowRowGroupCols() ?? [];\n            groupDisplayCols.forEach((groupDisplayCol) => {\n                const showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n                if (typeof showRowGroup !== 'string') {\n                    _errorOnce(\n                        'groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup'\n                    );\n                    return;\n                }\n\n                const displayingGroupKey = showRowGroup;\n                const rowGroupColumn = this.columnModel.getColDefCol(displayingGroupKey);\n                const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n\n                if (thisRowNodeMatches) {\n                    return;\n                }\n\n                if (clearOperation) {\n                    // if doing a clear operation, we clear down the value for every possible group column\n                    childRowNode.setGroupValue(groupDisplayCol.getId(), undefined);\n                } else {\n                    // if doing a set operation, we set only where the pull down is to occur\n                    const parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n                    if (parentToStealFrom) {\n                        childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n                    }\n                }\n            });\n        });\n    }\n}\n", "import type {\n    BeanCollection,\n    IRowNodeStage,\n    NamedBean,\n    SortController,\n    SortOption,\n    StageExecuteParams,\n} from '@ag-grid-community/core';\nimport { BeanStub, _exists } from '@ag-grid-community/core';\n\nimport type { SortService } from './sortService';\n\nexport class SortStage extends BeanStub implements NamedBean, IRowNodeStage {\n    beanName = 'sortStage' as const;\n\n    private sortService: SortService;\n    private sortController: SortController;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.sortService = beans.sortService as SortService;\n        this.sortController = beans.sortController;\n    }\n\n    public execute(params: StageExecuteParams): void {\n        const sortOptions: SortOption[] = this.sortController.getSortOptions();\n\n        const sortActive = _exists(sortOptions) && sortOptions.length > 0;\n        const deltaSort =\n            sortActive &&\n            _exists(params.rowNodeTransactions) &&\n            // in time we can remove this check, so that delta sort is always\n            // on if transactions are present. it's off for now so that we can\n            // selectively turn it on and test it with some select users before\n            // rolling out to everyone.\n            this.gos.get('deltaSort');\n\n        const sortContainsGroupColumns = sortOptions.some((opt) => {\n            const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();\n            if (isSortingCoupled) {\n                return opt.column.isPrimary() && opt.column.isRowGroupActive();\n            }\n            return !!opt.column.getColDef().showRowGroup;\n        });\n        this.sortService.sort(\n            sortOptions,\n            sortActive,\n            deltaSort,\n            params.rowNodeTransactions,\n            params.changedPath,\n            sortContainsGroupColumns\n        );\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.3.1';\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "rowNode", "import_core"]
}
