{
  "version": 3,
  "sources": ["../../src/main.ts", "../../src/infiniteRowModelModule.ts", "../../src/infiniteRowModel/infiniteRowModel.ts", "../../src/infiniteRowModel/infiniteCache.ts", "../../src/infiniteRowModel/infiniteBlock.ts", "../../src/infiniteRowModel/infiniteRowModelApi.ts", "../../src/version.ts"],
  "sourcesContent": ["export { InfiniteRowModelModule } from './infiniteRowModelModule';\n", "import type { Module } from '@ag-grid-community/core';\nimport {\n    ModuleNames,\n    RowModelHelperService,\n    _RowNodeBlockModule,\n    _SsrmInfiniteSharedApiModule,\n} from '@ag-grid-community/core';\n\nimport { InfiniteRowModel } from './infiniteRowModel/infiniteRowModel';\nimport {\n    getInfiniteRowCount,\n    isLastRowIndexKnown,\n    purgeInfiniteCache,\n    refreshInfiniteCache,\n} from './infiniteRowModel/infiniteRowModelApi';\nimport { VERSION } from './version';\n\nexport const InfiniteRowModelCoreModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.InfiniteRowModelModule}-core`,\n    rowModel: 'infinite',\n    beans: [InfiniteRowModel],\n    dependantModules: [_RowNodeBlockModule],\n};\n\nexport const InfiniteRowModelApiModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.InfiniteRowModelModule}-api`,\n    beans: [RowModelHelperService],\n    apiFunctions: {\n        refreshInfiniteCache,\n        purgeInfiniteCache,\n        getInfiniteRowCount,\n        isLastRowIndexKnown,\n    },\n    dependantModules: [InfiniteRowModelCoreModule, _SsrmInfiniteSharedApiModule],\n};\n\nexport const InfiniteRowModelModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.InfiniteRowModelModule,\n    dependantModules: [InfiniteRowModelCoreModule, InfiniteRowModelApiModule],\n};\n", "import type {\n    BeanCollection,\n    FilterManager,\n    IDatasource,\n    IInfiniteRowModel,\n    ISelectionService,\n    ModelUpdatedEvent,\n    NamedBean,\n    RowBounds,\n    RowModelType,\n    RowNode,\n    RowNodeBlockLoader,\n    RowRenderer,\n    SortController,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, NumberSequence, _jsonEquals, _warnOnce } from '@ag-grid-community/core';\n\nimport type { InfiniteCacheParams } from './infiniteCache';\nimport { InfiniteCache } from './infiniteCache';\n\nexport class InfiniteRowModel extends BeanStub implements NamedBean, IInfiniteRowModel {\n    beanName = 'rowModel' as const;\n\n    private filterManager?: FilterManager;\n    private sortController: SortController;\n    private selectionService: ISelectionService;\n    private rowRenderer: RowRenderer;\n    private rowNodeBlockLoader: RowNodeBlockLoader;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.filterManager = beans.filterManager;\n        this.sortController = beans.sortController;\n        this.selectionService = beans.selectionService;\n        this.rowRenderer = beans.rowRenderer;\n        this.rowNodeBlockLoader = beans.rowNodeBlockLoader!;\n    }\n\n    private infiniteCache: InfiniteCache | null | undefined;\n    private datasource: IDatasource | null | undefined;\n    private rowHeight: number;\n    private cacheParams: InfiniteCacheParams;\n\n    public getRowBounds(index: number): RowBounds {\n        return {\n            rowHeight: this.rowHeight,\n            rowTop: this.rowHeight * index,\n        };\n    }\n\n    // we don't implement as lazy row heights is not supported in this row model\n    public ensureRowHeightsValid(): boolean {\n        return false;\n    }\n\n    public postConstruct(): void {\n        if (!this.gos.isRowModelType('infinite')) {\n            return;\n        }\n\n        this.rowHeight = this.gos.getRowHeightAsNumber();\n\n        this.addEventListeners();\n\n        this.addDestroyFunc(() => this.destroyCache());\n\n        this.verifyProps();\n    }\n\n    private verifyProps(): void {\n        if (this.gos.exists('initialGroupOrderComparator')) {\n            _warnOnce(\n                'initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side'\n            );\n        }\n    }\n\n    public start(): void {\n        this.setDatasource(this.gos.get('datasource'));\n    }\n\n    public override destroy(): void {\n        this.destroyDatasource();\n        super.destroy();\n    }\n\n    private destroyDatasource(): void {\n        if (this.datasource) {\n            this.destroyBean(this.datasource);\n            this.rowRenderer.datasourceChanged();\n            this.datasource = null;\n        }\n    }\n\n    private addEventListeners(): void {\n        this.addManagedEventListeners({\n            filterChanged: this.onFilterChanged.bind(this),\n            sortChanged: this.onSortChanged.bind(this),\n            newColumnsLoaded: this.onColumnEverything.bind(this),\n            storeUpdated: this.onCacheUpdated.bind(this),\n        });\n\n        this.addManagedPropertyListener('datasource', () => this.setDatasource(this.gos.get('datasource')));\n        this.addManagedPropertyListener('cacheBlockSize', () => this.resetCache());\n        this.addManagedPropertyListener('rowHeight', () => {\n            this.rowHeight = this.gos.getRowHeightAsNumber();\n            this.cacheParams.rowHeight = this.rowHeight;\n            this.updateRowHeights();\n        });\n    }\n\n    private onFilterChanged(): void {\n        this.reset();\n    }\n\n    private onSortChanged(): void {\n        this.reset();\n    }\n\n    private onColumnEverything(): void {\n        let resetRequired;\n        // if cache params, we require reset only if sort model has changed. we don't need to check\n        // for filter model, as the filter manager will fire an event when columns change that result\n        // in the filter changing.\n        if (this.cacheParams) {\n            resetRequired = this.isSortModelDifferent();\n        } else {\n            // if no cacheParams, means first time creating the cache, so always create one\n            resetRequired = true;\n        }\n        if (resetRequired) {\n            this.reset();\n        }\n    }\n\n    private isSortModelDifferent(): boolean {\n        return !_jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());\n    }\n\n    public getType(): RowModelType {\n        return 'infinite';\n    }\n\n    public setDatasource(datasource: IDatasource | undefined): void {\n        this.destroyDatasource();\n        this.datasource = datasource;\n\n        // only reset if we have a valid datasource to working with\n        if (datasource) {\n            this.reset();\n        }\n    }\n\n    public isEmpty(): boolean {\n        return !this.infiniteCache;\n    }\n\n    public isRowsToRender(): boolean {\n        return !!this.infiniteCache;\n    }\n\n    public getNodesInRangeForSelection(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];\n    }\n\n    private reset() {\n        // important to return here, as the user could be setting filter or sort before\n        // data-source is set\n        if (!this.datasource) {\n            return;\n        }\n\n        // if user is providing id's, then this means we can keep the selection between datasource hits,\n        // as the rows will keep their unique id's even if, for example, server side sorting or filtering\n        // is done.\n        const getRowIdFunc = this.gos.getRowIdCallback();\n        const userGeneratingIds = getRowIdFunc != null;\n\n        if (!userGeneratingIds) {\n            this.selectionService.reset('rowDataChanged');\n        }\n\n        this.resetCache();\n    }\n\n    private createModelUpdatedEvent(): WithoutGridCommon<ModelUpdatedEvent> {\n        return {\n            type: 'modelUpdated',\n            // not sure if these should all be false - noticed if after implementing,\n            // maybe they should be true?\n            newPage: false,\n            newPageSize: false,\n            newData: false,\n            keepRenderedRows: true,\n            animate: false,\n        };\n    }\n\n    private resetCache(): void {\n        // if not first time creating a cache, need to destroy the old one\n        this.destroyCache();\n\n        this.cacheParams = {\n            // the user provided datasource\n            datasource: this.datasource,\n\n            // sort and filter model\n            filterModel: this.filterManager?.getFilterModel() ?? {},\n            sortModel: this.sortController.getSortModel(),\n\n            rowNodeBlockLoader: this.rowNodeBlockLoader,\n\n            // properties - this way we take a snapshot of them, so if user changes any, they will be\n            // used next time we create a new cache, which is generally after a filter or sort change,\n            // or a new datasource is set\n            initialRowCount: this.gos.get('infiniteInitialRowCount'),\n            maxBlocksInCache: this.gos.get('maxBlocksInCache'),\n            rowHeight: this.gos.getRowHeightAsNumber(),\n\n            // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n            // the current page and request first row of next page\n            overflowSize: this.gos.get('cacheOverflowSize'),\n\n            // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n            // server for one page at a time. so the default if not specified is 100.\n            blockSize: this.gos.get('cacheBlockSize'),\n\n            // the cache could create this, however it is also used by the pages, so handy to create it\n            // here as the settings are also passed to the pages\n            lastAccessedSequence: new NumberSequence(),\n        } as InfiniteCacheParams;\n\n        this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));\n\n        this.eventService.dispatchEventOnce({\n            type: 'rowCountReady',\n        });\n\n        const event = this.createModelUpdatedEvent();\n        this.eventService.dispatchEvent(event);\n    }\n\n    private updateRowHeights() {\n        this.forEachNode((node) => {\n            node.setRowHeight(this.rowHeight);\n            node.setRowTop(this.rowHeight * node.rowIndex!);\n        });\n\n        const event = this.createModelUpdatedEvent();\n        this.eventService.dispatchEvent(event);\n    }\n\n    private destroyCache(): void {\n        if (this.infiniteCache) {\n            this.infiniteCache = this.destroyBean(this.infiniteCache);\n        }\n    }\n\n    private onCacheUpdated(): void {\n        const event = this.createModelUpdatedEvent();\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getRow(rowIndex: number): RowNode | undefined {\n        if (!this.infiniteCache) {\n            return undefined;\n        }\n        if (rowIndex >= this.infiniteCache.getRowCount()) {\n            return undefined;\n        }\n        return this.infiniteCache.getRow(rowIndex);\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        let result: RowNode | undefined;\n        this.forEachNode((rowNode) => {\n            if (rowNode.id === id) {\n                result = rowNode;\n            }\n        });\n        return result;\n    }\n\n    public forEachNode(callback: (rowNode: RowNode, index: number) => void): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.forEachNodeDeep(callback);\n        }\n    }\n\n    public getTopLevelRowCount(): number {\n        return this.getRowCount();\n    }\n\n    public getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        return topLevelIndex;\n    }\n\n    public getRowIndexAtPixel(pixel: number): number {\n        if (this.rowHeight !== 0) {\n            // avoid divide by zero error\n            const rowIndexForPixel = Math.floor(pixel / this.rowHeight);\n            const lastRowIndex = this.getRowCount() - 1;\n            if (rowIndexForPixel > lastRowIndex) {\n                return lastRowIndex;\n            }\n            return rowIndexForPixel;\n        }\n        return 0;\n    }\n\n    public getRowCount(): number {\n        return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;\n    }\n\n    public isRowPresent(rowNode: RowNode): boolean {\n        const foundRowNode = this.getRowNode(rowNode.id!);\n        return !!foundRowNode;\n    }\n\n    public refreshCache(): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.refreshCache();\n        }\n    }\n\n    public purgeCache(): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.purgeCache();\n        }\n    }\n\n    // for iRowModel\n    public isLastRowIndexKnown(): boolean {\n        if (this.infiniteCache) {\n            return this.infiniteCache.isLastRowIndexKnown();\n        }\n        return false;\n    }\n\n    public setRowCount(rowCount: number, lastRowIndexKnown?: boolean): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);\n        }\n    }\n}\n", "import type {\n    BeanCollection,\n    FocusService,\n    IDatasource,\n    RowNode,\n    RowNodeBlockLoader,\n    RowRenderer,\n    SortModelItem,\n    StoreUpdatedEvent,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { BeanStub, NumberSequence, _exists, _getAllValuesInObject, _log, _missing } from '@ag-grid-community/core';\n\nimport { InfiniteBlock } from './infiniteBlock';\n\nexport interface InfiniteCacheParams {\n    datasource: IDatasource;\n    initialRowCount: number;\n    blockSize?: number;\n    overflowSize: number;\n    sortModel: SortModelItem[];\n    filterModel: any;\n    maxBlocksInCache?: number;\n    rowHeight: number;\n    lastAccessedSequence: NumberSequence;\n    rowNodeBlockLoader?: RowNodeBlockLoader;\n    dynamicRowHeight: boolean;\n}\n\n// this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n// blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n// scrolled over are not needed to be loaded.\nconst MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n\nexport class InfiniteCache extends BeanStub {\n    protected rowRenderer: RowRenderer;\n    private focusService: FocusService;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.rowRenderer = beans.rowRenderer;\n        this.focusService = beans.focusService;\n    }\n\n    private readonly params: InfiniteCacheParams;\n\n    private rowCount: number;\n    private lastRowIndexKnown = false;\n\n    private blocks: { [blockNumber: string]: InfiniteBlock } = {};\n    private blockCount = 0;\n\n    constructor(params: InfiniteCacheParams) {\n        super();\n        this.rowCount = params.initialRowCount;\n        this.params = params;\n    }\n\n    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,\n    // it will want new pages in the cache as it asks for rows. only when we are inserting /\n    // removing rows via the api is dontCreatePage set, where we move rows between the pages.\n    public getRow(rowIndex: number, dontCreatePage = false): RowNode | undefined {\n        const blockId = Math.floor(rowIndex / this.params.blockSize!);\n        let block = this.blocks[blockId];\n\n        if (!block) {\n            if (dontCreatePage) {\n                return undefined;\n            }\n            block = this.createBlock(blockId);\n        }\n\n        return block.getRow(rowIndex);\n    }\n\n    private createBlock(blockNumber: number): InfiniteBlock {\n        const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));\n\n        this.blocks[newBlock.getId()] = newBlock;\n        this.blockCount++;\n\n        this.purgeBlocksIfNeeded(newBlock);\n\n        this.params.rowNodeBlockLoader!.addBlock(newBlock);\n\n        return newBlock;\n    }\n\n    // we have this on infinite row model only, not server side row model,\n    // because for server side, it would leave the children in inconsistent\n    // state - eg if a node had children, but after the refresh it had data\n    // for a different row, then the children would be with the wrong row node.\n    public refreshCache(): void {\n        const nothingToRefresh = this.blockCount == 0;\n        if (nothingToRefresh) {\n            this.purgeCache();\n            return;\n        }\n\n        this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());\n        this.params.rowNodeBlockLoader!.checkBlockToLoad();\n    }\n\n    public override destroy(): void {\n        this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));\n        super.destroy();\n    }\n\n    public getRowCount(): number {\n        return this.rowCount;\n    }\n\n    public isLastRowIndexKnown(): boolean {\n        return this.lastRowIndexKnown;\n    }\n\n    // block calls this, when page loaded\n    public pageLoaded(block: InfiniteBlock, lastRow?: number): void {\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isAlive()) {\n            return;\n        }\n\n        if (this.gos.get('debug')) {\n            _log(`InfiniteCache - onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);\n        }\n\n        this.checkRowCount(block, lastRow);\n        // we fire cacheUpdated even if the row count has not changed, as some items need updating even\n        // if no new rows to render. for example the pagination panel has '?' as the total rows when loading\n        // is underway, which would need to get updated when loading finishes.\n        this.onCacheUpdated();\n    }\n\n    private purgeBlocksIfNeeded(blockToExclude: InfiniteBlock): void {\n        // we exclude checking for the page just created, as this has yet to be accessed and hence\n        // the lastAccessed stamp will not be updated for the first time yet\n        const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);\n        const lastAccessedComparator = (a: InfiniteBlock, b: InfiniteBlock) =>\n            b.getLastAccessed() - a.getLastAccessed();\n        blocksForPurging.sort(lastAccessedComparator);\n\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        const maxBlocksProvided = this.params.maxBlocksInCache! > 0;\n        const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache! - 1 : null;\n        const emptyBlocksToKeep = MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n\n        blocksForPurging.forEach((block: InfiniteBlock, index: number) => {\n            const purgeBecauseBlockEmpty = block.getState() === 'needsLoading' && index >= emptyBlocksToKeep;\n\n            const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep! : false;\n\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n                // if the block currently has rows been displayed, then don't remove it either.\n                // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n                // but the screen is showing 20 rows, so at least 4 blocks are needed.\n                if (this.isBlockCurrentlyDisplayed(block)) {\n                    return;\n                }\n\n                // don't want to loose keyboard focus, so keyboard navigation can continue. so keep focused blocks.\n                if (this.isBlockFocused(block)) {\n                    return;\n                }\n\n                // at this point, block is not needed, so burn baby burn\n                this.removeBlockFromCache(block);\n            }\n        });\n    }\n\n    private isBlockFocused(block: InfiniteBlock): boolean {\n        const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n        if (!focusedCell) {\n            return false;\n        }\n        if (focusedCell.rowPinned != null) {\n            return false;\n        }\n\n        const blockIndexStart = block.getStartRow();\n        const blockIndexEnd = block.getEndRow();\n\n        const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n        return hasFocus;\n    }\n\n    private isBlockCurrentlyDisplayed(block: InfiniteBlock): boolean {\n        const startIndex = block.getStartRow();\n        const endIndex = block.getEndRow() - 1;\n        return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n    }\n\n    private removeBlockFromCache(blockToRemove: InfiniteBlock): void {\n        if (!blockToRemove) {\n            return;\n        }\n\n        this.destroyBlock(blockToRemove);\n\n        // we do not want to remove the 'loaded' event listener, as the\n        // concurrent loads count needs to be updated when the load is complete\n        // if the purged page is in loading state\n    }\n\n    private checkRowCount(block: InfiniteBlock, lastRow?: number): void {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.rowCount = lastRow;\n            this.lastRowIndexKnown = true;\n        } else if (!this.lastRowIndexKnown) {\n            // otherwise, see if we need to add some virtual rows\n            const lastRowIndex = (block.getId() + 1) * this.params.blockSize!;\n            const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;\n\n            if (this.rowCount < lastRowIndexPlusOverflow) {\n                this.rowCount = lastRowIndexPlusOverflow;\n            }\n        }\n    }\n\n    public setRowCount(rowCount: number, lastRowIndexKnown?: boolean): void {\n        this.rowCount = rowCount;\n\n        // if undefined is passed, we do not set this value, if one of {true,false}\n        // is passed, we do set the value.\n        if (_exists(lastRowIndexKnown)) {\n            this.lastRowIndexKnown = lastRowIndexKnown;\n        }\n\n        // if we are still searching, then the row count must not end at the end\n        // of a particular page, otherwise the searching will not pop into the\n        // next page\n        if (!this.lastRowIndexKnown) {\n            if (this.rowCount % this.params.blockSize! === 0) {\n                this.rowCount++;\n            }\n        }\n\n        this.onCacheUpdated();\n    }\n\n    public forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void): void {\n        const sequence = new NumberSequence();\n        this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));\n    }\n\n    public getBlocksInOrder(): InfiniteBlock[] {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        const blockComparator = (a: InfiniteBlock, b: InfiniteBlock) => a.getId() - b.getId();\n        const blocks = _getAllValuesInObject(this.blocks).sort(blockComparator);\n        return blocks;\n    }\n\n    private destroyBlock(block: InfiniteBlock): void {\n        delete this.blocks[block.getId()];\n        this.destroyBean(block);\n        this.blockCount--;\n        this.params.rowNodeBlockLoader!.removeBlock(block);\n    }\n\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    private onCacheUpdated(): void {\n        if (this.isAlive()) {\n            // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n            // in the valid range. so we must remove these. this can happen if user explicitly sets\n            // the virtual row count, or the datasource returns a result and sets lastRow to something\n            // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).\n            this.destroyAllBlocksPastVirtualRowCount();\n\n            // this results in both row models (infinite and server side) firing ModelUpdated,\n            // however server side row model also updates the row indexes first\n            const event: WithoutGridCommon<StoreUpdatedEvent> = {\n                type: 'storeUpdated',\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    private destroyAllBlocksPastVirtualRowCount(): void {\n        const blocksToDestroy: InfiniteBlock[] = [];\n        this.getBlocksInOrder().forEach((block) => {\n            const startRow = block.getId() * this.params.blockSize!;\n            if (startRow >= this.rowCount) {\n                blocksToDestroy.push(block);\n            }\n        });\n        if (blocksToDestroy.length > 0) {\n            blocksToDestroy.forEach((block) => this.destroyBlock(block));\n        }\n    }\n\n    public purgeCache(): void {\n        this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));\n        this.lastRowIndexKnown = false;\n        // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n        // otherwise if set to zero rows last time, and we don't update the row count, then after\n        // the purge there will still be zero rows, meaning the SSRM won't request any rows.\n        // to kick things off, at least one row needs to be asked for.\n        if (this.rowCount === 0) {\n            this.rowCount = this.params.initialRowCount;\n        }\n\n        this.onCacheUpdated();\n    }\n\n    public getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        const result: RowNode[] = [];\n\n        let lastBlockId = -1;\n        let inActiveRange = false;\n        const numberSequence: NumberSequence = new NumberSequence();\n\n        let foundGapInSelection = false;\n\n        this.getBlocksInOrder().forEach((block) => {\n            if (foundGapInSelection) {\n                return;\n            }\n\n            if (inActiveRange && lastBlockId + 1 !== block.getId()) {\n                foundGapInSelection = true;\n                return;\n            }\n\n            lastBlockId = block.getId();\n\n            block.forEachNode(\n                (rowNode) => {\n                    const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                    if (inActiveRange || hitFirstOrLast) {\n                        result.push(rowNode);\n                    }\n\n                    if (hitFirstOrLast) {\n                        inActiveRange = !inActiveRange;\n                    }\n                },\n                numberSequence,\n                this.rowCount\n            );\n        });\n\n        // inActiveRange will be still true if we never hit the second rowNode\n        const invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    }\n}\n", "import type { BeanCollection, IGetRowsParams, LoadSuccessParams, NumberSequence } from '@ag-grid-community/core';\nimport { RowNode, RowNodeBlock, _exists, _missing, _warnOnce } from '@ag-grid-community/core';\n\nimport type { InfiniteCache, InfiniteCacheParams } from './infiniteCache';\n\nexport class InfiniteBlock extends RowNodeBlock {\n    private beans: BeanCollection;\n\n    public wireBeans(beans: BeanCollection): void {\n        this.beans = beans;\n    }\n\n    private readonly startRow: number;\n    private readonly endRow: number;\n    private readonly parentCache: InfiniteCache;\n\n    private params: InfiniteCacheParams;\n\n    private lastAccessed: number;\n\n    public rowNodes: RowNode[];\n\n    constructor(id: number, parentCache: InfiniteCache, params: InfiniteCacheParams) {\n        super(id);\n\n        this.parentCache = parentCache;\n        this.params = params;\n\n        // we don't need to calculate these now, as the inputs don't change,\n        // however it makes the code easier to read if we work them out up front\n        this.startRow = id * params.blockSize!;\n        this.endRow = this.startRow + params.blockSize!;\n    }\n\n    public postConstruct(): void {\n        this.createRowNodes();\n    }\n\n    public getBlockStateJson(): { id: string; state: any } {\n        return {\n            id: '' + this.getId(),\n            state: {\n                blockNumber: this.getId(),\n                startRow: this.getStartRow(),\n                endRow: this.getEndRow(),\n                pageStatus: this.getState(),\n            },\n        };\n    }\n\n    protected setDataAndId(rowNode: RowNode, data: any, index: number): void {\n        if (_exists(data)) {\n            // this means if the user is not providing id's we just use the\n            // index for the row. this will allow selection to work (that is based\n            // on index) as long user is not inserting or deleting rows,\n            // or wanting to keep selection between server side sorting or filtering\n            rowNode.setDataAndId(data, index.toString());\n        } else {\n            rowNode.setDataAndId(undefined, undefined);\n        }\n    }\n\n    protected loadFromDatasource(): void {\n        const params = this.createLoadParams();\n        if (_missing(this.params.datasource.getRows)) {\n            _warnOnce(`datasource is missing getRows method`);\n            return;\n        }\n\n        // put in timeout, to force result to be async\n        window.setTimeout(() => {\n            this.params.datasource.getRows(params);\n        }, 0);\n    }\n\n    protected processServerFail(): void {\n        // todo - this method has better handling in SSRM\n    }\n\n    protected createLoadParams(): any {\n        // PROBLEM . . . . when the user sets sort via colDef.sort, then this code\n        // is executing before the sort is set up, so server is not getting the sort\n        // model. need to change with regards order - so the server side request is\n        // AFTER thus it gets the right sort model.\n        const params: IGetRowsParams = {\n            startRow: this.getStartRow(),\n            endRow: this.getEndRow(),\n            successCallback: this.pageLoaded.bind(this, this.getVersion()),\n            failCallback: this.pageLoadFailed.bind(this, this.getVersion()),\n            sortModel: this.params.sortModel,\n            filterModel: this.params.filterModel,\n            context: this.gos.getGridCommonParams().context,\n        };\n        return params;\n    }\n\n    public forEachNode(\n        callback: (rowNode: RowNode, index: number) => void,\n        sequence: NumberSequence,\n        rowCount: number\n    ): void {\n        this.rowNodes.forEach((rowNode: RowNode, index: number) => {\n            const rowIndex = this.startRow + index;\n            if (rowIndex < rowCount) {\n                callback(rowNode, sequence.next());\n            }\n        });\n    }\n\n    public getLastAccessed(): number {\n        return this.lastAccessed;\n    }\n\n    public getRow(rowIndex: number, dontTouchLastAccessed = false): RowNode {\n        if (!dontTouchLastAccessed) {\n            this.lastAccessed = this.params.lastAccessedSequence.next();\n        }\n        const localIndex = rowIndex - this.startRow;\n        return this.rowNodes[localIndex];\n    }\n\n    public getStartRow(): number {\n        return this.startRow;\n    }\n\n    public getEndRow(): number {\n        return this.endRow;\n    }\n\n    // creates empty row nodes, data is missing as not loaded yet\n    protected createRowNodes(): void {\n        this.rowNodes = [];\n        for (let i = 0; i < this.params.blockSize!; i++) {\n            const rowIndex = this.startRow + i;\n\n            const rowNode = new RowNode(this.beans);\n\n            rowNode.setRowHeight(this.params.rowHeight);\n            rowNode.uiLevel = 0;\n            rowNode.setRowIndex(rowIndex);\n            rowNode.setRowTop(this.params.rowHeight * rowIndex);\n\n            this.rowNodes.push(rowNode);\n        }\n    }\n\n    protected processServerResult(params: LoadSuccessParams): void {\n        this.rowNodes.forEach((rowNode: RowNode, index: number) => {\n            const data = params.rowData ? params.rowData[index] : undefined;\n\n            if (!rowNode.id && rowNode.alreadyRendered && data) {\n                // if the node had no id and was rendered, but we have data for it now, then\n                // destroy the old row and copy its position into new row. This prevents an additional\n                // set of events being fired as the row renderer tries to understand the changing id\n                this.rowNodes[index] = new RowNode(this.beans);\n                this.rowNodes[index].setRowIndex(rowNode.rowIndex!);\n                this.rowNodes[index].setRowTop(rowNode.rowTop!);\n                this.rowNodes[index].setRowHeight(rowNode.rowHeight!);\n\n                // clean up the old row\n                rowNode.clearRowTopAndRowIndex();\n            }\n            this.setDataAndId(this.rowNodes[index], data, this.startRow + index);\n        });\n        const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : undefined;\n        this.parentCache.pageLoaded(this, finalRowCount);\n    }\n\n    public override destroy(): void {\n        this.rowNodes.forEach((rowNode) => {\n            // this is needed, so row render knows to fade out the row, otherwise it\n            // sees row top is present, and thinks the row should be shown.\n            rowNode.clearRowTopAndRowIndex();\n        });\n        super.destroy();\n    }\n}\n", "import type { BeanCollection } from '@ag-grid-community/core';\n\nexport function refreshInfiniteCache(beans: BeanCollection): void {\n    beans.rowModelHelperService?.getInfiniteRowModel()?.refreshCache();\n}\n\nexport function purgeInfiniteCache(beans: BeanCollection): void {\n    beans.rowModelHelperService?.getInfiniteRowModel()?.purgeCache();\n}\n\nexport function getInfiniteRowCount(beans: BeanCollection): number | undefined {\n    return beans.rowModelHelperService?.getInfiniteRowModel()?.getRowCount();\n}\n\nexport function isLastRowIndexKnown(beans: BeanCollection): boolean | undefined {\n    return beans.rowModelHelperService?.getInfiniteRowModel()?.isLastRowIndexKnown();\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.3.1';\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "import_core"]
}
